"use strict";(self.webpackChunk_dashboard_features_navigation_search=self.webpackChunk_dashboard_features_navigation_search||[]).push([[494],{1117:(me,$,j)=>{j.d($,{G:()=>Ue});var f=j(4848),F=j(6072),C=j(3803),N=j.n(C),K=j(4935),D=j(738),V=j(4872),E=j(4547),_=j(6843),H=j(1027),W=j(6322),X=j(3637),ne=j(4978),ce=j(2388),ae=j(4377),Q=j(7879),ye=j(4644),Se=j(5498),ke=j(2452);const Ge=()=>{const P=window.navigator.userAgent;return P.includes("Mac")?"mac":P.includes("Windows")?"windows":P.includes("Linux")?"linux":""};var xe=j(5316),Ne=Object.defineProperty,ue=Object.getOwnPropertySymbols,Ye=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable,Qe=(P,h,I)=>h in P?Ne(P,h,{enumerable:!0,configurable:!0,writable:!0,value:I}):P[h]=I,Be=(P,h)=>{for(var I in h||(h={}))Ye.call(h,I)&&Qe(P,I,h[I]);if(ue)for(var I of ue(h))T.call(h,I)&&Qe(P,I,h[I]);return P};const qe=P=>P.length===0?"":(0,f.jsx)(D.s,{gap:4,children:P.map((h,I)=>(0,f.jsxs)(D.s,{gap:4,align:"center",children:[!!I&&(0,f.jsx)(xe.K,{size:12}),(0,f.jsx)(_.E,{size:12,color:"light",children:h})]},h))}),Ce=()=>({orgId:(Mkiconf==null?void 0:Mkiconf.org_id)||"",userId:(Mkiconf==null?void 0:Mkiconf.user_eid)||"",timestamp:new Date().toISOString()}),Te=({itemIndex:P})=>{const{filteredMenuData:h,currentFocusedItem:I,searchInputVal:A}=(0,F.useContext)(ke.Z),O=(0,F.useRef)(null);if((0,F.useEffect)(()=>{O&&O.current&&I===P&&O.current.focus()},[P,I]),!h[P-1]||!h[P-1].item)return null;const S=h[P-1].item;if(!S.url)return null;const{title:B="",iconKind:J,breadcrumbs:e=[],url:be=""}=S,ve=e.map(Ke=>Ke.name);return ve.push(B),(0,f.jsx)(ae.N,{href:`${be}`,size:"md",ref:O,onClick:()=>{(0,Q.vR)({category:"navigation",data:Be({component:"search-menu-link",title:B,url:be,searchKeyword:A},Ce()),event:"click",id:"trigger_search_button_analytics",component:"link"})},children:(0,f.jsxs)(D.s,{direction:"vertical",gap:2,style:{padding:10},children:[(0,f.jsx)(_.E,{size:"p3",weight:"semi-bold",children:B}),(0,f.jsxs)(D.s,{direction:"horizontal",gap:2,align:"center",children:[(0,f.jsx)(ye.In,{kind:J,style:{transform:"scale(0.75)"}}),qe(ve)]})]})},ve.join("-"))};var Ve=j(7478),We=j.n(Ve),De=j(2607),Re={};Re.insert="head",Re.singleton=!1;var Ee=We()(De.A,Re);const k=De.A.locals||{};var ze=j(4209);const Le=()=>({orgId:Mkiconf==null?void 0:Mkiconf.org_id,orgName:Mkiconf==null?void 0:Mkiconf.org_name,userId:Mkiconf==null?void 0:Mkiconf.user_eid,networkName:Mkiconf==null?void 0:Mkiconf.network_name,timestamp:new Date().toISOString()}),Ie=({closeForm:P})=>{const h="https://ciscocx.qualtrics.com/jfe/form/SV_8B5jNkBg27hAkqW",I=(0,F.useRef)(null);return(0,F.useEffect)(()=>{const A=()=>{setTimeout(()=>{var S,B;(B=(S=I.current)==null?void 0:S.contentWindow)==null||B.postMessage({type:"userInfo",value:Le()},h)},500)},O=I.current;return O&&O.addEventListener("load",A),()=>{O&&O.removeEventListener("load",A)}},[]),(0,f.jsx)(f.Fragment,{children:(0,f.jsxs)(D.s,{direction:"vertical",gap:16,children:[(0,f.jsx)(V.a.Content,{className:"feedback-form",children:(0,f.jsx)("iframe",{ref:I,id:"survey-iframe",src:h,width:720,height:540})}),(0,f.jsx)(D.s,{direction:"horizontal",justify:"flex-end",children:(0,f.jsx)(ze.$.Group,{children:(0,f.jsx)(ze.$,{kind:"tertiary",onClick:()=>P(!1),children:"Back to search"})})})]})})};var Ze=Object.defineProperty,R=Object.getOwnPropertySymbols,L=Object.prototype.hasOwnProperty,G=Object.prototype.propertyIsEnumerable,ee=(P,h,I)=>h in P?Ze(P,h,{enumerable:!0,configurable:!0,writable:!0,value:I}):P[h]=I,he=(P,h)=>{for(var I in h||(h={}))L.call(h,I)&&ee(P,I,h[I]);if(R)for(var I of R(h))G.call(h,I)&&ee(P,I,h[I]);return P};const we=Ge(),_e=()=>(0,f.jsxs)(D.s,{direction:"horizontal",children:[(0,f.jsxs)(D.s,{direction:"horizontal",children:[(0,f.jsx)(_.E,{color:"grey",children:"Move:"}),(0,f.jsx)(D.s,{direction:"vertical",align:"baseline",children:(0,f.jsx)("kbd",{children:(0,f.jsx)(H.D,{size:16})})}),(0,f.jsxs)(D.s,{direction:"vertical",align:"baseline",children:[(0,f.jsx)("kbd",{children:(0,f.jsx)(W.y,{size:16})})," "]})]}),(0,f.jsxs)(D.s,{direction:"horizontal",children:[(0,f.jsx)(_.E,{color:"grey",children:"Select: "}),(0,f.jsx)(D.s,{direction:"vertical",align:"baseline",children:(0,f.jsx)("kbd",{children:(0,f.jsx)(X.S,{size:16})})})]}),(0,f.jsxs)(D.s,{direction:"horizontal",children:[(0,f.jsx)(_.E,{color:"grey",children:"Close: "}),(0,f.jsx)(D.s,{direction:"vertical",align:"baseline",children:(0,f.jsx)("kbd",{children:"Esc"})})]})]}),je=()=>({orgId:(Mkiconf==null?void 0:Mkiconf.org_id)||"",userId:(Mkiconf==null?void 0:Mkiconf.user_eid)||"",timestamp:new Date().toISOString()}),Ue=({menu:P})=>{const{isSearchModalOpen:h,setIsSearchModalOpen:I,searchInputVal:A,setSearchInputVal:O,filteredMenuData:S,setFilteredMenuData:B,currentFocusedItem:J,setCurrentFocusedId:e,isFeedbackFormModalOpen:be,setIsFeedbackFormModalOpen:ve}=(0,F.useContext)(ke.Z),Ke=new Se.A(P,{findAllMatches:!0,threshold:0,ignoreLocation:!0,minMatchCharLength:1,keys:[{name:"title",weight:1},{name:"keywords",weight:2}]}),Xe=()=>{O(""),e(0),B([])},ht=te=>{var Pe,ft;const{code:Oe,metaKey:zt,ctrlKey:w,shiftKey:b}=te;we==="mac"&&Oe==="KeyK"&&zt||we==="windows"&&Oe==="KeyK"&&w?(te.preventDefault(),te.stopPropagation(),He("hotkey")):Oe==="ArrowUp"||Oe==="Tab"&&b?J>0&&(te.preventDefault(),te.stopPropagation(),e(J-1)):Oe==="ArrowDown"||Oe==="Tab"?J<S.length&&(te.preventDefault(),te.stopPropagation(),e(J+1)):Oe==="Escape"?$e():Oe==="Enter"&&J===0&&S.length>0&&(ft=(Pe=S[0])==null?void 0:Pe.item)!=null&&ft.url&&((0,Q.vR)({category:"navigation",data:he({component:"search-menu-link",title:S[0].item.title,url:S[0].item.url},je()),event:"click",id:"trigger_search_button_analytics",component:"link"}),window.location.href=S[0].item.url)},He=te=>{I(!0),(0,Q.vR)({category:"navigation",data:he({navigationOption:"search-menu-loaded",loadType:te},je()),event:"click",id:"trigger_search_modal_analytics",component:"modal"})},$e=()=>{I(!1),Xe(),(0,Q.vR)({category:"navigation",data:he({navigationOption:"search-menu-closed"},je()),event:"click",id:"trigger_search_modal_analytics",component:"modal"})},et=te=>{te.target instanceof HTMLElement&&te.target.classList.contains("mds-rebuild-modal-overlay")&&$e()};(0,F.useEffect)(()=>{var te;document.querySelector("#nav-controls section")&&((te=document.querySelector("#nav-controls section:last-child"))==null||te.appendChild(document.getElementById("navigation_search")))},[]),(0,F.useEffect)(()=>(document.addEventListener("keydown",ht),document.addEventListener("click",et),()=>{document.removeEventListener("keydown",ht),document.removeEventListener("click",et)}),[S,J]);const bt=(0,F.useCallback)(N()(te=>{(0,Q.vR)({component:"input",category:"navigation",data:he({searchKeyword:te,navigationOption:"search-menu-input"},je()),event:"change",id:"trigger_search_input_analytics"})},300),[]),Je=te=>{const Pe=te.target.value;O(Pe),e(0),bt(te.target.value),Pe.length===0?B([]):B(Ke.search(Pe).slice(0,10))};return(0,f.jsxs)(f.Fragment,{children:[(0,f.jsx)(ye.so.Divider,{}),(0,f.jsx)(K.m,{placement:"right",className:"nav-search-tooltip-message",title:we==="mac"?"\u2318 K":"Ctrl+K",children:(0,f.jsx)(ye.so,{initialIsCollapsed:!1,className:"search-menu-nav",children:(0,f.jsx)(ye.so.Item,{className:"search-menu-label",icon:(0,f.jsx)(ye.In,{kind:"investigate"}),onClick:()=>He("click"),isSelected:h,label:"Find in Menu"})})}),(0,f.jsx)(D.s,{direction:"vertical",gap:16,className:"search-menu-modal",children:(0,f.jsxs)(V.a,{isOpen:h,size:"lg",className:"nav-search-modal",children:[(0,f.jsxs)(D.s,{direction:"vertical",gap:8,children:[!be&&(0,f.jsx)(E.pd,{placeholder:"Find pages & features",label:"",value:A,onChange:te=>Je(te),prefix:(0,f.jsx)(ne.e,{size:20}),onClear:()=>Xe(),style:{height:30},autoFocus:!0,"data-testid":"search-menu-input",size:"lg"}),!be&&A.length>0&&(0,f.jsxs)(f.Fragment,{children:[(0,f.jsx)(V.a.Content,{className:"filtered-data",children:S.length>0?(0,f.jsx)(D.s,{direction:"vertical","data-testid":"filtered-data-list",children:S.map((te,Pe)=>(0,f.jsx)(Te,{itemIndex:Pe+1},Pe))}):(0,f.jsx)(f.Fragment,{children:(0,f.jsxs)(D.s,{direction:"vertical",gap:2,align:"center",justify:"center",children:[(0,f.jsx)(ce.S.Info,{width:120,height:120}),(0,f.jsx)(_.E,{color:"grey",size:"xs",align:"center",children:"No match found"})]})})}),(0,f.jsx)(D.s,{direction:"vertical",justify:"flex-end",gap:24,children:(0,f.jsxs)(D.s,{direction:"horizontal",justify:"space-between",align:"center",children:[_e(),(0,f.jsx)(ae.N,{onClick:()=>ve(!0),children:"Give feedback"})]})})]})]}),be&&(0,f.jsx)(Ie,{closeForm:ve})]})})]})}},1317:(me,$,j)=>{j.d($,{lX:()=>D,_j:()=>f,xy:()=>F});var f=function(V,E,_){return function(H,W){if(W?.ok){var X=V.safeParse(H);if(!X.success){var ne=_?" with args ".concat(JSON.stringify(_)):"";console.warn("".concat(E).concat(ne," returned unexpected data:"),X.error)}}return H}},F=function(){for(var V=[],E=0;E<arguments.length;E++)V[E]=arguments[E];return function(_,H){return f.apply(void 0,V)(_,H?.response)}},C=function(){return C=Object.assign||function(V){for(var E,_=1,H=arguments.length;_<H;_++){E=arguments[_];for(var W in E)Object.prototype.hasOwnProperty.call(E,W)&&(V[W]=E[W])}return V},C.apply(this,arguments)},N={"access-manager":"access-manager","adaptive-policy":"policies",admin:"admin",assurance:"assurance",cameras:"cameras","cellular-gateway":"cellular-gateway",cloud:"multicloud",extend:"systems-manager","global-overview":"global-overview",help:"help",insight:"meraki-insight",monitor:"monitor","network-wide":"network-wide",organization:"organization","secure-connect":"secure-connect","security-sd-wan":"security",sensors:"sensors",switching:"switching","systems-manager":"systems-manager","teleworker-gateway":"teleworker-gateway",wireless:"wireless",automation:"workflows"};function K(V){return V.map(function(E){var _;return C(C({},E),{iconKind:(_=N[E.key])!==null&&_!==void 0?_:"placeholder",sections:E.sections.map(function(H){return C(C({},H),{items:H.items.map(function(W){var X;return C(C({},W),{iconKind:(X=N[E.key])!==null&&X!==void 0?X:"placeholder"})})})})})})}function D(V){return{categories:K(V.categories),globalCategories:K(V.globalCategories)}}},1735:(me,$,j)=>{j.d($,{v1:()=>D});var f=j(1558),F=j(4337),C=j.n(F),N=j(2235),K=j(5586),D=(0,f.xP)({reducerPath:"@dashboard/store/v1",baseQuery:(0,F.fetchBaseQuery)({baseUrl:"/api/v1/",paramsSerializer:N.DK,transformHeaders:K.P}),endpoints:function(){return{}}})},2374:(me,$,j)=>{j.d($,{D:()=>ye});var f=j(7869),F=f.d.injectEndpoints({endpoints:function(h){return{getGlobalMenu:h.query({query:function(){return"administered/navigation/menu"}})}}}),C=F.useGetGlobalMenuQuery,N=f.d.enhanceEndpoints({addTagTypes:["UserSession"]}).injectEndpoints({endpoints:function(h){return{getUserSession:h.query({query:function(){return"userSession/attributes"},providesTags:["UserSession"]})}}}),K=N.useGetUserSessionQuery,D=f.d.enhanceEndpoints({addTagTypes:["UserPermissions"]}).injectEndpoints({endpoints:function(h){return{getUserPermissions:h.query({query:function(){return"identities/me/permissions"},providesTags:["UserPermissions"]})}}}),V=D.useGetUserPermissionsQuery,E=f.d.enhanceEndpoints({addTagTypes:["UserSession/dashboardPreferences"]}).injectEndpoints({endpoints:function(h){return{getUserDashboardPreferences:h.query({query:function(){return"userSession/dashboardPreferences"},providesTags:["UserSession/dashboardPreferences"]})}}}),_=E.useGetUserDashboardPreferencesQuery,H=f.d.enhanceEndpoints({addTagTypes:["HeaderUrls"]}).injectEndpoints({endpoints:function(h){return{getHeaderUrls:h.query({query:function(){return"headerUrls"},providesTags:["HeaderUrls"]})}}}),W=H.useGetHeaderUrlsQuery,X=f.d.injectEndpoints({endpoints:function(h){return{getShardContext:h.query({query:function(){return"shardContext"}})}}}),ne=X.useGetShardContextQuery,ce=j(1317),ae=function(h,I){var A={};for(var O in h)Object.prototype.hasOwnProperty.call(h,O)&&I.indexOf(O)<0&&(A[O]=h[O]);if(h!=null&&typeof Object.getOwnPropertySymbols=="function")for(var S=0,O=Object.getOwnPropertySymbols(h);S<O.length;S++)I.indexOf(O[S])<0&&Object.prototype.propertyIsEnumerable.call(h,O[S])&&(A[O[S]]=h[O[S]]);return A},Q=f.d.injectEndpoints({endpoints:function(h){return{getNetworkMenu:h.query({query:function(I){var A=I.networkId,O=I.forceBlankNetworkContext;return{url:"networks/".concat(A,"/navigation/menu"),params:O?{forceBlankNetworkContext:"true"}:{}}},extraOptions:{maxRetries:5},transformResponse:ce.lX}),getNetworkNavigationAccess:h.query({query:function(I){var A=I.networkId,O=ae(I,["networkId"]);return{url:"networks/".concat(A,"/navigation/access"),params:O}}})}}}),ye=Q.useGetNetworkMenuQuery,Se=Q.useGetNetworkNavigationAccessQuery,ke=f.d.enhanceEndpoints({addTagTypes:["Network"]}).injectEndpoints({endpoints:function(h){return{getNetwork:h.query({query:function(I){return"networks/".concat(I)},providesTags:function(I,A,O){return[{type:"Network",id:O}]}})}}}),Ge=ke.useGetNetworkQuery,xe=f.d.injectEndpoints({endpoints:function(h){return{getMyNetworkPermissions:h.query({query:function(I){return"networks/".concat(I,"/identities/me/permissions")}})}}}),Ne=xe.useGetMyNetworkPermissionsQuery,ue=f.d.injectEndpoints({endpoints:function(h){return{getNetworkNodeGroups:h.query({query:function(I){return"networks/".concat(I,"/nodeGroups")}})}}}),Ye=ue.useGetNetworkNodeGroupsQuery,T=f.d.injectEndpoints({endpoints:function(h){return{getCounterSetRules:h.query({query:function(I){return"networks/".concat(I,"/counterSetRules")}})}}}),Qe=T.useGetCounterSetRulesQuery,Be=f.d.injectEndpoints({endpoints:function(h){return{getNetworkClientPermissions:h.query({query:function(I){var A=I.networkId,O=I.clientId;return"networks/".concat(A,"/clients/").concat(O,"/permissions")}})}}}),qe=Be.useGetNetworkClientPermissionsQuery,Ce=f.d.injectEndpoints({endpoints:function(h){return{getOrganizationMenu:h.query({query:function(I){return"organizations/".concat(I,"/navigation/menu")},extraOptions:{maxRetries:5},transformResponse:ce.lX})}}}),Te=Ce.useGetOrganizationMenuQuery,Ve=f.d.injectEndpoints({endpoints:function(h){return{getMyOrganizationPermissions:h.query({query:function(I){return"organizations/".concat(I,"/identities/me/permissions")}})}}}),We=Ve.useGetMyOrganizationPermissionsQuery,De=f.d.injectEndpoints({endpoints:function(h){return{getSupportedFeatures:h.query({query:function(I){var A=I.organizationId,O=I.features,S=I.networkIds;return{url:"organizations/".concat(A,"/supportedFeatures"),params:{features:O,networkIds:S}}}})}}}),Re=De.useGetSupportedFeaturesQuery,Ee=f.d.injectEndpoints({endpoints:function(h){return{getProductAnnouncements:h.query({query:function(I){var A=I.organizationId,O=I.timespan,S=I.showFiltered;return{url:"organizations/".concat(A,"/productAnnouncements"),params:{timespan:O,showFiltered:S}}}})}}}),k=Ee.useGetProductAnnouncementsQuery,ze=f.d.injectEndpoints({endpoints:function(h){return{getOrganizationAiAssistantStatus:h.query({query:function(I){var A=I.organizationId;return"organizations/".concat(A,"/aiAssistantStatus")}})}}}),Le=ze.useGetOrganizationAiAssistantStatusQuery,Ie=f.d.injectEndpoints({endpoints:function(h){return{getOrganization:h.query({query:function(I){var A=I.organizationId;return"organizations/".concat(A)}})}}}),Ze=Ie.useGetOrganizationQuery,R=f.d.injectEndpoints({endpoints:function(h){return{getActiveBrandingPolicy:h.query({query:function(I){return"organizations/".concat(I,"/activeBrandingPolicy")}})}}}),L=R.useGetActiveBrandingPolicyQuery,G=f.d.injectEndpoints({endpoints:function(h){return{getPromotedPageData:h.query({query:function(I){var A=I.pageId,O=I.organizationId,S=I.networkId;return{url:"pagePromotion/page/".concat(A),params:{organization_id:O,network_id:S}}}})}}}),ee=G.useGetPromotedPageDataQuery,he=f.d.injectEndpoints({endpoints:function(h){return{getDeviceAttributes:h.query({query:function(I){var A=I.serial;return"devices/".concat(A,"/attributes")}})}}}),we=he.useGetDeviceAttributesQuery,_e=f.d.enhanceEndpoints({addTagTypes:["DevicePermissions"]}).injectEndpoints({endpoints:function(h){return{getDevicePermissions:h.query({query:function(I){var A=I.serial;return"devices/".concat(A,"/permissions")},providesTags:["DevicePermissions"]})}}}),je=_e.useGetDevicePermissionsQuery,Ue=f.d.injectEndpoints({endpoints:function(h){return{getDashboardPreferencesBanners:h.query({query:function(I){return{url:"banners",params:I}}})}}}),P=Ue.useGetDashboardPreferencesBannersQuery},2452:(me,$,j)=>{j.d($,{Z:()=>X,q:()=>ne});var f=j(4848),F=j(843),C=j(6072),N=j(6014),K=Object.defineProperty,D=Object.getOwnPropertySymbols,V=Object.prototype.hasOwnProperty,E=Object.prototype.propertyIsEnumerable,_=(ce,ae,Q)=>ae in ce?K(ce,ae,{enumerable:!0,configurable:!0,writable:!0,value:Q}):ce[ae]=Q,H=(ce,ae)=>{for(var Q in ae||(ae={}))V.call(ae,Q)&&_(ce,Q,ae[Q]);if(D)for(var Q of D(ae))E.call(ae,Q)&&_(ce,Q,ae[Q]);return ce};const W={isSearchModalOpen:!1,searchInputVal:"",filteredMenuData:[],currentFocusedItem:0,isFeedbackFormModalOpen:!1,setIsSearchModalOpen:()=>null,setSearchInputVal:()=>null,setFilteredMenuData:()=>null,setCurrentFocusedId:()=>null,setIsFeedbackFormModalOpen:()=>null},X=(0,C.createContext)(H({},W)),ne=({children:ce,ctx:ae})=>(0,f.jsx)(N.Kq,{store:F.M_,children:(0,f.jsx)(X.Provider,{value:ae,children:ce})})},2518:(me,$,j)=>{var f=j(6929),F=function(){return F=Object.assign||function(w){for(var b,v=1,y=arguments.length;v<y;v++){b=arguments[v];for(var Y in b)Object.prototype.hasOwnProperty.call(b,Y)&&(w[Y]=b[Y])}return w},F.apply(this,arguments)},C=function(w,b){var v={};for(var y in w)Object.prototype.hasOwnProperty.call(w,y)&&b.indexOf(y)<0&&(v[y]=w[y]);if(w!=null&&typeof Object.getOwnPropertySymbols=="function")for(var Y=0,y=Object.getOwnPropertySymbols(w);Y<y.length;Y++)b.indexOf(y[Y])<0&&Object.prototype.propertyIsEnumerable.call(w,y[Y])&&(v[y[Y]]=w[y[Y]]);return v},N=f.u.injectEndpoints({endpoints:function(w){return{getClientUseblocks:w.query({query:function(b){var v=b.networkName,y=b.networkEid,Y=C(b,["networkName","networkEid"]);return{url:"/".concat(v,"/n/").concat(y,"/manage/usage/client_useblocks")+"?"+new URLSearchParams(F(F({},Y),{t0:Y.t0.toString(),t1:Y.t1.toString()}))}}})}}}),K=N.useGetClientUseblocksQuery,D=f.u.injectEndpoints({endpoints:function(w){return{getClientRuleUseblocks:w.query({query:function(b){var v=b.networkName,y=b.networkEid,Y=b.csid,x=b.csrid,ie=b.src,de=b.t0,le=b.t1;return{url:"/".concat(v,"/n/").concat(y,"/manage/usage/rule_useblocks")+"?"+new URLSearchParams({csid:Y,csrid:x,src:ie,t0:de.toString(),t1:le.toString()}),method:"GET"}},transformResponse:function(b,v,y){var Y=y.csid,x=b.allnode.nruseblocks[Y],ie=Object.entries(x).map(function(de){var le=de[0],M=de[1];return{id:le,useblocks:M}});return ie}})}}}),V=D.useGetClientRuleUseblocksQuery,E=f.u.injectEndpoints({endpoints:function(w){return{forgetDevices:w.mutation({query:function(b){var v=b.networkTag,y=b.networkEid,Y=b.ids;return{url:"".concat(v,"/n/").concat(y,"/manage/usage/forget_clients"),method:"POST",body:{ids:Y}}}})}}}),_=E.useForgetDevicesMutation,H=f.u.injectEndpoints({endpoints:function(w){return{logOutUser:w.mutation({query:function(b){var v=b.userId;return{url:"/manage/organization/logout_user",method:"POST",body:{id:v}}}}),unlockUser:w.mutation({query:function(b){var v=b.userId;return{url:"/manage/organization/unlock_user",responseHandler:"text",method:"POST",body:{id:v}}}}),resendEmail:w.mutation({query:function(b){var v=b.admin;return{url:"/manage/organization/resend_email",method:"POST",body:{admin:v}}}}),administeredOrgs:w.query({query:function(){return{url:"/manage/organization/administered_orgs",method:"GET"}}}),thousandEyesIsLinked:w.query({query:function(b){var v=b.organizationEid;return{url:"o/".concat(v,"/manage/app_analytics/thousandeyes/is_linked")}}})}}}),W=H.useLogOutUserMutation,X=H.useUnlockUserMutation,ne=H.useResendEmailMutation,ce=H.useAdministeredOrgsQuery,ae=H.useThousandEyesIsLinkedQuery,Q=f.u.injectEndpoints({endpoints:function(w){return{getNetworkAdministeredOrgs:w.query({query:function(b){var v=b.networkTag,y=b.networkEid;return{url:"/".concat(v,"/n/").concat(y,"/manage/organization/administered_orgs")}}})}}}),ye=Q.useGetNetworkAdministeredOrgsQuery,Se=function(){return Se=Object.assign||function(w){for(var b,v=1,y=arguments.length;v<y;v++){b=arguments[v];for(var Y in b)Object.prototype.hasOwnProperty.call(b,Y)&&(w[Y]=b[Y])}return w},Se.apply(this,arguments)},ke=function(w,b){var v={};for(var y in w)Object.prototype.hasOwnProperty.call(w,y)&&b.indexOf(y)<0&&(v[y]=w[y]);if(w!=null&&typeof Object.getOwnPropertySymbols=="function")for(var Y=0,y=Object.getOwnPropertySymbols(w);Y<y.length;Y++)b.indexOf(y[Y])<0&&Object.prototype.propertyIsEnumerable.call(w,y[Y])&&(v[y[Y]]=w[y[Y]]);return v},Ge=f.u.injectEndpoints({endpoints:function(w){return{getPortsJson:w.query({query:function(b){var v=b.networkTag,y=b.networkEid,Y=ke(b,["networkTag","networkEid"]);return{url:"/".concat(v,"/n/").concat(y,"/manage/nodes/ports_json")+"?"+new URLSearchParams(Se(Se({},Y),{aggregates:Y.aggregates.toString()}))}}})}}}),xe=Ge.useGetPortsJsonQuery,Ne=f.u.injectEndpoints({endpoints:function(w){return{SDBJobs:w.query({query:function(b){var v=b.nodeId,y=b.lookbackHours;return{method:"GET",url:"/nodes/".concat(v,"/support_data_bundle_jobs").concat(y?"?lookback_hours=".concat(y):"")}},transformResponse:function(b){var v;return{result:(v=b.result)!==null&&v!==void 0?v:[]}}}),enqueueSDB:w.mutation({query:function(b){var v=b.nodeId;return{url:"/nodes/".concat(v,"/enqueue_support_bundle_generation"),method:"GET"}}})}}}),ue=Ne.useSDBJobsQuery,Ye=Ne.useEnqueueSDBMutation,T=j(7448),Qe=j(1317),Be=T.z.object({id:T.z.string().optional(),serial:T.z.string().optional(),alerts:T.z.array(T.z.object({admin_alert:T.z.boolean(),alert_key:T.z.string(),alert_type:T.z.enum(["success","warning","danger"]),html:T.z.string().nullable(),html_safe:T.z.object({html:T.z.boolean(),name:T.z.boolean(),short_desc:T.z.boolean()}),name:T.z.string(),short_desc:T.z.string()})).optional(),supports_l3:T.z.string().optional(),has_l3:T.z.boolean().optional(),"status#":T.z.number().optional(),"config_forced_at#":T.z.number().optional(),"config_fetch_at#":T.z.number().optional(),"config_new_at#":T.z.number().optional(),"usage#":T.z.number().optional(),"watchdog#":T.z.number().optional(),"clients#":T.z.number().optional(),"outage_graph#":T.z.number().optional(),"last_active#":T.z.number().optional(),config_status_data:T.z.object({admin:T.z.object({message:T.z.string(),"running_config_fetched_at#":T.z.number().optional()}),id:T.z.string().optional(),visible:T.z.object({"config_changed_at#":T.z.number().optional(),"config_fetched_at#":T.z.number().optional(),"config_forced_at#":T.z.number().optional(),message:T.z.string()})}).nullish().optional(),ntp_status:T.z.string().optional(),uplink6_settings:T.z.array(T.z.object({static_ip6_enabled:T.z.union([T.z.string(),T.z.boolean()]).optional(),static_ip6:T.z.string().optional(),static_ip6_plen:T.z.string().optional(),static_ip6_gateway:T.z.string().optional(),static_vlan6:T.z.string().optional(),static_dns6_1:T.z.string().optional(),static_dns6_2:T.z.string().optional()}).nullable()).nullish().optional(),visible_version_number:T.z.string().optional(),udi:T.z.string().nullable().optional(),is_aurora2_catalyst_device:T.z.boolean().optional(),is_polaris_switch:T.z.boolean().optional(),is_stackable_switch:T.z.boolean().optional(),name:T.z.string().optional(),mac:T.z.string().optional(),upseries:T.z.array(T.z.unknown()).optional(),tags:T.z.string().optional(),notes:T.z.string().optional(),catalyst_conversion:T.z.object({eligible:T.z.boolean(),created_at:T.z.number().nullable(),fetched_at:T.z.number().nullable()}).optional(),admin_tags:T.z.string().optional(),num_ports:T.z.number().optional(),num_active_ports:T.z.number().optional(),product_code:T.z.string().optional(),alert_tags:T.z.string().optional(),firmware_version:T.z.string().optional(),validation_level:T.z.string().optional(),booted_at:T.z.number().optional(),ip:T.z.string().nullable().optional(),local_ip:T.z.string().optional(),lan_ip:T.z.string().nullable().optional(),ipv6_tunnel_ip:T.z.string().optional(),public_firmware_version:T.z.string().optional(),nass:T.z.number().optional(),switch_stack_name:T.z.string().nullable().optional(),switch_stack_id:T.z.string().nullable().optional(),node_profile_name:T.z.string().nullish(),uplink6_state_json:T.z.array(T.z.unknown()).optional(),vlan_profile:T.z.string().optional()}),qe=["status#","is_gateway","nouns","name","mac","upseries","outage_graph#","tags","serial","product_short_description","notes","catalyst_conversion","admin_tags","last_rolling_upgrade_group","num_ports","num_stack_ports","num_active_ports","udi","product_code","alert_tags","last_active#","firmware_version","validation_level","config_fetch_at#","config_new_at#","booted_at","ip","local_ip","lan_ip","ipv6_tunnel_ip","lat","lng","id","network_eid","device_type","vrrp_primary","supports_l3","is_stackable_switch","has_l3","has_transient_static_ip","public_firmware_version","visible_version_number","has_firmware_eco","has_tagged_firmware_eco","usage#","clients#","nass","is_read_only","switch_stack_id","switch_stack_name","node_profile_name","uplink6_state_json","vlan_profile"],Ce=T.z.object({at:T.z.number(),metanode:T.z.unknown(),nodes:T.z.array(Be),ssid:T.z.number()}),Te=f.u.injectEndpoints({endpoints:function(w){return{getNodesJson:w.query({query:function(b){var v=b.url,y=b.params;return{method:"GET",url:v,params:{offset:0,skip_expensive:!0,timespan:86400,f:y??qe}}},transformResponse:(0,Qe.xy)(Ce,"manage/nodes/json")})}}}),Ve=Te.useGetNodesJsonQuery,We=j(1735),De=j(4450),Re=function(w,b,v,y){function Y(x){return x instanceof v?x:new v(function(ie){ie(x)})}return new(v||(v=Promise))(function(x,ie){function de(ge){try{M(y.next(ge))}catch(tt){ie(tt)}}function le(ge){try{M(y.throw(ge))}catch(tt){ie(tt)}}function M(ge){ge.done?x(ge.value):Y(ge.value).then(de,le)}M((y=y.apply(w,b||[])).next())})},Ee=function(w,b){var v={label:0,sent:function(){if(x[0]&1)throw x[1];return x[1]},trys:[],ops:[]},y,Y,x,ie;return ie={next:de(0),throw:de(1),return:de(2)},typeof Symbol=="function"&&(ie[Symbol.iterator]=function(){return this}),ie;function de(M){return function(ge){return le([M,ge])}}function le(M){if(y)throw new TypeError("Generator is already executing.");for(;ie&&(ie=0,M[0]&&(v=0)),v;)try{if(y=1,Y&&(x=M[0]&2?Y.return:M[0]?Y.throw||((x=Y.return)&&x.call(Y),0):Y.next)&&!(x=x.call(Y,M[1])).done)return x;switch(Y=0,x&&(M=[M[0]&2,x.value]),M[0]){case 0:case 1:x=M;break;case 4:return v.label++,{value:M[1],done:!1};case 5:v.label++,Y=M[1],M=[0];continue;case 7:M=v.ops.pop(),v.trys.pop();continue;default:if(x=v.trys,!(x=x.length>0&&x[x.length-1])&&(M[0]===6||M[0]===2)){v=0;continue}if(M[0]===3&&(!x||M[1]>x[0]&&M[1]<x[3])){v.label=M[1];break}if(M[0]===6&&v.label<x[1]){v.label=x[1],x=M;break}if(x&&v.label<x[2]){v.label=x[2],v.ops.push(M);break}x[2]&&v.ops.pop(),v.trys.pop();continue}M=b.call(w,v)}catch(ge){M=[6,ge],Y=0}finally{y=x=0}if(M[0]&5)throw M[1];return{value:M[0]?M[1]:void 0,done:!0}}},k=f.u.injectEndpoints({endpoints:function(w){return{moveL3Settings:w.mutation({query:function(b){var v=b.path.baseUrl,y=b.body;return{url:"".concat(v,"manage/switch_l3/move_l3_settings"),method:"POST",body:y}},onQueryStarted:function(b,v){return Re(this,arguments,void 0,function(y,Y){var x,ie=Y.dispatch,de=Y.queryFulfilled;return Ee(this,function(le){switch(le.label){case 0:return le.trys.push([0,2,,3]),[4,de];case 1:return le.sent(),ie(We.v1.util.invalidateTags([{type:De.Ye},{type:De.jr}])),[3,3];case 2:return x=le.sent(),[3,3];case 3:return[2]}})})}})}}}),ze=k.useMoveL3SettingsMutation,Le=function(w,b){var v={};for(var y in w)Object.prototype.hasOwnProperty.call(w,y)&&b.indexOf(y)<0&&(v[y]=w[y]);if(w!=null&&typeof Object.getOwnPropertySymbols=="function")for(var Y=0,y=Object.getOwnPropertySymbols(w);Y<y.length;Y++)b.indexOf(y[Y])<0&&Object.prototype.propertyIsEnumerable.call(w,y[Y])&&(v[y[Y]]=w[y[Y]]);return v},Ie=f.u.injectEndpoints({endpoints:function(w){return{getNetworkUseblocks:w.query({query:function(b){var v=b.nodeGroupTag,y=b.networkEid,Y=Le(b,["nodeGroupTag","networkEid"]);return{url:"/".concat(v,"/n/").concat(y,"/manage/usage/network_useblocks")+"?"+new URLSearchParams(Y)}},keepUnusedDataFor:0,transformResponse:function(b){return{rusage:b.rusage,rusageSrc:b.rusage_src,netUseBlocks:b.netuseblocks,t0:b.t0,t1:b.t1}}}),getCounterSets:w.query({query:function(){return{url:"manage/usage/counter_sets_magnetize"}}}),setFilteredUseblocks:w.mutation({query:function(b){var v=b.nodeGroupTag,y=b.networkEid,Y=Le(b,["nodeGroupTag","networkEid"]);return{url:"/".concat(v,"/n/").concat(y,"/manage/usage/filtered_useblocks"),method:"POST",body:new URLSearchParams(Y),headers:{"Content-Type":"application/x-www-form-urlencoded"}}}})}}}),Ze=Ie.useGetNetworkUseblocksQuery,R=Ie.useGetCounterSetsQuery,L=Ie.useSetFilteredUseblocksMutation,G=f.u.injectEndpoints({endpoints:function(w){return{setUserDashboardPreferences:w.mutation({query:function(b){var v,y,Y,x,ie=b.namespace,de=b.key,le=b.value,M=de!==void 0?typeof de=="string"?(v={},v[ie]=(y={},y[de]=le,y),v):(Y={},Y[ie]=de,Y):(x={},x[ie]=le,x);return{url:"manage/dashboard/quiet_update",method:"POST",body:{user_prefs:JSON.stringify(M)}}}})}}}),ee=G.useSetUserDashboardPreferencesMutation,he=function(){return he=Object.assign||function(w){for(var b,v=1,y=arguments.length;v<y;v++){b=arguments[v];for(var Y in b)Object.prototype.hasOwnProperty.call(b,Y)&&(w[Y]=b[Y])}return w},he.apply(this,arguments)},we=function(w,b){var v={};for(var y in w)Object.prototype.hasOwnProperty.call(w,y)&&b.indexOf(y)<0&&(v[y]=w[y]);if(w!=null&&typeof Object.getOwnPropertySymbols=="function")for(var Y=0,y=Object.getOwnPropertySymbols(w);Y<y.length;Y++)b.indexOf(y[Y])<0&&Object.prototype.propertyIsEnumerable.call(w,y[Y])&&(v[y[Y]]=w[y[Y]]);return v},_e={Normal:"-1",Allowed:"0",Blocked:"1"},je=f.u.injectEndpoints({endpoints:function(w){return{setManyPolicies:w.mutation({query:function(b){var v=b.networkName,y=b.networkEid,Y=we(b,["networkName","networkEid"]);return{url:"/".concat(v,"/n/").concat(y,"/manage/usage/set_many_policies"),method:"POST",body:he({},Y)}}})}}}),Ue=je.useSetManyPoliciesMutation,P=function(w){if(!w)return null;var b=w.match(/^https:\/\/n(\d+)\./);return b?b[1]:null},h=f.u.injectEndpoints({endpoints:function(w){return{createLiveSearchReact:w.mutation({query:function(b){var v=b.networkName,y=b.networkEid,Y=b.query,x=b.organizations,ie=b.categories,de=new URLSearchParams;(x||[]).forEach(function(M,ge){var tt=M.id,mt=P(M.url);tt&&mt&&(de.append("orgIds[".concat(ge,"][id]"),tt),de.append("orgIds[".concat(ge,"][shard_id]"),mt))}),ie&&ie.length>0&&ie.forEach(function(M){de.append("categories[]",M)});var le=v&&y?"/".concat(v,"/n/").concat(y,"/manage/dashboard/live_search_react"):"/manage/dashboard/live_search_react";return{url:le+"?"+new URLSearchParams({query:Y}),method:"POST",headers:{"X-Requested-With":"XMLHttpRequest","Content-Type":"application/x-www-form-urlencoded"},body:de.toString()}}})}}}),I=h.useCreateLiveSearchReactMutation,A=f.u.injectEndpoints({endpoints:function(w){return{setLocalAssets:w.mutation({query:function(b){var v=b.enabled;return{url:"/manage/system/set_local_assets_mode",body:{enabled:v.toString()},method:"POST"}}})}}}),O=A.useSetLocalAssetsMutation,S=f.u.injectEndpoints({endpoints:function(w){return{toggleIdleTimeout:w.mutation({query:function(b){var v=b.networkName,y=b.networkEid,Y=b.skipTimeout;return{url:"/".concat(v,"/n/").concat(y,"/manage/dashboard/toggle_idle_timeout")+"?"+new URLSearchParams({skip_timeout:Y?"1":"0"}),method:"POST"}}})}}}),B=S.useToggleIdleTimeoutMutation,J=f.u.injectEndpoints({endpoints:function(w){return{keepIdleTimeoutAlive:w.mutation({query:function(){return{url:"/manage/dashboard/keep_idle_timeout_alive",responseHandler:function(b){return b.text()},method:"POST",headers:{"X-Requested-With":"XMLHttpRequest"}}},transformResponse:function(b){if(typeof b!="string")throw new Error("Invalid response type");return b.trim()}})}}}),e=J.useKeepIdleTimeoutAliveMutation,be=f.u.injectEndpoints({endpoints:function(w){return{getIdleStatus:w.query({query:function(b){var v=b.secondsAgo;return{url:"/manage/dashboard/get_idle_status?seconds_ago=".concat(v),responseHandler:function(y){return y.text()},method:"GET",headers:{"X-Requested-With":"XMLHttpRequest"}}},transformResponse:function(b){if(typeof b!="string")throw new Error("Invalid response type");var v=b.trim();if(v!=="active"&&v!=="idle")throw new Error("Invalid idle status: ".concat(v));return v},keepUnusedDataFor:0})}}}),ve=be.useGetIdleStatusQuery,Ke=be.useLazyGetIdleStatusQuery,Xe=f.u.injectEndpoints({endpoints:function(w){return{createWish:w.mutation({query:function(b){var v=b.wish,y=b.wishHash,Y=b.pageName;return{url:"manage/support/wish",method:"POST",body:{page_name:Y,wish:v,wish_hash:y},headers:{"X-Requested-With":"XMLHttpRequest"}}}})}}}),ht=Xe.useCreateWishMutation,He=function(){return He=Object.assign||function(w){for(var b,v=1,y=arguments.length;v<y;v++){b=arguments[v];for(var Y in b)Object.prototype.hasOwnProperty.call(b,Y)&&(w[Y]=b[Y])}return w},He.apply(this,arguments)},$e=f.u.injectEndpoints({endpoints:function(w){return{getSynchronousMessage:w.query({query:function(b){var v=b.organizationId,y=b.body;return{url:"internal/assistant/organizations/".concat(v,"/v1/synchronous_message"),method:"POST",body:y}},transformResponse:function(b){return He(He({},b),{content:JSON.parse(b.content)})}})}}}),et=$e.useGetSynchronousMessageQuery,bt=j(2235),Je=function(){return Je=Object.assign||function(w){for(var b,v=1,y=arguments.length;v<y;v++){b=arguments[v];for(var Y in b)Object.prototype.hasOwnProperty.call(b,Y)&&(w[Y]=b[Y])}return w},Je.apply(this,arguments)},te=function(w,b){var v={};for(var y in w)Object.prototype.hasOwnProperty.call(w,y)&&b.indexOf(y)<0&&(v[y]=w[y]);if(w!=null&&typeof Object.getOwnPropertySymbols=="function")for(var Y=0,y=Object.getOwnPropertySymbols(w);Y<y.length;Y++)b.indexOf(y[Y])<0&&Object.prototype.propertyIsEnumerable.call(w,y[Y])&&(v[y[Y]]=w[y[Y]]);return v},Pe=f.u.injectEndpoints({endpoints:function(w){return{getHealthHistoricalBySensor:w.query({query:function(b){var v=b.networkTag,y=b.networkEid,Y=b.serial,x=te(b,["networkTag","networkEid","serial"]);return{url:"/".concat(v,"/n/").concat(y,"/manage/sensors/health/historical_by_sensor").concat((0,bt.DK)(Je(Je({},x),{serials:[Y]})))}}})}}}),ft=Pe.useGetHealthHistoricalBySensorQuery,Oe=f.u.injectEndpoints({endpoints:function(w){return{createScopeSuggestions:w.mutation({query:function(b){var v=b.query,y=b.scopeType,Y=new URLSearchParams;Y.append("body",v);var x=y.toLowerCase()==="network"?"networks":"networkgroups";return{url:"/api/v1/magic-search/suggestions/".concat(x,"?query=").concat(encodeURIComponent(v)),method:"POST",headers:{"X-Requested-With":"XMLHttpRequest"},body:Y.toString()}}})}}}),zt=Oe.useCreateScopeSuggestionsMutation},2607:(me,$,j)=>{j.d($,{A:()=>D});var f=j(6063),F=j.n(f),C=j(5248),N=j.n(C),K=N()(F());K.push([me.id,".search-menu-nav{height:100% !important}.search-menu-nav.mds-rebuild-nav{z-index:unset}.search-menu-nav::before{display:none}.nav-search-modal{position:absolute;top:200px}.nav-search-modal .mds-rebuild-input.mds-rebuild-input-size-lg{width:720px !important;min-width:720px !important}.nav-search-modal .feedback-form{border:none}.nav-search-modal .feedback-form iframe{border:none}.nav-search-modal kbd{align-items:center;border:1px solid var(--base-border-default);border-radius:3px;color:var(--base-text-default);display:inline-flex;font-style:normal;height:1.5em;justify-content:center;margin-left:.4em;margin-right:.4em;max-width:3em;min-width:1.5em;padding:3px}.nav-search-modal .filtered-data{max-height:300px;border:none !important;padding-bottom:10px !important;padding-top:10px !important}.nav-search-modal .feedback-form{border:none}.search-menu-nav button.search-menu-label p{width:100%;font-weight:600}.search-menu-nav button.search-menu-label p kbd{float:right}#navigation_search .mds-rebuild-nav{min-width:240px;padding:0px;overflow:hidden;list-style:none}#navigation_search .mds-rebuild-nav li{width:100%}#navigation_search .mds-rebuild-nav-item::before{background:rgba(0,0,0,0)}.nav-search-tooltip-message{color:#fff;border:none}",""]);const D=K},4450:(me,$,j)=>{j.d($,{BX:()=>C,Ye:()=>f,jr:()=>F});var f="SwitchRoutingInterfacesTag",F="SwitchRoutingStaticRoutesTag",C="SwitchLinkAggregationsTag"},5586:(me,$,j)=>{j.d($,{P:()=>f});var f=function(F,C,N){var K,D,V,E,_=C.getState,H=N===void 0?{}:N,W=H.legacyHeaders,X=W===void 0?!1:W,ne=window.Mkiconf,ce=_(),ae=(V=(K=ne?.authenticity_token)!==null&&K!==void 0?K:(D=ce.auth)===null||D===void 0?void 0:D.token)!==null&&V!==void 0?V:"",Q=new Headers(F);return X||(Q.set("Accept","application/json"),Q.set("Content-Type","application/json")),Q.set("X-CSRF-TOKEN",ae),Q.set("X-Pageload-Request-Id",(E=ne?.pageload_request_id)!==null&&E!==void 0?E:""),Promise.resolve(Q)}},6350:(me,$,j)=>{j.d($,{Eu:()=>Ue});var f=j(6870),F=j(796),C=j(6843),N=j(1435),K=j(738),D=j(5418),V=j(7002),E=j(2388),_=j(9983),H=j(3117),W=j(9096),X=j(9284),ne=j(1138),ce=j(8553),ae=Object.defineProperty,Q=Object.getOwnPropertySymbols,ye=Object.prototype.hasOwnProperty,Se=Object.prototype.propertyIsEnumerable,ke=(P,h,I)=>h in P?ae(P,h,{enumerable:!0,configurable:!0,writable:!0,value:I}):P[h]=I,Ge=(P,h)=>{for(var I in h||(h={}))ye.call(h,I)&&ke(P,I,h[I]);if(Q)for(var I of Q(h))Se.call(h,I)&&ke(P,I,h[I]);return P},xe=Object.defineProperty,Ne=(P,h,I)=>h in P?xe(P,h,{enumerable:!0,configurable:!0,writable:!0,value:I}):P[h]=I,ue=(P,h,I)=>(Ne(P,typeof h!="symbol"?h+"":h,I),I),Ye=Object.defineProperty,T=(P,h)=>Ye(P,"name",{value:h,configurable:!0});const Qe=null;var Be=Object.defineProperty,qe=(P,h)=>Be(P,"name",{value:h,configurable:!0});const Ce=typeof process<"u",Te=qe(()=>{var P,h,I,A,O;return{localeId:(P=window.Mkiconf)==null?void 0:P.locale_id,location:(h=window.Mkiconf)==null?void 0:h.location,nodeGroupId:(I=window.Mkiconf)==null?void 0:I.ng_id,organizationId:(A=window.Mkiconf)==null?void 0:A.org_id,userEid:(O=window.Mkiconf)==null?void 0:O.user_eid}},"createDefaultConfiguration");class Ve{constructor({configuration:h,force:I=!1}){ue(this,"configuration"),ue(this,"currentLocationOrigin"),ue(this,"environment"),ue(this,"isDevEnv",!1),ue(this,"isFederalEnv",!1),ue(this,"isLocalEnv",!1),ue(this,"isProductionEnv",!1),ue(this,"isTestEnv",!1),ue(this,"sendLogs"),ue(this,"sentryClient"),ue(this,"sentryScope"),ue(this,"staticAssetsRevisionNumber"),ue(this,"ignoredUrlRegExp",[/http.*localhost.*/i,/http.*ephemeral.exp.ikarem.io.*/i,/http.*dashboard.e2e.ikarem.*/i,/http.*10.0.0.*/i,/http.*192.168.*/i,/^https:\/\/n1\.(?!meraki\.dev\.ikarem\.io).+\.ikarem\.io$/]);var A,O;Ce&&(A=process==null?void 0:process.env)!=null&&A.BUILD_TAG?this.staticAssetsRevisionNumber=process.env.BUILD_TAG:this.staticAssetsRevisionNumber="N/A",this.configuration=h??Te(),this.currentLocationOrigin=((O=window?.location)==null?void 0:O.origin)||"",this.environment=this.detectEnvironment(),this.sendLogs=this.shouldSendLogs()||I;const S=_.nI({}).filter(B=>!["BrowserApiErrors","Breadcrumbs","GlobalHandlers"].includes(B.name));this.sendLogs&&(this.sentryClient=new H.y({dsn:"https://6e5104a775114fb79390e669501709cc@o1070925.ingest.us.sentry.io/6691806",integrations:[...S,W.X()],sampleRate:1,tracesSampleRate:.1,replaysSessionSampleRate:0,replaysOnErrorSampleRate:.5,environment:this.environment,release:this.staticAssetsRevisionNumber,stackParser:X.lG,transport:ne._,denyUrls:this.ignoredUrlRegExp,ignoreErrors:["ResizeObserver","XMLHttpRequest.nrWrapper"]}),this.sentryScope=new ce.H,this.sentryScope.setClient(this.sentryClient),this.sentryScope.setTags(this.buildTags()))}shouldSendLogs(){const h=`Sentry error reporting disabled for ${this.currentLocationOrigin}`;if(this.isFederalEnv||this.isLocalEnv)return console.info(h),!1;const I=this.ignoredUrlRegExp.find(A=>this.currentLocationOrigin.match(A));return I&&console.info(h),!I}buildTags(h){var I,A,O,S,B,J,e;const be={localeId:(I=this.configuration.localeId)!=null?I:"N/A",organizationId:(A=this.configuration.organizationId)!=null?A:"N/A",pageLocation:(O=this.configuration.location)!=null?O:"missing_page_location",staticAssetRevisionNumber:this.staticAssetsRevisionNumber,userId:(S=this.configuration.userEid)!=null?S:"N/A",nodeGroupId:(B=this.configuration.nodeGroupId)!=null?B:"N/A",pageTitle:document?.title||"N/A",url:((J=document?.location)==null?void 0:J.href)||"N/A",hostname:((e=document?.location)==null?void 0:e.hostname)||"N/A"};return h!==void 0?Ge(Ge({},be),h):be}error(h,I={}){var A;let O;if(typeof h=="string"?O=new Error(h):O=h,console.error(O),!this.sendLogs)return;const S=this.buildTags(I);(A=this.sentryScope)==null||A.captureException(O,{captureContext:{tags:S}}),window.newrelic&&window.newrelic.noticeError(O,S)}detectEnvironment(){var h;return Ce&&((h=process==null?void 0:process.env)==null?void 0:h.NODE_ENV)==="test"?(this.isTestEnv=!0,"test"):window.location.hostname.includes("gov-meraki")?(this.isFederalEnv=!0,"federal"):window.location.hostname==="localhost"||this.currentLocationOrigin.match(/^https:\/\/n1\.(?!meraki\.dev\.ikarem\.io).+\.ikarem\.io$/)?(this.isLocalEnv=!0,"local"):window.location.hostname.endsWith("ikarem.io")?(this.isDevEnv=!0,"development"):(this.isProductionEnv=!0,"production")}}qe(Ve,"Logger");const We=new Ve({});var De=Object.defineProperty,Re=(P,h,I)=>h in P?De(P,h,{enumerable:!0,configurable:!0,writable:!0,value:I}):P[h]=I,Ee=(P,h,I)=>(Re(P,typeof h!="symbol"?h+"":h,I),I);function k(P){return P&&P.__esModule&&Object.prototype.hasOwnProperty.call(P,"default")?P.default:P}var ze={exports:{}};/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function(P){(function(){var h={}.hasOwnProperty;function I(){for(var S="",B=0;B<arguments.length;B++){var J=arguments[B];J&&(S=O(S,A(J)))}return S}function A(S){if(typeof S=="string"||typeof S=="number")return S;if(typeof S!="object")return"";if(Array.isArray(S))return I.apply(null,S);if(S.toString!==Object.prototype.toString&&!S.toString.toString().includes("[native code]"))return S.toString();var B="";for(var J in S)h.call(S,J)&&S[J]&&(B=O(B,J));return B}function O(S,B){return B?S?S+" "+B:S+B:S}P.exports?(I.default=I,P.exports=I):window.classNames=I})()})(ze);var Le=ze.exports;const Ie=k(Le);var Ze=Object.defineProperty,R=(P,h)=>Ze(P,"name",{value:h,configurable:!0});const L=R(()=>(0,f.jsxs)(K.s,{direction:"vertical",align:"center",gap:36,"data-testid":"page-level-fallback",children:[(0,f.jsx)(E.S.Negative,{}),(0,f.jsxs)(K.s,{direction:"vertical",align:"center",gap:8,children:[(0,f.jsx)(D.D,{size:"h2",children:"Content failed to load"}),(0,f.jsx)(C.E,{size:"p2",color:"light",children:"Please try again"})]})]}),"PageLevelFallback"),G=R(()=>(0,f.jsx)(V.Eg,{status:"negative","data-testid":"section-level-fallback",children:"The content failed to load. Please try again."}),"SectionLevelFallback");class ee extends F.Component{constructor(){super(...arguments),Ee(this,"state",{hasError:!1})}static getDerivedStateFromError(){return{hasError:!0}}componentDidCatch(h,I){console.warn("Uncaught error:",h,I);const{feature:A,team:O}=this.props;We.error(h,{team:O.tag,feature:A.tag});const S=R(B=>B.tag?[B.tag]:[],"buildTags");window.JL?window.JL("onerrorLogger").fatalException({logData:{errorMsg:`Caught React exception: ${h}`},message:h.message,stack:I.componentStack,tags:S(O)}):console.warn("React javascript error logging disabled.")}render(){var h;if(this.state.hasError)switch(this.props.level){case"page":return(0,f.jsx)(L,{});default:return(0,f.jsx)(G,{})}return(h=this.props.children)!=null?h:null}}R(ee,"ErrorBoundary");var he=Object.defineProperty,we=(P,h)=>he(P,"name",{value:h,configurable:!0});const _e="meraki-admin-team-ownership-visible",je="meraki-admin-team-ownership-change",Ue=we(({children:P,level:h="page",feature:I,team:A,fullWidth:O,teamMetaZIndex:S})=>{const[B,J]=(0,F.useState)(!1),e=(0,F.useCallback)(()=>{J(window.localStorage.getItem(_e)==="true")},[]);(0,F.useEffect)(()=>(e(),window.addEventListener(je,e),()=>window.removeEventListener(je,e)),[e]);const be=N.T3[A],ve=N.Gv[I],Ke=Ie("meraki-team-boundary",{"boundary-visible":B});return(0,f.jsxs)("div",{className:Ke,"data-testid":`enabled-${B}`,"data-feature-name":ve.name,"data-level":h,style:{width:O?"100%":void 0},children:[(0,f.jsx)("div",{className:"team-meta",style:{zIndex:S},children:(0,f.jsxs)(C.E,{size:"p4",weight:"bold",children:[be.name," ",be.slack]})}),h==="feature"?P:(0,f.jsx)(ee,{level:h,team:be,feature:ve,children:P})]})},"TeamBoundary")},6918:(me,$,j)=>{j.d($,{d7:()=>f.d7,mM:()=>D,ur:()=>Qn.ur,v1:()=>k.v1});var f=j(525),F=j(1558),C=j(4337),N=j(2235),K=j(5586),D=(0,F.xP)({reducerPath:"@dashboard/store/internal",baseQuery:(0,C.fetchBaseQuery)({baseUrl:"/internalAPI/",paramsSerializer:N.DK,transformHeaders:K.P}),endpoints:function(){return{}}}),V=D.injectEndpoints({endpoints:function(s){return{getMyNetworkPermissions:s.query({query:function(n){return"networks/".concat(n,"/identities/me/permissions")}})}}}),E=V.useGetMyNetworkPermissionsQuery,_=D.injectEndpoints({endpoints:function(s){return{getNetworkClientACLLogs:s.query({query:function(n){var t=n.networkId,i=n.clientId;return"networks/".concat(t,"/clients/").concat(i,"/aclLogs")}})}}}),H=_.useGetNetworkClientACLLogsQuery,W=D.injectEndpoints({endpoints:function(s){return{getNetworkClientAssociationLogs:s.query({query:function(n){var t=n.networkId,i=n.clientId;return"networks/".concat(t,"/clients/").concat(i,"/associationLogs")}})}}}),X=W.useGetNetworkClientAssociationLogsQuery,ne=D.enhanceEndpoints({addTagTypes:["RuntimeInformation"]}).injectEndpoints({endpoints:function(s){return{getRuntimeInformation:s.query({query:function(){return"systems/runtimeInformation"},providesTags:["RuntimeInformation"]})}}}),ce=ne.useGetRuntimeInformationQuery,ae=D.injectEndpoints({endpoints:function(s){return{getOrganizationAdminParams:s.query({query:function(n){return{url:"organization/".concat(n,"/admin_params"),params:{},method:"GET"}}})}}}),Q=ae.useGetOrganizationAdminParamsQuery,ye=D.injectEndpoints({endpoints:function(s){return{getOrganizationAiAssistantOptions:s.query({query:function(n){return{url:"organizations/".concat(n,"/aiAssistantOptions"),params:{},method:"GET"}}})}}}),Se=ye.useGetOrganizationAiAssistantOptionsQuery,ke=D.injectEndpoints({endpoints:function(s){return{getOrganizationSupportPasswords:s.query({query:function(n){return{url:"organization/".concat(n,"/iam/admins/supportPasswords"),params:{},method:"GET"}}})}}}),Ge=ke.useGetOrganizationSupportPasswordsQuery,xe=D.injectEndpoints({endpoints:function(s){return{getBanners:s.query({query:function(n){return{url:"banners",params:n}}}),getBanner:s.query({query:function(n){return"banners/".concat(n)}})}}}),Ne=xe.useGetBannersQuery,ue=xe.useGetBannerQuery,Ye=D.injectEndpoints({endpoints:function(s){return{getBannerRequests:s.query({query:function(){return"banners/requests"}}),getBannerRequest:s.query({query:function(n){return"banners/requests/".concat(n)}}),createBannerRequest:s.mutation({query:function(n){return{url:"banners/requests",method:"POST",body:n}}}),deleteBannerRequest:s.mutation({query:function(n){return{url:"banners/requests/".concat(n),method:"DELETE"}}}),approveBannerRequest:s.mutation({query:function(n){return{url:"banners/requests/".concat(n,"/approve"),method:"PUT"}}})}}}),T=Ye.useGetBannerRequestsQuery,Qe=Ye.useGetBannerRequestQuery,Be=Ye.useCreateBannerRequestMutation,qe=Ye.useDeleteBannerRequestMutation,Ce=Ye.useApproveBannerRequestMutation,Te=D.injectEndpoints({endpoints:function(s){return{getBannerAudiences:s.query({query:function(n){return{url:"bannerAudiences",params:n}}}),getBannerAudience:s.query({query:function(n){return"bannerAudiences/".concat(n)}}),createBannerAudience:s.mutation({query:function(n){return{url:"bannerAudiences",method:"POST",body:n}}})}}}),Ve=Te.useGetBannerAudiencesQuery,We=Te.useGetBannerAudienceQuery,De=Te.useCreateBannerAudienceMutation,Re=D.injectEndpoints({endpoints:function(s){return{revertLicensingMode:s.mutation({query:function(n){return{url:"organizations/".concat(n.organizationId,"/licensingMode"),method:"PUT",params:{licensingMode:"coterm"},headers:{"Content-type":"application/json; charset=UTF-8"}}}})}}}),Ee=Re.useRevertLicensingModeMutation,k=j(1735),ze=k.v1.injectEndpoints({endpoints:function(s){return{getDeviceCompliances:s.query({query:function(n){return{url:"administered/licensing/subscription/deviceCompliances",params:n}}})}}}),Le=ze.useGetDeviceCompliancesQuery,Ie=function(){return Ie=Object.assign||function(s){for(var n,t=1,i=arguments.length;t<i;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(s[a]=n[a])}return s},Ie.apply(this,arguments)},Ze=k.v1.injectEndpoints({endpoints:function(s){return{getEntitlements:s.query({query:function(n){return{url:"administered/licensing/subscription/entitlements",params:Ie({},n)}}})}}}).useGetEntitlementsQuery,R=j(3006),L=j(796),G=function(){return G=Object.assign||function(s){for(var n,t=1,i=arguments.length;t<i;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(s[a]=n[a])}return s},G.apply(this,arguments)},ee=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},he=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},we=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},_e=function(s,n){return delete s.startingAfter,delete s.endingBefore,G(G({},s),n)},je=function(s,n,t,i){var a=function(o,l,u){return ee(void 0,void 0,void 0,function(){var m,d,p,g,q,Z,U;return he(this,function(pe){switch(pe.label){case 0:return[4,s(o).unwrap()];case 1:return m=pe.sent(),d=m.records,p=m.cursors,g=we(we([],l,!0),d,!0),i&&i(u,g),q=u+1,Z=p?.next&&q<t,Z&&p.next?(U=_e(o,p.next),[2,a(U,g,q)]):[2,g]}})})};return a(n,[],0)},Ue=function(){return{data:void 0,isLoading:!1,isFetching:!1,error:void 0}},P=function(){return function(s,n){switch(n.type){case"FETCH_START":return{data:void 0,isLoading:!0,isFetching:!0,error:void 0};case"FIRST_PAGE_LOADED":return G(G({},s),{data:n.payload,isLoading:!1,isFetching:!0});case"PAGE_LOADED":return G(G({},s),{data:n.payload,isFetching:!0});case"FETCH_SUCCESS":return G(G({},s),{data:n.payload,isLoading:!1,isFetching:!1,error:void 0});case"FETCH_ERROR":return G(G({},s),{isLoading:!1,isFetching:!1,error:n.payload})}}},h=function(s,n,t){t===void 0&&(t=10);var i=useReducer(P(),Ue()),a=i[0],o=i[1],l=useRef(!0),u=useRef("");return useEffect(function(){var m=JSON.stringify(n);if(u.current!==m){u.current=m,o({type:"FETCH_START"});var d=function(q){l.current&&o(q)},p=function(q,Z){var U=q===0?"FIRST_PAGE_LOADED":"PAGE_LOADED";d({type:U,payload:Z})},g=function(){return ee(void 0,void 0,void 0,function(){var q,Z;return he(this,function(U){switch(U.label){case 0:return U.trys.push([0,2,,3]),[4,je(s,n,t,p)];case 1:return q=U.sent(),d({type:"FETCH_SUCCESS",payload:q}),[3,3];case 2:return Z=U.sent(),d({type:"FETCH_ERROR",payload:Z}),[3,3];case 3:return[2]}})})};g()}},[n,t,s]),useEffect(function(){return function(){l.current=!1}},[]),a},I=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},A=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}};function O(s){if(s){var n=new URL(s).search,t=new URLSearchParams(n),i=t.get("startingAfter");if(i)return{startingAfter:i};var a=t.get("endingBefore");if(a)return{endingBefore:a}}}function S(s){var n=s||{},t=n.startingAfter,i=n.endingBefore;if(i)return{endingBefore:i};if(t)return{startingAfter:t}}function B(s,n){var t=s?.firstPageUrl?O(s?.firstPageUrl):void 0,i=s?.lastPageUrl?O(s?.lastPageUrl):void 0,a=s?.prevPageUrl?O(s?.prevPageUrl):void 0,o=s?.nextPageUrl?O(s?.nextPageUrl):void 0,l=S(n)||t;return{first:t,prev:a,next:o,last:i,current:l}}var J=function(s){return I(void 0,void 0,void 0,function(){var n,t;return A(this,function(i){switch(i.label){case 0:return n=[],t=[],[4,(0,C.paginatedApiRequest)(n.push.bind(n),t.push.bind(t),s)];case 1:return i.sent(),[2,{data:n,errors:t}]}})})},e=j(7448),be=/^(([A-F0-9]{2}[:]){5}[A-F0-9]{2})+$/i,ve=e.Ay.custom(function(s){return be.test(s)}),Ke=/\d\d\d\d-\d\d-\d\dT\d\d:\d\d:[\d.]+Z/,Xe=e.Ay.custom(function(s){return Ke.test(s)}),ht=function(s){return s.toISOString()},He=function(s){return z.object({items:z.array(s),meta:z.object({counts:z.object({items:z.object({total:z.number(),remaining:z.number().optional()})})})})},$e=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},et=k.v1.enhanceEndpoints({addTagTypes:["SubscriptionNetwork"]}).injectEndpoints({endpoints:function(s){return{getSubscriptionNetworks:s.query({query:function(n){return{url:"administered/licensing/subscription/networks",params:n}},transformResponse:function(n,t,i){var a=B(t,i),o=n;return{records:o,cursors:a}},providesTags:function(n,t,i){var a;if(!n||t)return[];var o=n.records.map(function(m){var d=m.id;return{type:"SubscriptionNetwork",id:d}})||[],l=((a=i.subscriptionIds)===null||a===void 0?void 0:a.length)===1?i.subscriptionIds[0]:void 0,u=l?[{type:"SubscriptionNetwork",id:"SUB-".concat(l)}]:[];return $e($e(["SubscriptionNetwork"],o,!0),u,!0)}})}}}),bt=et.useGetSubscriptionNetworksQuery,Je=et.useLazyGetSubscriptionNetworksQuery,te=function(s,n){return createSelector(et.endpoints.getSubscriptionNetworks.select({organizationIds:[n]}),function(t){var i,a,o=(a=(i=t.data)===null||i===void 0?void 0:i.records)!==null&&a!==void 0?a:[],l=o.find(function(u){return u.id===s});return l?l.name:void 0})},Pe=function(s,n){n===void 0&&(n=10);var t=Je()[0];return useInfiniteQuery(t,s,n)},ft=k.v1.injectEndpoints({endpoints:function(s){return{getFeatureTierTrials:s.query({query:function(n){return{url:"administered/licensing/subscription/networks/featureTierTrials",params:n}}})}}}).useGetFeatureTierTrialsQuery,Oe=function(s,n){return!s||s.items.length===0||n?[]:s.items.map(function(t){return{type:"SubscriptionNetwork",id:t.network.id}})},zt=k.v1.enhanceEndpoints({addTagTypes:["Subscription","SubscriptionNetwork"]}).injectEndpoints({endpoints:function(s){return{featureTiersBatchUpdate:s.mutation({query:function(n){return{url:"administered/licensing/subscription/networks/featureTiers/batchUpdate",method:"POST",body:n}},invalidatesTags:Oe})}}}).useFeatureTiersBatchUpdateMutation,w=k.v1.enhanceEndpoints({addTagTypes:["NetworkCount"]}).injectEndpoints({endpoints:function(s){return{getSubscriptionNetworkOverview:s.query({query:function(n){return{url:"administered/licensing/subscription/networks/overview",params:n}},providesTags:["NetworkCount"]})}}}).useGetSubscriptionNetworkOverviewQuery,b=k.v1.enhanceEndpoints({addTagTypes:["Subscription","SubscriptionNetwork"]}).injectEndpoints({endpoints:function(s){return{switchFeatureTier:s.mutation({query:function(n){var t=n.networkId,i=n.productTypes;return{url:"administered/licensing/subscription/networks/".concat(t),method:"PUT",body:{productTypes:i}}},invalidatesTags:function(n,t){return!n||t||n.insufficientEntitlements.length?[]:[{type:"Subscription",id:n.subscriptionId},{type:"SubscriptionNetwork",id:n.network.id}]}})}}}).useSwitchFeatureTierMutation,v=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},y=k.v1.enhanceEndpoints({addTagTypes:["Subscription","SubscriptionNetwork"]}).injectEndpoints({endpoints:function(s){return{unbindNetworks:s.mutation({query:function(n){var t=n.networkIds;return{url:"administered/licensing/subscription/networks/unbind",method:"POST",body:{networkIds:t},headers:{"Content-type":"application/json; charset=UTF-8"}}},invalidatesTags:function(n,t){var i;return!((i=n?.errors)===null||i===void 0)&&i.length||t||!n?[]:v(["Subscription"],n.networks.map(function(a){var o=a.id;return{type:"SubscriptionNetwork",id:o}}),!0)}})}}}).useUnbindNetworksMutation,Y=k.v1.injectEndpoints({endpoints:function(s){return{organizationCounts:s.query({query:function(n){var t=n.subscriptionId,i=n.organizationIds;return{url:"administered/licensing/subscription/subscriptions/".concat(t,"/organizations"),params:{organizationIds:i}}}})}}}),x=Y.useOrganizationCountsQuery,ie=function(){return ie=Object.assign||function(s){for(var n,t=1,i=arguments.length;t<i;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(s[a]=n[a])}return s},ie.apply(this,arguments)},de=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},le="Subscription",M=k.v1.enhanceEndpoints({addTagTypes:[le]}).injectEndpoints({endpoints:function(s){return{getSubscriptions:s.query({query:function(n){return{url:"administered/licensing/subscription/subscriptions",params:ie({perPage:1e3},n)}},transformResponse:function(n,t,i){var a=B(t,i),o=n;return{records:o,cursors:a}},providesTags:function(n){return n?de(de([],n.records.map(function(t){var i=t.subscriptionId;return{type:le,id:i}}),!0),[le],!1):[le]}})}}}),ge=M.useGetSubscriptionsQuery,tt=function(s,n){return createSelector(M.endpoints.getSubscriptions.select({organizationIds:[n]}),function(t){var i,a,o=(a=(i=t.data)===null||i===void 0?void 0:i.records)!==null&&a!==void 0?a:[],l=o.find(function(u){return u.subscriptionId===s});return l?l.name:void 0})},mt=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))};function Wi(s){var n=s.networkIds,t=s.networks;if(n?.length)return{networkIds:n};if(t?.length)return{networks:t};throw new Error("Either networkIds or networks must be provided")}var Wn=k.v1.enhanceEndpoints({addTagTypes:["Subscription","SubscriptionNetwork"]}).injectEndpoints({endpoints:function(s){return{bindNetworks:s.mutation({query:function(n){var t=n.subscriptionId,i=n.networkIds,a=n.networks,o=n.validate;return{url:"administered/licensing/subscription/subscriptions/".concat(t,"/bind"),method:"POST",params:{validate:o},body:Wi({networkIds:i,networks:a}),headers:{"Content-type":"application/json; charset=UTF-8"}}},invalidatesTags:function(n,t,i){var a,o;if(i.validate||!n||!((a=n.errors)===null||a===void 0)&&a.length||t)return[];var l={type:"Subscription",id:i.subscriptionId},u={type:"SubscriptionNetwork",id:"SUB-".concat(i.subscriptionId)},m=(o=n.networks)===null||o===void 0?void 0:o.map(function(d){var p=d.id;return{type:"SubscriptionNetwork",id:p}});return mt([l,u],m,!0)}})}}}).useBindNetworksMutation,Kn=k.v1.injectEndpoints({endpoints:function(s){return{getSubscriptionChanges:s.query({query:function(n){return{url:"administered/licensing/subscription/subscriptions/changes",params:n}}})}}}).useGetSubscriptionChangesQuery;function Ki(s){return Object.fromEntries(Object.entries(s).filter(function(n){var t=n[1];return!!t}))}var Xn=k.v1.enhanceEndpoints({addTagTypes:["Subscription","SubscriptionCount"]}).injectEndpoints({endpoints:function(s){return{claimSubscription:s.mutation({query:function(n){var t=n.claimKey,i=n.organizationId,a=n.name,o=n.description,l=n.validate;return{url:"administered/licensing/subscription/subscriptions/claim",method:"POST",params:l?{validate:!0}:{},body:Ki({claimKey:t.trim(),organizationId:i,name:a,description:o}),headers:{"Content-type":"application/json; charset=UTF-8"}}},invalidatesTags:function(){return["Subscription","SubscriptionCount"]}})}}}).useClaimSubscriptionMutation,Jn=k.v1.injectEndpoints({endpoints:function(s){return{subscriptionComplianceStatuses:s.query({query:function(n){return{url:"administered/licensing/subscription/subscriptions/compliance/statuses",params:n}}})}}}).useSubscriptionComplianceStatusesQuery,Zn=k.v1.enhanceEndpoints({addTagTypes:["Subscription"]}).injectEndpoints({endpoints:function(s){return{editSubscription:s.mutation({query:function(n){return{url:"administered/licensing/subscription/subscriptions/".concat(n.id),method:"PUT",body:n,headers:{"Content-type":"application/json; charset=UTF-8"}}},invalidatesTags:function(n){return n?[{type:"Subscription",id:n.subscriptionId}]:[]}})}}}).useEditSubscriptionMutation,gt="SubscriptionCount",$n=k.v1.enhanceEndpoints({addTagTypes:[gt]}).injectEndpoints({endpoints:function(s){return{getSubscriptionOverview:s.query({query:function(n){return{url:"administered/licensing/subscription/subscriptions/overview",params:n}},providesTags:[gt]})}}}).useGetSubscriptionOverviewQuery,Xi=k.v1.injectEndpoints({endpoints:function(s){return{partnerInfo:s.query({query:function(n){var t=n.subscriptionId,i=n.organizationIds;return{url:"administered/licensing/subscription/subscriptions/".concat(t,"/partner"),params:{organizationIds:i}}}})}}}),ea=Xi.usePartnerInfoQuery,Ji=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Zi=k.v1.enhanceEndpoints({addTagTypes:["SubscriptionNetwork"]}).injectEndpoints({endpoints:function(s){return{networkManagementMode:s.mutation({query:function(n){var t=n.networkId,i=Ji(n,["networkId"]);return{url:"administered/licensing/cssm/networks/".concat(t,"/settings"),method:"PUT",body:i}},invalidatesTags:function(n,t,i){return t||!n||!n.success?[]:[{type:"SubscriptionNetwork",id:i.networkId}]}})}}}),ta=Zi.useNetworkManagementModeMutation,$i=k.v1.injectEndpoints({endpoints:function(s){return{smartAccounts:s.query({query:function(n){return{url:"administered/licensing/cssm/smartAccounts",method:"GET",params:n||{}}}})}}}),ia=$i.useSmartAccountsQuery,eo=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},to=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},io=k.v1.injectEndpoints({endpoints:function(s){return{virtualAccount:s.query({queryFn:function(n){return eo(this,arguments,void 0,function(t){var i,a,o,l=t.smartAccountId;return to(this,function(u){switch(u.label){case 0:return[4,J({method:"GET",url:"/api/v1/administered/licensing/cssm/smartAccounts/".concat(l,"/virtualAccounts")})];case 1:return i=u.sent(),a=i.data,o=i.errors,o.length>0?[2,{error:{errors:o.flat()}}]:[2,{data:a.flat()}]}})})}})}}}),oa=io.useVirtualAccountQuery,oo=k.v1.enhanceEndpoints({addTagTypes:["Subscription"]}).injectEndpoints({endpoints:function(s){return{updateSubscriptionSmartAccount:s.mutation({query:function(n){return{url:"administered/licensing/cssm/smartAccounts/subscriptions",method:"POST",body:n,headers:{"Content-type":"application/json; charset=UTF-8"}}},invalidatesTags:function(n,t,i){return t||!n||!n.success?[]:[{type:"Subscription",id:i.subscriptionId}]}})}}}),ra=oo.useUpdateSubscriptionSmartAccountMutation,Jt=k.v1.injectEndpoints({endpoints:function(s){return{userLoginStatus:s.query({query:function(){return{url:"administered/licensing/cssm/userLoginStatus"}}})}}}),na=Jt.useUserLoginStatusQuery,aa=Jt.useLazyUserLoginStatusQuery,ro=k.v1.injectEndpoints({endpoints:function(s){return{getWarmSpareSettings:s.query({query:function(n){var t=n.networkId;return{url:"networks/".concat(t,"/appliance/warmSpare")}}})}}}),sa=ro.useGetWarmSpareSettingsQuery,no=k.v1.injectEndpoints({endpoints:function(s){return{getNetworkApplianceSettings:s.query({query:function(n){var t=n.networkId;return{url:"networks/".concat(t,"/appliance/settings")}}})}}}),da=no.useGetNetworkApplianceSettingsQuery,Zt=k.v1.injectEndpoints({endpoints:function(s){return{getClients:s.query({query:function(n){var t=n.networkId,i=n.params;return{url:"networks/".concat(t,"/clients"),params:i}},keepUnusedDataFor:0}),provisionClient:s.mutation({query:function(n){var t=n.networkId,i=n.data;return{url:"networks/".concat(t,"/clients/provision"),method:"POST",body:i}}})}}}),la=Zt.useProvisionClientMutation,ca=Zt.useGetClientsQuery,pa=k.v1.injectEndpoints({endpoints:function(s){return{removeNetworkDevices:s.mutation({query:function(n){var t=n.serial,i=n.networkId;return{url:"networks/".concat(i,"/devices/remove"),method:"POST",body:{serial:t},headers:{"Content-type":"application/json; charset=UTF-8"}}}})}},overrideExisting:!1}).useRemoveNetworkDevicesMutation,ao=k.v1.injectEndpoints({endpoints:function(s){return{getGroupPolicies:s.query({query:function(n){return{url:"networks/".concat(n,"/groupPolicies")}}})}}}),ua=ao.useGetGroupPoliciesQuery,so=k.v1.injectEndpoints({endpoints:function(s){return{getProductHealthSummary:s.query({query:function(n){var t=n.networkId,i=n.product;return{url:"networks/".concat(t,"/").concat(i,"/health/summary")}}})}}}),ha=so.useGetProductHealthSummaryQuery,lo=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},co=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},At=k.v1.enhanceEndpoints({addTagTypes:["Network"]}).injectEndpoints({endpoints:function(s){return{getNetwork:s.query({query:function(n){return"networks/".concat(n)},providesTags:function(n,t,i){return[{type:"Network",id:i}]}}),deleteNetwork:s.mutation({query:function(n){return{url:"networks/".concat(n),method:"DELETE"}},invalidatesTags:function(n,t,i){return[{type:"Network",id:i}]}}),deleteNetworks:s.mutation({queryFn:function(n){return lo(this,arguments,void 0,function(t){var i,a,o,l,u,m=t.organizationId,d=t.token,p=t.networkIds,g=t.synchronous,q=g===void 0?!1:g,Z=t.maxPollingTime,U=Z===void 0?60*1e3:Z;return co(this,function(pe){switch(pe.label){case 0:return pe.trys.push([0,2,,3]),i={auth:{csrfToken:d}},a={synchronous:q,maxPollingTime:U},o=p.map(function(fe){return{operation:"destroy",resource:"/networks/".concat(fe),body:{}}}),[4,(0,C.batchedApiRequest)(m,o,i,a)];case 1:return l=pe.sent(),[2,{data:l.data}];case 2:return u=pe.sent(),[2,{error:u}];case 3:return[2]}})})},invalidatesTags:["Network"]})}}}),ba=At.useGetNetworkQuery,fa=At.useDeleteNetworkMutation,ma=At.useDeleteNetworksMutation,po=k.v1.injectEndpoints({endpoints:function(s){return{getWirelessSsids:s.query({query:function(n){return{url:"networks/".concat(n,"/wireless/ssids")}}})}}}),ga=po.useGetWirelessSsidsQuery,Ae=j(1317),Ia=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),uo=e.Ik({enabled:e.zM().optional().describe("Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set"),vlanId:e.ai().int().optional().describe("Alternate management VLAN, must be between 1 and 4094"),protocols:e.YO(e.Yj().optional()).optional().describe("Can be one or more of the following values: 'radius', 'snmp' or 'syslog'"),switches:e.YO(e.Ik({serial:e.Yj().optional().describe("Switch serial number"),alternateManagementIp:e.Yj().optional().describe("Switch alternative management IP. To remove a prior IP setting, provide an empty string"),subnetMask:e.Yj().optional().describe("Switch subnet mask must be in IP format. Only and must be specified for Polaris switches"),gateway:e.Yj().optional().describe("Switch gateway must be in IP format. Only and must be specified for Polaris switches")}).optional()).optional().describe("Array of switch serial number and IP assignment. If parameter is present, it cannot have empty body. Note: switches parameter is not applicable for template networks, in other words, do not put 'switches' in the body when updating template networks. Also, an empty 'switches' array will remove all previous assignments")}).optional(),ho=k.v1.injectEndpoints({endpoints:function(s){var n=s.query;return{fetchNetworkAlternateManagementInterfaces:n({query:function(t){var i=t.path.networkId;return{url:"networks/".concat(i,"/switch/alternateManagementInterface"),method:"GET"}},transformResponse:(0,Ae._j)(uo,"networks/:networkId/switch/alternateManagementInterface")})}}}),va=ho.useFetchNetworkAlternateManagementInterfacesQuery,se=j(4450),ya=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbors by network ID. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter address families by router ID. This filter uses multiple exact matches."),addressFamilyIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter address families by ID. This filter uses multiple exact matches.")})}),ka=e.Ik({items:e.YO(e.Ik({addressFamilyId:e.Yj().optional().describe("Object ID for the address family"),profile:e.Ik({id:e.Yj().optional().describe("Object ID for the address family's profile"),name:e.Yj().optional().describe("Name of the address family's profile")}).optional().describe("Information regarding the address family's profile"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the address family's router")}).optional().describe("Information regarding the address family's router"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the address family belongs to"),afi:e.Yj().optional().describe("The address family identifier (AFI) denoting the network layer protocol of the address family (e.g. 'ipv4') (CLI: 'address-family <afi> unicast')"),safi:e.Yj().optional().describe("The subsequent address family identifier (SAFI) denoting the route type and usage of the address family (e.g. 'unicast') (CLI: 'address-family ipv4 <safi>')"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF instance")}).optional().describe("The Virtual Routing and Forwarding (VRF) options for the address family")}).optional()).optional().describe("The top-level propery containing all address families"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of address families"),remaining:e.ai().int().optional().describe("The number of address families remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),wa=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({profile:e.Ik({id:e.Yj().optional().describe("Object ID for the address family's profile")}).describe("Information regarding the address family's profile"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the address family's router")}).describe("Information regarding the address family's router"),afi:e.k5(["ipv4"]).describe("The address family identifier (AFI) denoting the network layer protocol of the address family (e.g. 'ipv4') (CLI: 'address-family <afi> unicast')"),safi:e.k5(["unicast"]).describe("The subsequent address family identifier (SAFI) denoting the route type and usage of the address family (e.g. 'unicast') (CLI: 'address-family ipv4 <safi>')"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF instance")}).describe("The Virtual Routing and Forwarding (VRF) options for the address family")})}),ja=e.Ik({addressFamilyId:e.Yj().optional().describe("Object ID for the address family"),profile:e.Ik({id:e.Yj().optional().describe("Object ID for the address family's profile"),name:e.Yj().optional().describe("Name of the address family's profile")}).optional().describe("Information regarding the address family's profile"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the address family's router")}).optional().describe("Information regarding the address family's router"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the address family belongs to"),afi:e.Yj().optional().describe("The address family identifier (AFI) denoting the network layer protocol of the address family (e.g. 'ipv4') (CLI: 'address-family <afi> unicast')"),safi:e.Yj().optional().describe("The subsequent address family identifier (SAFI) denoting the route type and usage of the address family (e.g. 'unicast') (CLI: 'address-family ipv4 <safi>')"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF instance")}).optional().describe("The Virtual Routing and Forwarding (VRF) options for the address family")}).optional(),Ya=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),addressFamilyId:e.Yj().describe("Address family ID")})}),Ta=e.Vx(),Pa=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter address family profiles by network ID. This filter uses multiple exact matches."),profileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter address family profiles by ID. This filter uses multiple exact matches.")})}),Oa=e.Ik({items:e.YO(e.Ik({profileId:e.Yj().optional().describe("Object ID for the address family profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the address family profile belongs to"),name:e.Yj().optional().describe("The name describing the address family profile"),ebgp:e.Ik({paths:e.Ik({maximum:e.ai().int().optional().describe("An integer from 1 to 32, which determines how many paths can be installed in the routing table (CLI: 'maximum-paths <maximum>)'")}).optional().describe("Options related to the installation of paths in the routing table")}).optional().describe("Options related to eBGP configuration"),metrics:e.Ik({default:e.ai().int().optional().describe("An integer from 0 to 4,294,967,295, which indicates the IGP cost. A lower number indicates a preferred route. (CLI: 'default-metric <default>')")}).optional().describe("Options related to metrics for redistributing routes"),summarization:e.Ik({auto:e.Ik({enabled:e.zM().optional().describe("An option allowing BGP to automatically aggregate routes based on their network address (CLI: 'auto-summary')")}).optional().describe("Options related to the BGP auto summary feature")}).optional().describe("Options related to summarizing routing information in routing tables"),redistribution:e.Ik({static:e.Ik({enabled:e.zM().optional().describe("An option allowing static routes to be injected into the BGP routing table (CLI: 'redistribute static')")}).optional().describe("Options related to the BGP redistribute static feature"),connected:e.Ik({enabled:e.zM().optional().describe("An option allowing the router to inject locally connected network routes into the BGP routing table (CLI: 'redistribute connected')")}).optional().describe("Options related to the BGP redistribute connected feature")}).optional().describe("Options related to redistribution of routes from one routing domain into another routing domain")}).optional()).optional().describe("The top-level propery containing all address family profiles"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of address family profiles"),remaining:e.ai().int().optional().describe("The number of address family profiles remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Sa=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).describe("Information regarding the network the address family profile belongs to"),name:e.Yj().describe("The name describing the address family profile"),ebgp:e.Ik({paths:e.Ik({maximum:e.ai().int().optional().describe("An integer from 1 to 32, which determines how many paths can be installed in the routing table (CLI: 'maximum-paths <maximum>)'")}).optional().describe("Options related to the installation of paths in the routing table")}).optional().optional().describe("Options related to eBGP configuration"),metrics:e.Ik({default:e.ai().int().optional().describe("An integer from 0 to 4,294,967,295, which indicates the IGP cost. A lower number indicates a preferred route. (CLI: 'default-metric <default>')")}).optional().optional().describe("Options related to metrics for redistributing routes"),summarization:e.Ik({auto:e.Ik({enabled:e.zM().optional().describe("An option allowing BGP to automatically aggregate routes based on their network address (CLI: 'auto-summary')")}).optional().describe("Options related to the BGP auto summary feature")}).optional().optional().describe("Options related to summarizing routing information in routing tables"),redistribution:e.Ik({static:e.Ik({enabled:e.zM().optional().describe("An option allowing static routes to be injected into the BGP routing table (CLI: 'redistribute static')")}).optional().describe("Options related to the BGP redistribute static feature"),connected:e.Ik({enabled:e.zM().optional().describe("An option allowing the router to inject locally connected network routes into the BGP routing table (CLI: 'redistribute connected')")}).optional().describe("Options related to the BGP redistribute connected feature")}).optional().optional().describe("Options related to redistribution of routes from one routing domain into another routing domain")})}),Da=e.Ik({profileId:e.Yj().optional().describe("Object ID for the address family profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the address family profile belongs to"),name:e.Yj().optional().describe("The name describing the address family profile"),ebgp:e.Ik({paths:e.Ik({maximum:e.ai().int().optional().describe("An integer from 1 to 32, which determines how many paths can be installed in the routing table (CLI: 'maximum-paths <maximum>)'")}).optional().describe("Options related to the installation of paths in the routing table")}).optional().describe("Options related to eBGP configuration"),metrics:e.Ik({default:e.ai().int().optional().describe("An integer from 0 to 4,294,967,295, which indicates the IGP cost. A lower number indicates a preferred route. (CLI: 'default-metric <default>')")}).optional().describe("Options related to metrics for redistributing routes"),summarization:e.Ik({auto:e.Ik({enabled:e.zM().optional().describe("An option allowing BGP to automatically aggregate routes based on their network address (CLI: 'auto-summary')")}).optional().describe("Options related to the BGP auto summary feature")}).optional().describe("Options related to summarizing routing information in routing tables"),redistribution:e.Ik({static:e.Ik({enabled:e.zM().optional().describe("An option allowing static routes to be injected into the BGP routing table (CLI: 'redistribute static')")}).optional().describe("Options related to the BGP redistribute static feature"),connected:e.Ik({enabled:e.zM().optional().describe("An option allowing the router to inject locally connected network routes into the BGP routing table (CLI: 'redistribute connected')")}).optional().describe("Options related to the BGP redistribute connected feature")}).optional().describe("Options related to redistribution of routes from one routing domain into another routing domain")}).optional(),Ra=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),profileId:e.Yj().describe("Profile ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).optional().describe("Information regarding the network the address family profile belongs to"),name:e.Yj().optional().describe("The name describing the address family profile"),ebgp:e.Ik({paths:e.Ik({maximum:e.ai().int().optional().describe("An integer from 1 to 32, which determines how many paths can be installed in the routing table (CLI: 'maximum-paths <maximum>)'")}).optional().describe("Options related to the installation of paths in the routing table")}).optional().describe("Options related to eBGP configuration"),metrics:e.Ik({default:e.ai().int().optional().describe("An integer from 0 to 4,294,967,295, which indicates the IGP cost. A lower number indicates a preferred route. (CLI: 'default-metric <default>')")}).optional().describe("Options related to metrics for redistributing routes"),summarization:e.Ik({auto:e.Ik({enabled:e.zM().optional().describe("An option allowing BGP to automatically aggregate routes based on their network address (CLI: 'auto-summary')")}).optional().describe("Options related to the BGP auto summary feature")}).optional().describe("Options related to summarizing routing information in routing tables"),redistribution:e.Ik({static:e.Ik({enabled:e.zM().optional().describe("An option allowing static routes to be injected into the BGP routing table (CLI: 'redistribute static')")}).optional().describe("Options related to the BGP redistribute static feature"),connected:e.Ik({enabled:e.zM().optional().describe("An option allowing the router to inject locally connected network routes into the BGP routing table (CLI: 'redistribute connected')")}).optional().describe("Options related to the BGP redistribute connected feature")}).optional().describe("Options related to redistribution of routes from one routing domain into another routing domain")}).optional()}),za=e.Ik({profileId:e.Yj().optional().describe("Object ID for the address family profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the address family profile belongs to"),name:e.Yj().optional().describe("The name describing the address family profile"),ebgp:e.Ik({paths:e.Ik({maximum:e.ai().int().optional().describe("An integer from 1 to 32, which determines how many paths can be installed in the routing table (CLI: 'maximum-paths <maximum>)'")}).optional().describe("Options related to the installation of paths in the routing table")}).optional().describe("Options related to eBGP configuration"),metrics:e.Ik({default:e.ai().int().optional().describe("An integer from 0 to 4,294,967,295, which indicates the IGP cost. A lower number indicates a preferred route. (CLI: 'default-metric <default>')")}).optional().describe("Options related to metrics for redistributing routes"),summarization:e.Ik({auto:e.Ik({enabled:e.zM().optional().describe("An option allowing BGP to automatically aggregate routes based on their network address (CLI: 'auto-summary')")}).optional().describe("Options related to the BGP auto summary feature")}).optional().describe("Options related to summarizing routing information in routing tables"),redistribution:e.Ik({static:e.Ik({enabled:e.zM().optional().describe("An option allowing static routes to be injected into the BGP routing table (CLI: 'redistribute static')")}).optional().describe("Options related to the BGP redistribute static feature"),connected:e.Ik({enabled:e.zM().optional().describe("An option allowing the router to inject locally connected network routes into the BGP routing table (CLI: 'redistribute connected')")}).optional().describe("Options related to the BGP redistribute connected feature")}).optional().describe("Options related to redistribution of routes from one routing domain into another routing domain")}).optional(),Aa=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),profileId:e.Yj().describe("Profile ID")})}),xa=e.Vx(),Na=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbor address family bindings by network ID. This filter uses multiple exact matches."),bindingIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbor address family bindings by ID. This filter uses multiple exact matches."),neighborIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbor address family bindings by neighbor ID. This filter uses multiple exact matches."),addressFamilyIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbor address family bindings by address family ID. This filter uses multiple exact matches.")})}),Ca=e.Ik({items:e.YO(e.Ik({bindingId:e.Yj().optional().describe("Object ID for the binding"),addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family"),description:e.Yj().optional().describe("Text description of the address family afi and safi (e.g. 'ipv4 unicast') (CLI: 'address-family <afi> <safi>')")}).optional().describe("Information regarding the address family this binding is bound to"),neighbor:e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor"),ipAddress:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <ipAddress>')")}).optional().describe("Information regarding the neighbor the binding is bound to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the binding belongs to"),peering:e.Ik({enabled:e.zM().optional().describe("Whether peering is enabled for this address family and neighbor (CLI: 'neighbor 10.0.42.1 activate')")}).optional().describe("Options related to enabling peering for this address family and neighbor"),weight:e.ai().int().optional().describe("Set default weight for routes from this neighbor (CLI: 'neighbor 10.0.42.1 weight <weight>')"),advertisement:e.Ik({defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this neighbor (CLI: 'neighbor 10.0.42.1 default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor 10.0.42.1 soft-reconfiguration inbound)")}).optional().describe("Options related to soft reconfiguration")}).optional()).optional().describe("The top-level propery containing all neighbor address family bindings"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of bindings"),remaining:e.ai().int().optional().describe("The number of bindings remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),La=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family")}).describe("Information regarding the address family this binding is bound to"),neighbor:e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor")}).describe("Information regarding the neighbor the binding is bound to"),peering:e.Ik({enabled:e.zM().optional().describe("Whether peering is enabled for this address family and neighbor (CLI: 'neighbor 10.0.42.1 activate')")}).optional().optional().describe("Options related to enabling peering for this address family and neighbor"),weight:e.ai().int().optional().optional().describe("Set default weight for routes from this neighbor (CLI: 'neighbor 10.0.42.1 weight <weight>')"),advertisement:e.Ik({defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this neighbor (CLI: 'neighbor 10.0.42.1 default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().optional().describe("Options related to route advertisement"),softReconfiguration:e.Ik({direction:e.k5(["inbound"]).optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor 10.0.42.1 soft-reconfiguration inbound)")}).optional().optional().describe("Options related to soft reconfiguration")})}),Ma=e.Ik({bindingId:e.Yj().optional().describe("Object ID for the binding"),addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family"),description:e.Yj().optional().describe("Text description of the address family afi and safi (e.g. 'ipv4 unicast') (CLI: 'address-family <afi> <safi>')")}).optional().describe("Information regarding the address family this binding is bound to"),neighbor:e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor"),ipAddress:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <ipAddress>')")}).optional().describe("Information regarding the neighbor the binding is bound to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the binding belongs to"),peering:e.Ik({enabled:e.zM().optional().describe("Whether peering is enabled for this address family and neighbor (CLI: 'neighbor 10.0.42.1 activate')")}).optional().describe("Options related to enabling peering for this address family and neighbor"),weight:e.ai().int().optional().describe("Set default weight for routes from this neighbor (CLI: 'neighbor 10.0.42.1 weight <weight>')"),advertisement:e.Ik({defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this neighbor (CLI: 'neighbor 10.0.42.1 default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor 10.0.42.1 soft-reconfiguration inbound)")}).optional().describe("Options related to soft reconfiguration")}).optional(),Fa=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),bindingId:e.Yj().describe("Binding ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family")}).optional().describe("Information regarding the address family this binding is bound to"),neighbor:e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor")}).optional().describe("Information regarding the neighbor the binding is bound to"),peering:e.Ik({enabled:e.zM().optional().describe("Whether peering is enabled for this address family and neighbor (CLI: 'neighbor 10.0.42.1 activate')")}).optional().describe("Options related to enabling peering for this address family and neighbor"),weight:e.ai().int().optional().describe("Set default weight for routes from this neighbor (CLI: 'neighbor 10.0.42.1 weight <weight>')"),advertisement:e.Ik({defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this neighbor (CLI: 'neighbor 10.0.42.1 default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),softReconfiguration:e.Ik({direction:e.k5(["inbound"]).optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor 10.0.42.1 soft-reconfiguration inbound)")}).optional().describe("Options related to soft reconfiguration")}).optional()}),Ga=e.Ik({bindingId:e.Yj().optional().describe("Object ID for the binding"),addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family"),description:e.Yj().optional().describe("Text description of the address family afi and safi (e.g. 'ipv4 unicast') (CLI: 'address-family <afi> <safi>')")}).optional().describe("Information regarding the address family this binding is bound to"),neighbor:e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor"),ipAddress:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <ipAddress>')")}).optional().describe("Information regarding the neighbor the binding is bound to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the binding belongs to"),peering:e.Ik({enabled:e.zM().optional().describe("Whether peering is enabled for this address family and neighbor (CLI: 'neighbor 10.0.42.1 activate')")}).optional().describe("Options related to enabling peering for this address family and neighbor"),weight:e.ai().int().optional().describe("Set default weight for routes from this neighbor (CLI: 'neighbor 10.0.42.1 weight <weight>')"),advertisement:e.Ik({defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this neighbor (CLI: 'neighbor 10.0.42.1 default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor 10.0.42.1 soft-reconfiguration inbound)")}).optional().describe("Options related to soft reconfiguration")}).optional(),Ba=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),bindingId:e.Yj().describe("Binding ID")})}),qa=e.Vx(),Va=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family binding profiles by network ID. This filter uses multiple exact matches."),profileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family binding profiles by ID. This filter uses multiple exact matches.")})}),Ea=e.Ik({items:e.YO(e.Ik({profileId:e.Yj().optional().describe("Object ID for the peer group address family binding profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group address family binding profile belongs to"),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().describe("Information regarding the community attribute for peer groups for a given address family"),name:e.Yj().optional().describe("The name of the peer group address family binding profile"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")}).optional()).optional().describe("The top-level propery containing all peer group address family binding profiles"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of peer group address family binding profiles"),remaining:e.ai().int().optional().describe("The number of peer group address family binding profiles remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),_a=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).describe("Information regarding the network the peer group address family binding profile belongs to"),name:e.Yj().describe("The name of the peer group address family binding profile"),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().optional().describe("Information regarding the community attribute for peer groups for a given address family"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.k5(["inbound"]).optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")})}),Ua=e.Ik({profileId:e.Yj().optional().describe("Object ID for the peer group address family binding profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group address family binding profile belongs to"),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().describe("Information regarding the community attribute for peer groups for a given address family"),name:e.Yj().optional().describe("The name of the peer group address family binding profile"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")}).optional(),Ha=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),profileId:e.Yj().describe("Profile ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).optional().describe("Information regarding the network the peer group address family binding profile belongs to"),name:e.Yj().optional().describe("The name of the peer group address family binding profile"),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().describe("Information regarding the community attribute for peer groups for a given address family"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.k5(["inbound"]).optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")}).optional()}),Qa=e.Ik({profileId:e.Yj().optional().describe("Object ID for the peer group address family binding profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group address family binding profile belongs to"),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().describe("Information regarding the community attribute for peer groups for a given address family"),name:e.Yj().optional().describe("The name of the peer group address family binding profile"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")}).optional(),Wa=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),profileId:e.Yj().describe("Profile ID")})}),Ka=e.Vx(),Xa=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family bindings by network ID. This filter uses multiple exact matches."),addressFamilyIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family bindings by address family ID. This filter uses multiple exact matches."),peerGroupIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family bindings by peer group ID. This filter uses multiple exact matches."),profileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family bindings by peer group address family binding profile ID. This filter uses multiple exact matches."),bindingIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family bindings by ID. This filter uses multiple exact matches.")})}),Ja=e.Ik({items:e.YO(e.Ik({bindingId:e.Yj().optional().describe("Object ID for the peer group address family binding"),addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID"),description:e.Yj().optional().describe("The address family afi and safi (i.e. 'ipv4 unicast') (CLI: 'address-family <description>')")}).optional().describe("Information regarding the address family the peer group address family binding belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("The peer group object ID"),name:e.Yj().optional().describe("The peer group object name. (CLI: 'neighbor <name>')")}).optional().describe("Information regarding the peer group the peer group address family binding belongs to"),profile:e.Ik({id:e.Yj().optional().describe("The peer group address family binding profile object ID"),name:e.Yj().optional().describe("The peer group address family binding profile object name")}).optional().describe("Information regarding the peer group address family binding profile the peer group address family binding belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group address family binding belongs to")}).optional()).optional().describe("The top-level propery containing all peer group address family bindings"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of peer group address family bindings"),remaining:e.ai().int().optional().describe("The number of peer group address family bindings remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Za=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID")}).describe("Information regarding the address family the peer group address family binding belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("The peer group object ID")}).describe("Information regarding the peer group the peer group address family binding belongs to"),profile:e.Ik({id:e.Yj().optional().describe("The peer group address family binding profile object ID")}).describe("Information regarding the peer group address family binding profile the peer group address family binding belongs to")})}),$a=e.Ik({bindingId:e.Yj().optional().describe("Object ID for the peer group address family binding"),addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID"),description:e.Yj().optional().describe("The address family afi and safi (i.e. 'ipv4 unicast') (CLI: 'address-family <description>')")}).optional().describe("Information regarding the address family the peer group address family binding belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("The peer group object ID"),name:e.Yj().optional().describe("The peer group object name. (CLI: 'neighbor <name>')")}).optional().describe("Information regarding the peer group the peer group address family binding belongs to"),profile:e.Ik({id:e.Yj().optional().describe("The peer group address family binding profile object ID"),name:e.Yj().optional().describe("The peer group address family binding profile object name")}).optional().describe("Information regarding the peer group address family binding profile the peer group address family binding belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group address family binding belongs to")}).optional(),es=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),bindingId:e.Yj().describe("Binding ID")})}),ts=e.Vx(),is=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routing policies by network ID. This filter uses multiple exact matches."),policyIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routing policies by ID. This filter uses multiple exact matches."),neighborAddressFamilyBindingIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routing policies by neighbor address family binding IDs. This filter uses multiple exact matches."),peerGroupAddressFamilyBindingProfileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routing policies by peer group address family binding profile IDs. This filter uses multiple exact matches."),filterListIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routing policies by as path access list IDs. This filter uses multiple exact matches."),prefixListIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routing policies by prefix list IDs. This filter uses multiple exact matches."),directions:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routing policies by direction. This filter uses multiple exact matches.")})}),os=e.Ik({items:e.YO(e.Ik({policyId:e.Yj().optional().describe("Object ID for the policy"),addressFamilyBinding:e.Ik({type:e.k5(["Neighbor address family binding","Peer group address family binding"]).optional().describe("The type of the address family binding"),id:e.Yj().optional().describe("The address family binding object ID (CLI: 'neighbor <peer_group.name> filter-list 5 in' or 'neighbor <neighbor.ip_address> filter-list 5 in')")}).optional().describe("Information regarding the address family binding the policy belongs to"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),name:e.Yj().optional().describe("The name of the rule list For filter lists, this value corresponds to the list number (CLI: 'neighbor IBGP filter-list <name> in' or 'neighbor 10.10.248.254 prefix-list <name> in')"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the policy belongs to"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")}).optional()).optional().describe("The top-level property containing all routing policies"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of routing policies"),remaining:e.ai().int().optional().describe("The number of routing policies remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),rs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({addressFamilyBinding:e.Ik({type:e.k5(["Neighbor address family binding","Peer group address family binding"]).optional().describe("The type of the address family binding"),id:e.Yj().optional().describe("The address family binding object ID (CLI: 'neighbor <peer_group.name> filter-list 5 in' or 'neighbor <neighbor.ip_address> filter-list 5 in')")}).describe("Information regarding the address family binding the policy belongs to"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),id:e.Yj().optional().describe("The filter list object ID")}).describe("Information regarding the list of filter rules that the policy uses"),direction:e.k5(["in","out"]).describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")})}),ns=e.Ik({policyId:e.Yj().optional().describe("Object ID for the policy"),addressFamilyBinding:e.Ik({type:e.k5(["Neighbor address family binding","Peer group address family binding"]).optional().describe("The type of the address family binding"),id:e.Yj().optional().describe("The address family binding object ID (CLI: 'neighbor <peer_group.name> filter-list 5 in' or 'neighbor <neighbor.ip_address> filter-list 5 in')")}).optional().describe("Information regarding the address family binding the policy belongs to"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),name:e.Yj().optional().describe("The name of the rule list For filter lists, this value corresponds to the list number (CLI: 'neighbor IBGP filter-list <name> in' or 'neighbor 10.10.248.254 prefix-list <name> in')"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the policy belongs to"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")}).optional(),as=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),policyId:e.Yj().describe("Policy ID")}),body:e.Ik({addressFamilyBinding:e.Ik({type:e.k5(["Neighbor address family binding","Peer group address family binding"]).optional().describe("The type of the address family binding"),id:e.Yj().optional().describe("The address family binding object ID (CLI: 'neighbor <peer_group.name> filter-list 5 in' or 'neighbor <neighbor.ip_address> filter-list 5 in')")}).optional().describe("Information regarding the address family binding the policy belongs to"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")}).optional()}),ss=e.Ik({policyId:e.Yj().optional().describe("Object ID for the policy"),addressFamilyBinding:e.Ik({type:e.k5(["Neighbor address family binding","Peer group address family binding"]).optional().describe("The type of the address family binding"),id:e.Yj().optional().describe("The address family binding object ID (CLI: 'neighbor <peer_group.name> filter-list 5 in' or 'neighbor <neighbor.ip_address> filter-list 5 in')")}).optional().describe("Information regarding the address family binding the policy belongs to"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),name:e.Yj().optional().describe("The name of the rule list For filter lists, this value corresponds to the list number (CLI: 'neighbor IBGP filter-list <name> in' or 'neighbor 10.10.248.254 prefix-list <name> in')"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the policy belongs to"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")}).optional(),ds=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),policyId:e.Yj().describe("Policy ID")})}),ls=e.Vx(),cs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),addressFamilyIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter address prefixes by address family ID. This filter uses multiple exact matches"),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter address family prefixes by network ID. This filter uses multiple exact matches."),prefixIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter address family prefixes by ID. This filter uses multiple exact matches.")})}),ps=e.Ik({items:e.YO(e.Ik({prefixId:e.Yj().optional().describe("The ID of the address family's prefix"),network:e.Ik({id:e.Yj().optional().describe("Object ID for the network"),name:e.Yj().optional().describe("The name of the network")}).optional().describe("Information regarding the network the prefix belongs to"),addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix's address family"),description:e.Yj().optional().describe("Description for the prefix's address family")}).optional().describe("Information regarding the prefix's address family"),prefix:e.Yj().optional().describe("The IP prefix in CIDR notation (CLI: network <ip-address>)"),enabled:e.zM().optional().describe("A boolean indicating whether the address family prefix is enabled"),description:e.Yj().optional().describe("A description of the address family prefix")}).optional()).optional().describe("The top-level propery containing all address family prefixes"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of address family prefixes"),remaining:e.ai().int().optional().describe("The number of address family prefixes remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),us=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix's address family")}).describe("Information regarding the prefix's address family"),prefix:e.Yj().describe("The IP prefix in CIDR notation (CLI: network <ip-address>)"),enabled:e.zM().optional().optional().describe("A boolean indicating whether the address family prefix is enabled"),description:e.Yj().optional().optional().describe("A description of the address family prefix")})}),hs=e.Ik({prefixId:e.Yj().optional().describe("The ID of the address family's prefix"),network:e.Ik({id:e.Yj().optional().describe("Object ID for the network"),name:e.Yj().optional().describe("The name of the network")}).optional().describe("Information regarding the network the prefix belongs to"),addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix's address family"),description:e.Yj().optional().describe("Description for the prefix's address family")}).optional().describe("Information regarding the prefix's address family"),prefix:e.Yj().optional().describe("The IP prefix in CIDR notation (CLI: network <ip-address>)"),enabled:e.zM().optional().describe("A boolean indicating whether the address family prefix is enabled"),description:e.Yj().optional().describe("A description of the address family prefix")}).optional(),bs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),prefixId:e.Yj().describe("Prefix ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix's address family")}).optional().describe("Information regarding the prefix's address family"),prefix:e.Yj().optional().describe("The IP prefix in CIDR notation (CLI: network <ip-address>)"),enabled:e.zM().optional().describe("A boolean indicating whether the address family prefix is enabled"),description:e.Yj().optional().describe("A description of the address family prefix")}).optional()}),fs=e.Ik({prefixId:e.Yj().optional().describe("The ID of the address family's prefix"),network:e.Ik({id:e.Yj().optional().describe("Object ID for the network"),name:e.Yj().optional().describe("The name of the network")}).optional().describe("Information regarding the network the prefix belongs to"),addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix's address family"),description:e.Yj().optional().describe("Description for the prefix's address family")}).optional().describe("Information regarding the prefix's address family"),prefix:e.Yj().optional().describe("The IP prefix in CIDR notation (CLI: network <ip-address>)"),enabled:e.zM().optional().describe("A boolean indicating whether the address family prefix is enabled"),description:e.Yj().optional().describe("A description of the address family prefix")}).optional(),ms=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),prefixId:e.Yj().describe("Prefix ID")})}),gs=e.Vx(),Is=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter 'filter list' rules by network ID. This filter uses multiple exact matches."),ruleIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter 'filter list' rules by ID. This filter uses multiple exact matches."),filterListIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter 'filter lists' by ID. This filter uses multiple exact matches.")})}),vs=e.Ik({items:e.YO(e.Ik({ruleId:e.Yj().optional().describe("Object ID for the filter list rule"),filterList:e.Ik({id:e.Yj().optional().describe("Information regarding the rule's filter list"),name:e.Yj().optional().describe("The filter list number (CLI: ip as-path access-list <name> permit ^100$)")}).optional().describe("The filter list the rule belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the filter list belongs to"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be added to the device's config"),policy:e.Yj().optional().describe("The policy for the rule (CLI: ip as-path access-list 3 <policy> ^109$)"),match:e.Ik({regex:e.Yj().optional().describe("The regex for the match criteria (CLI: ip as-path access-list 3 permit <regex>)")}).optional().describe("The match criteria for the rule")}).optional()).optional().describe("The top-level propery containing all filter list rules"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of filter list rules"),remaining:e.ai().int().optional().describe("The number of filter list rules remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),ys=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({filterList:e.Ik({id:e.Yj().optional().describe("Information regarding the rule's filter list")}).describe("The filter list the rule belongs to"),sequenceNumber:e.ai().int().describe("The sequence number for the rule, defining the order in which rules will be added to the device's config"),policy:e.k5(["deny","permit"]).describe("The policy for the rule (CLI: ip as-path access-list 3 <policy> ^109$)"),match:e.Ik({regex:e.Yj().optional().describe("The regex for the match criteria (CLI: ip as-path access-list 3 permit <regex>)")}).describe("The match criteria for the rule")})}),ks=e.Ik({ruleId:e.Yj().optional().describe("Object ID for the filter list rule"),filterList:e.Ik({id:e.Yj().optional().describe("Information regarding the rule's filter list"),name:e.Yj().optional().describe("The filter list number (CLI: ip as-path access-list <name> permit ^100$)")}).optional().describe("The filter list the rule belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the filter list belongs to"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be added to the device's config"),policy:e.Yj().optional().describe("The policy for the rule (CLI: ip as-path access-list 3 <policy> ^109$)"),match:e.Ik({regex:e.Yj().optional().describe("The regex for the match criteria (CLI: ip as-path access-list 3 permit <regex>)")}).optional().describe("The match criteria for the rule")}).optional(),ws=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),ruleId:e.Yj().describe("Rule ID")}),body:e.Ik({filterList:e.Ik({id:e.Yj().optional().describe("Information regarding the rule's filter list")}).optional().describe("The filter list the rule belongs to"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be added to the device's config"),policy:e.k5(["deny","permit"]).optional().describe("The policy for the rule (CLI: ip as-path access-list 3 <policy> ^109$)"),match:e.Ik({regex:e.Yj().optional().describe("The regex for the match criteria (CLI: ip as-path access-list 3 permit <regex>)")}).optional().describe("The match criteria for the rule")}).optional()}),js=e.Ik({ruleId:e.Yj().optional().describe("Object ID for the filter list rule"),filterList:e.Ik({id:e.Yj().optional().describe("Information regarding the rule's filter list"),name:e.Yj().optional().describe("The filter list number (CLI: ip as-path access-list <name> permit ^100$)")}).optional().describe("The filter list the rule belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the filter list belongs to"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be added to the device's config"),policy:e.Yj().optional().describe("The policy for the rule (CLI: ip as-path access-list 3 <policy> ^109$)"),match:e.Ik({regex:e.Yj().optional().describe("The regex for the match criteria (CLI: ip as-path access-list 3 permit <regex>)")}).optional().describe("The match criteria for the rule")}).optional(),Ys=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),ruleId:e.Yj().describe("Rule ID")})}),Ts=e.Vx(),Ps=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter 'filter lists' by network ID. This filter uses multiple exact matches."),listIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter 'filter lists' by ID. This filter uses multiple exact matches.")})}),Os=e.Ik({items:e.YO(e.Ik({listId:e.Yj().optional().describe("Object ID for the filter list"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the filter list belongs to"),name:e.Yj().optional().describe("The filter list number(CLI: ip as-path access-list <name> permit ^100$)"),description:e.Yj().optional().describe("The description of the filter list")}).optional()).optional().describe("The top-level propery containing all filter lists"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of filter lists"),remaining:e.ai().int().optional().describe("The number of filter lists remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Ss=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).describe("Information regarding the network the filter list belongs to"),name:e.Yj().describe("The filter list number(CLI: ip as-path access-list <name> permit ^100$)"),description:e.Yj().optional().optional().describe("The description of the filter list")})}),Ds=e.Ik({listId:e.Yj().optional().describe("Object ID for the filter list"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the filter list belongs to"),name:e.Yj().optional().describe("The filter list number(CLI: ip as-path access-list <name> permit ^100$)"),description:e.Yj().optional().describe("The description of the filter list")}).optional(),Rs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter 'filter list' overviews by network ID. This filter uses multiple exact matches."),listIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter 'filter list' overviews by ID. This filter uses multiple exact matches.")})}),zs=e.Ik({items:e.YO(e.Ik({listId:e.Yj().optional().describe("Object ID for the filter list"),counts:e.Ik({neighbors:e.Ik({total:e.ai().int().optional().describe("Total number of neighbors configured with this filter list")}).optional().describe("Information regarding the neighbors configured with this filter list"),peerGroups:e.Ik({total:e.ai().int().optional().describe("Total number of peer groups configured with this filter list")}).optional().describe("Information regarding the peer groups configured with this filter list"),rules:e.Ik({total:e.ai().int().optional().describe("Total number of filter list rules in this filter list")}).optional().describe("Information regarding the filter list rules")}).optional().describe("Counts related to the filter list")}).optional()).optional().describe("The top-level property containing all filter list overviews"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of filter list overviews"),remaining:e.ai().int().optional().describe("The number of filter list overviews remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),As=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({filterList:e.Ik({id:e.Yj().optional().describe("Object ID for the filter list"),name:e.Yj().optional().describe("The filter list number(CLI: ip as-path access-list <name> permit ^100$)"),description:e.Yj().optional().describe("The description of the filter list")}).describe("Information regarding the filter list"),network:e.Ik({id:e.Yj().optional().describe("The network ID")}).describe("Information regarding the network the filter list belongs to"),rules:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the filter list rule"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be added to the device's config"),policy:e.k5(["deny","permit"]).optional().describe("The policy for the rule (CLI: ip as-path access-list 3 <policy> ^109$)"),match:e.Ik({regex:e.Yj().optional().describe("The regex for the match criteria (CLI: ip as-path access-list 3 permit <regex>)")}).optional().describe("The match criteria for the rule"),destroy:e.zM().optional().describe("Flag to indicate if the filter list rule should be destroyed")}).optional()).describe("Information regarding the filter list rules")})}),xs=e.Ik({filterList:e.Ik({id:e.Yj().optional().describe("Object ID for the filter list"),name:e.Yj().optional().describe("The filter list number(CLI: ip as-path access-list <name> permit ^100$)"),description:e.Yj().optional().describe("The description of the filter list")}).optional().describe("Information regarding the filter list"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the filter list belongs to"),rules:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the filter list rule"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be added to the device's config"),policy:e.Yj().optional().describe("The policy for the rule (CLI: ip as-path access-list 3 <policy> ^109$)"),match:e.Ik({regex:e.Yj().optional().describe("The regex for the match criteria (CLI: ip as-path access-list 3 permit <regex>)")}).optional().describe("The match criteria for the rule")}).optional()).optional().describe("Information regarding the filter list rules")}).optional(),Ns=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),listId:e.Yj().describe("List ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).optional().describe("Information regarding the network the filter list belongs to"),name:e.Yj().optional().describe("The filter list number(CLI: ip as-path access-list <name> permit ^100$)"),description:e.Yj().optional().describe("The description of the filter list")}).optional()}),Cs=e.Ik({listId:e.Yj().optional().describe("Object ID for the filter list"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the filter list belongs to"),name:e.Yj().optional().describe("The filter list number(CLI: ip as-path access-list <name> permit ^100$)"),description:e.Yj().optional().describe("The description of the filter list")}).optional(),Ls=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),listId:e.Yj().describe("List ID")})}),Ms=e.Vx(),Fs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter prefix list rules by network ID. This filter uses multiple exact matches."),prefixListIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter prefix list rules by prefix list ID. This filter uses multiple exact matches."),ruleIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter prefix list rules by ID. This filter uses multiple exact matches.")})}),Gs=e.Ik({items:e.YO(e.Ik({ruleId:e.Yj().optional().describe("Object ID for the prefix list rule"),prefixList:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list"),name:e.Yj().optional().describe("Name of the prefix list. (CLI: 'ip prefix-list <name> seq 5')")}).optional().describe("Information regarding the prefix list that the rule belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the prefix list rule belongs to"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be processed (CLI: 'ip prefix-list NoPrivateNets seq <sequenceNumber>')"),policy:e.k5(["deny","permit"]).optional().describe("Option to 'permit' or 'deny' traffic that matches the defined condition for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny')"),conditions:e.Ik({cidr:e.Yj().optional().describe("The cidr address to match for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny <cidr>')"),prefixLength:e.Ik({minimum:e.ai().int().optional().describe("The minimum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length greater than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny ge <minimum>')"),maximum:e.ai().int().optional().describe("The maximum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length less than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny le <maximum>')")}).optional().describe("Optional prefix length range conditions for the rule")}).optional().describe("The conditions that define the rule behavior for matching traffic")}).optional()).optional().describe("The top-level propery containing all prefix list rules"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of prefix list rules"),remaining:e.ai().int().optional().describe("The number of prefix list rules remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Bs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({prefixList:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list")}).describe("Information regarding the prefix list that the rule belongs to"),sequenceNumber:e.ai().int().describe("The sequence number for the rule, defining the order in which rules will be processed (CLI: 'ip prefix-list NoPrivateNets seq <sequenceNumber>')"),policy:e.k5(["deny","permit"]).describe("Option to 'permit' or 'deny' traffic that matches the defined condition for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny')"),conditions:e.Ik({cidr:e.Yj().optional().describe("The cidr address to match for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny <cidr>')"),prefixLength:e.Ik({minimum:e.ai().int().optional().describe("The minimum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length greater than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny ge <minimum>')"),maximum:e.ai().int().optional().describe("The maximum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length less than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny le <maximum>')")}).optional().describe("Optional prefix length range conditions for the rule")}).describe("The conditions that define the rule behavior for matching traffic")})}),qs=e.Ik({ruleId:e.Yj().optional().describe("Object ID for the prefix list rule"),prefixList:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list"),name:e.Yj().optional().describe("Name of the prefix list. (CLI: 'ip prefix-list <name> seq 5')")}).optional().describe("Information regarding the prefix list that the rule belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the prefix list rule belongs to"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be processed (CLI: 'ip prefix-list NoPrivateNets seq <sequenceNumber>')"),policy:e.k5(["deny","permit"]).optional().describe("Option to 'permit' or 'deny' traffic that matches the defined condition for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny')"),conditions:e.Ik({cidr:e.Yj().optional().describe("The cidr address to match for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny <cidr>')"),prefixLength:e.Ik({minimum:e.ai().int().optional().describe("The minimum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length greater than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny ge <minimum>')"),maximum:e.ai().int().optional().describe("The maximum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length less than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny le <maximum>')")}).optional().describe("Optional prefix length range conditions for the rule")}).optional().describe("The conditions that define the rule behavior for matching traffic")}).optional(),Vs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),ruleId:e.Yj().describe("Rule ID")}),body:e.Ik({prefixList:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list")}).optional().describe("Information regarding the prefix list that the rule belongs to"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be processed (CLI: 'ip prefix-list NoPrivateNets seq <sequenceNumber>')"),policy:e.k5(["deny","permit"]).optional().describe("Option to 'permit' or 'deny' traffic that matches the defined condition for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny')"),conditions:e.Ik({cidr:e.Yj().optional().describe("The cidr address to match for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny <cidr>')"),prefixLength:e.Ik({minimum:e.ai().int().optional().describe("The minimum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length greater than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny ge <minimum>')"),maximum:e.ai().int().optional().describe("The maximum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length less than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny le <maximum>')")}).optional().describe("Optional prefix length range conditions for the rule")}).optional().describe("The conditions that define the rule behavior for matching traffic")}).optional()}),Es=e.Ik({ruleId:e.Yj().optional().describe("Object ID for the prefix list rule"),prefixList:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list"),name:e.Yj().optional().describe("Name of the prefix list. (CLI: 'ip prefix-list <name> seq 5')")}).optional().describe("Information regarding the prefix list that the rule belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the prefix list rule belongs to"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be processed (CLI: 'ip prefix-list NoPrivateNets seq <sequenceNumber>')"),policy:e.k5(["deny","permit"]).optional().describe("Option to 'permit' or 'deny' traffic that matches the defined condition for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny')"),conditions:e.Ik({cidr:e.Yj().optional().describe("The cidr address to match for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny <cidr>')"),prefixLength:e.Ik({minimum:e.ai().int().optional().describe("The minimum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length greater than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny ge <minimum>')"),maximum:e.ai().int().optional().describe("The maximum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length less than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny le <maximum>')")}).optional().describe("Optional prefix length range conditions for the rule")}).optional().describe("The conditions that define the rule behavior for matching traffic")}).optional(),_s=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),ruleId:e.Yj().describe("Rule ID")})}),Us=e.Vx(),Hs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter prefix lists by network ID. This filter uses multiple exact matches."),listIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter prefix lists by ID. This filter uses multiple exact matches.")})}),Qs=e.Ik({items:e.YO(e.Ik({listId:e.Yj().optional().describe("Object ID for the prefix list"),name:e.Yj().optional().describe("The name of the prefix list (CLI: 'ip prefix-list <name>')"),description:e.Yj().optional().describe("The description of the prefix list (CLI: 'ip prefix-list MyPrefixList description <description>')"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the prefix list belongs to")}).optional()).optional().describe("The top-level propery containing all prefix lists"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of prefix lists"),remaining:e.ai().int().optional().describe("The number of prefix lists remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Ws=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({name:e.Yj().describe("The name of the prefix list (CLI: 'ip prefix-list <name>')"),description:e.Yj().optional().optional().describe("The description of the prefix list (CLI: 'ip prefix-list MyPrefixList description <description>')"),network:e.Ik({id:e.Yj().optional().describe("The network ID")}).describe("Information regarding the network the prefix list belongs to")})}),Ks=e.Ik({listId:e.Yj().optional().describe("Object ID for the prefix list"),name:e.Yj().optional().describe("The name of the prefix list (CLI: 'ip prefix-list <name>')"),description:e.Yj().optional().describe("The description of the prefix list (CLI: 'ip prefix-list MyPrefixList description <description>')"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the prefix list belongs to")}).optional(),Xs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter prefix list overviews by network ID. This filter uses multiple exact matches."),listIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter prefix list overviews by ID. This filter uses multiple exact matches.")})}),Js=e.Ik({items:e.YO(e.Ik({listId:e.Yj().optional().describe("Object ID for the prefix list"),counts:e.Ik({neighbors:e.Ik({total:e.ai().int().optional().describe("Total number of neighbors configured with this prefix list")}).optional().describe("Information regarding the neighbors configured with this prefix list"),peerGroups:e.Ik({total:e.ai().int().optional().describe("Total number of peer groups configured with this prefix list")}).optional().describe("Information regarding the peer groups configured with this prefix list"),rules:e.Ik({total:e.ai().int().optional().describe("Total number of prefix list rules in this prefix list")}).optional().describe("Information regarding the prefix list rules")}).optional().describe("Counts related to the prefix list")}).optional()).optional().describe("The top-level property containing all prefix list overviews"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of prefix list overviews"),remaining:e.ai().int().optional().describe("The number of prefix list overviews remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Zs=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).describe("Information regarding the network the prefix list belongs to"),prefixList:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list"),name:e.Yj().optional().describe("The name of the prefix list (CLI: 'ip prefix-list <name>')"),description:e.Yj().optional().describe("The description of the prefix list (CLI: 'ip prefix-list MyPrefixList description <description>')")}).describe("Information regarding the prefix list"),rules:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list rule"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be processed (CLI: 'ip prefix-list NoPrivateNets seq <sequenceNumber>')"),policy:e.k5(["deny","permit"]).optional().describe("Option to 'permit' or 'deny' traffic that matches the defined condition for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny')"),conditions:e.Ik({cidr:e.Yj().optional().describe("The cidr address to match for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny <cidr>')"),prefixLength:e.Ik({minimum:e.ai().int().optional().describe("The minimum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length greater than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny ge <minimum>')"),maximum:e.ai().int().optional().describe("The maximum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length less than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny le <maximum>')")}).optional().describe("Optional prefix length range conditions for the rule")}).optional().describe("The conditions that define the rule behavior for matching traffic"),destroy:e.zM().optional().describe("Flag to indicate if the prefix list rule should be destroyed")}).optional()).describe("Information regarding the prefix list rules")})}),$s=e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the prefix list belongs to"),prefixList:e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list"),name:e.Yj().optional().describe("The name of the prefix list (CLI: 'ip prefix-list <name>')"),description:e.Yj().optional().describe("The description of the prefix list (CLI: 'ip prefix-list MyPrefixList description <description>')")}).optional().describe("Information regarding the prefix list"),rules:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the prefix list rule"),sequenceNumber:e.ai().int().optional().describe("The sequence number for the rule, defining the order in which rules will be processed (CLI: 'ip prefix-list NoPrivateNets seq <sequenceNumber>')"),policy:e.k5(["deny","permit"]).optional().describe("Option to 'permit' or 'deny' traffic that matches the defined condition for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny')"),conditions:e.Ik({cidr:e.Yj().optional().describe("The cidr address to match for the rule (CLI: 'ip prefix-list NoPrivateNets seq 5 deny <cidr>')"),prefixLength:e.Ik({minimum:e.ai().int().optional().describe("The minimum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length greater than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny ge <minimum>')"),maximum:e.ai().int().optional().describe("The maximum prefix length for the rule. If defined, the rule will only apply for networks with a prefix length less than or equal to this value. (CLI: 'ip prefix-list NoPrivateNets seq 5 deny le <maximum>')")}).optional().describe("Optional prefix length range conditions for the rule")}).optional().describe("The conditions that define the rule behavior for matching traffic")}).optional()).optional().describe("Information regarding the prefix list rules")}).optional(),ed=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),listId:e.Yj().describe("List ID")}),body:e.Ik({name:e.Yj().optional().describe("The name of the prefix list (CLI: 'ip prefix-list <name>')"),description:e.Yj().optional().describe("The description of the prefix list (CLI: 'ip prefix-list MyPrefixList description <description>')"),network:e.Ik({id:e.Yj().optional().describe("The network ID")}).optional().describe("Information regarding the network the prefix list belongs to")}).optional()}),td=e.Ik({listId:e.Yj().optional().describe("Object ID for the prefix list"),name:e.Yj().optional().describe("The name of the prefix list (CLI: 'ip prefix-list <name>')"),description:e.Yj().optional().describe("The description of the prefix list (CLI: 'ip prefix-list MyPrefixList description <description>')"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the prefix list belongs to")}).optional(),id=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),listId:e.Yj().describe("List ID")})}),od=e.Vx(),rd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),numbers:e.YO(e.ai().int().optional()).optional().optional().describe("Optional parameter to filter autonomous systems by number. This filter uses multiple exact matches."),autonomousSystemIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter autonomous systems by ID. This filter uses multiple exact matches.")})}),nd=e.Ik({items:e.YO(e.Ik({autonomousSystemId:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional()).optional().describe("The top-level propery containing all autonomous systems"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of autonomous systems"),remaining:e.ai().int().optional().describe("The number of autonomous systems remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),ad=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({number:e.ai().int().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().optional().describe("A description for the autonomous system")})}),sd=e.Ik({autonomousSystemId:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional(),dd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),numbers:e.YO(e.ai().int().optional()).optional().optional().describe("Optional parameter to filter autonomous systems by number. This filter uses multiple exact matches."),autonomousSystemIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter autonomous systems by ID. This filter uses multiple exact matches.")})}),ld=e.Ik({items:e.YO(e.Ik({autonomousSystemId:e.Yj().optional().describe("Object ID for the autonomous system"),counts:e.Ik({routers:e.Ik({total:e.ai().int().optional().describe("Total number of routers for this autonomous system")}).optional().describe("Information regarding the autonomous system's routers")}).optional().describe("Counts related to the autonomous system")}).optional()).optional().describe("The top-level property containing all autonomous system overviews"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of autonomous system overviews"),remaining:e.ai().int().optional().describe("The number of autonomous system overviews remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),cd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),autonomousSystemId:e.Yj().describe("Autonomous system ID")}),body:e.Ik({number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional()}),pd=e.Ik({autonomousSystemId:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional(),ud=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),autonomousSystemId:e.Yj().describe("Autonomous system ID")})}),hd=e.Vx(),bd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter listen ranges by network ID. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter listen ranges by router ID. This filter uses multiple exact matches."),peerGroupIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter listen ranges by peer group ID. This filter uses multiple exact matches."),listenRangeIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter listen ranges by ID. This filter uses multiple exact matches.")})}),fd=e.Ik({items:e.YO(e.Ik({listenRangeId:e.Yj().optional().describe("Object ID for the listen range"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router that peers with the range of IP addresses represented by this listen range"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'bgp listen range 10.10.248.0/24 peer-group <peer_group.name>')")}).optional().describe("Information regarding the peer group this listen range belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the listen range belongs to"),cidr:e.Yj().optional().describe("The range of IP addresses this listen range responds to (CLI: 'bgp listen range <cidr>')"),enabled:e.zM().optional().describe("A boolean value determining whether this listen range is enabled for BGP"),description:e.Yj().optional().describe("A description for the listen range")}).optional()).optional().describe("The top-level propery containing all listen ranges"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of listen ranges"),remaining:e.ai().int().optional().describe("The number of listen ranges remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),md=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).describe("Information regarding the router that peers with the range of IP addresses represented by this listen range"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group")}).describe("Information regarding the peer group this listen range belongs to"),cidr:e.Yj().describe("The range of IP addresses this listen range responds to (CLI: 'bgp listen range <cidr>')"),enabled:e.zM().optional().optional().describe("A boolean value determining whether this listen range is enabled for BGP"),description:e.Yj().optional().optional().describe("A description for the listen range")})}),gd=e.Ik({listenRangeId:e.Yj().optional().describe("Object ID for the listen range"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router that peers with the range of IP addresses represented by this listen range"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'bgp listen range 10.10.248.0/24 peer-group <peer_group.name>')")}).optional().describe("Information regarding the peer group this listen range belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the listen range belongs to"),cidr:e.Yj().optional().describe("The range of IP addresses this listen range responds to (CLI: 'bgp listen range <cidr>')"),enabled:e.zM().optional().describe("A boolean value determining whether this listen range is enabled for BGP"),description:e.Yj().optional().describe("A description for the listen range")}).optional(),Id=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),listenRangeId:e.Yj().describe("Listen range ID")}),body:e.Ik({router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router that peers with the range of IP addresses represented by this listen range"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group")}).optional().describe("Information regarding the peer group this listen range belongs to"),cidr:e.Yj().optional().describe("The range of IP addresses this listen range responds to (CLI: 'bgp listen range <cidr>')"),enabled:e.zM().optional().describe("A boolean value determining whether this listen range is enabled for BGP"),description:e.Yj().optional().describe("A description for the listen range")}).optional()}),vd=e.Ik({listenRangeId:e.Yj().optional().describe("Object ID for the listen range"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router that peers with the range of IP addresses represented by this listen range"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'bgp listen range 10.10.248.0/24 peer-group <peer_group.name>')")}).optional().describe("Information regarding the peer group this listen range belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the listen range belongs to"),cidr:e.Yj().optional().describe("The range of IP addresses this listen range responds to (CLI: 'bgp listen range <cidr>')"),enabled:e.zM().optional().describe("A boolean value determining whether this listen range is enabled for BGP"),description:e.Yj().optional().describe("A description for the listen range")}).optional(),yd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),listenRangeId:e.Yj().describe("Listen range ID")})}),kd=e.Vx(),wd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbors by network ID. This filter uses multiple exact matches."),peerGroupIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbors by peer group ID. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbors by router ID. This filter uses multiple exact matches."),neighborIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbors by ID. This filter uses multiple exact matches.")})}),jd=e.Ik({items:e.YO(e.Ik({neighborId:e.Yj().optional().describe("Object ID for the neighbor"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this neighbor peers with"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("The peer group name (CLI: 'neighbor 10.0.42.1 peer-group <peer_group.name>')")}).optional().describe("Information regarding the peer group this neighbor belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the neighbor belongs to"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the neighbor has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor 10.0.42.1 password <password>')")}).optional().describe("Options related to BGP neighbor authentication"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to activate the precautionary check as to whether the client is on a directly connected network. (Inverse of CLI: 'neighbor 10.0.42.1 disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the source loopback interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: 'neighbor 10.0.42.1 update-source Loopback<loopback_interface.name>')"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the source loopback interface")}).optional().describe("Options related to the loopback interface")}).optional().describe("Options related to BGP interfaces")}).optional()).optional().describe("The top-level propery containing all neighbors"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of neighbors"),remaining:e.ai().int().optional().describe("The number of neighbors remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Yd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).describe("Information regarding the router this neighbor peers with"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group")}).describe("Information regarding the peer group this neighbor belongs to"),description:e.Yj().optional().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to activate the precautionary check as to whether the client is on a directly connected network. (Inverse of CLI: 'neighbor 10.0.42.1 disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().optional().describe("Options related to eBGP configuration"),password:e.Yj().optional().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor 10.0.42.1 password <password>')"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the source loopback interface")}).optional().describe("Options related to the source loopback interface")}).optional().describe("Options related to the loopback interface")}).optional().optional().describe("Options related to BGP interfaces")})}),Td=e.Ik({neighborId:e.Yj().optional().describe("Object ID for the neighbor"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this neighbor peers with"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("The peer group name (CLI: 'neighbor 10.0.42.1 peer-group <peer_group.name>')")}).optional().describe("Information regarding the peer group this neighbor belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the neighbor belongs to"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the neighbor has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor 10.0.42.1 password <password>')")}).optional().describe("Options related to BGP neighbor authentication"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to activate the precautionary check as to whether the client is on a directly connected network. (Inverse of CLI: 'neighbor 10.0.42.1 disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the source loopback interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: 'neighbor 10.0.42.1 update-source Loopback<loopback_interface.name>')"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the source loopback interface")}).optional().describe("Options related to the loopback interface")}).optional().describe("Options related to BGP interfaces")}).optional(),Pd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 50. Default is 20."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbor deployments by network ID. This filter uses multiple exact matches."),peerGroupIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbor deployments by peer group ID. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbor deployments by router ID. This filter uses multiple exact matches."),neighborIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter neighbor deployments by neighbor ID. This filter uses multiple exact matches."),afi:e.k5(["ipv4"]).optional().optional().describe("Optional parameter to filter deployments on each neighbor by address family identifier (AFI)."),safi:e.k5(["unicast"]).optional().optional().describe("Optional parameter to filter deployments on each neighbor by subsequent address family identifier (SAFI).")})}),Od=e.Ik({items:e.YO(e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the neighbor belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("The peer group name (CLI: 'neighbor 10.0.42.1 peer-group <peer_group.name>')")}).optional().describe("Information regarding the peer group this neighbor belongs to"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this neighbor peers with"),neighbor:e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the neighbor has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor 10.0.42.1 password <password>')")}).optional().describe("Options related to BGP neighbor authentication"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to activate the precautionary check as to whether the client is on a directly connected network. (Inverse of CLI: 'neighbor 10.0.42.1 disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the source loopback interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: 'neighbor 10.0.42.1 update-source Loopback<loopback_interface.name>')"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the source loopback interface")}).optional().describe("Options related to the loopback interface")}).optional().describe("Options related to BGP interfaces")}).optional().describe("Information regarding the BPG neighbor"),deployments:e.YO(e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family"),description:e.Yj().optional().describe("Text description of the address family afi and safi (e.g. 'ipv4 unicast') (CLI: 'address-family <afi> <safi>')")}).optional().describe("Information regarding the address family this binding is bound to"),neighborAddressFamilyBinding:e.Ik({id:e.Yj().optional().describe("Object ID for the binding"),peering:e.Ik({enabled:e.zM().optional().describe("Whether peering is enabled for this address family and neighbor (CLI: 'neighbor 10.0.42.1 activate')")}).optional().describe("Options related to enabling peering for this address family and neighbor"),weight:e.ai().int().optional().describe("Set default weight for routes from this neighbor (CLI: 'neighbor 10.0.42.1 weight <weight>')"),advertisement:e.Ik({defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this neighbor (CLI: 'neighbor 10.0.42.1 default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor 10.0.42.1 soft-reconfiguration inbound)")}).optional().describe("Options related to soft reconfiguration")}).optional().describe("Information regarding the neighbor address family binding"),policies:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the policy"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),name:e.Yj().optional().describe("The name of the rule list For filter lists, this value corresponds to the list number (CLI: 'neighbor IBGP filter-list <name> in' or 'neighbor 10.10.248.254 prefix-list <name> in')"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")}).optional()).optional().describe("Information regarding the routing policies related to the neighbor")}).optional()).optional().describe("The list of currently configured address family deployments for this BGP neighbor")}).optional()).optional().describe("The top-level propery containing all neighbor deployments"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of neighbor deployments"),remaining:e.ai().int().optional().describe("The number of neighbor deployments remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Sd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family")}).describe("Information regarding the address family this binding is bound to"),neighbor:e.Ik({id:e.Yj().optional().describe("The neighbor object ID. Only required for updating a neighbor"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to activate the precautionary check as to whether the client is on a directly connected network. (Inverse of CLI: 'neighbor 10.0.42.1 disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor 10.0.42.1 password <password>')"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the source loopback interface")}).optional().describe("Options related to the source loopback interface")}).optional().describe("Options related to the loopback interface")}).optional().describe("Options related to BGP interfaces")}).describe("Information regarding the BPG neighbor"),neighborAddressFamilyBinding:e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor address family binding. Only required when updating a neighbor"),peering:e.Ik({enabled:e.zM().optional().describe("Whether peering is enabled for this address family and neighbor (CLI: 'neighbor 10.0.42.1 activate')")}).optional().describe("Options related to enabling peering for this address family and neighbor"),weight:e.ai().int().optional().describe("Set default weight for routes from this neighbor (CLI: 'neighbor 10.0.42.1 weight <weight>')"),advertisement:e.Ik({defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this neighbor (CLI: 'neighbor 10.0.42.1 default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),softReconfiguration:e.Ik({direction:e.k5(["inbound"]).optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor 10.0.42.1 soft-reconfiguration inbound)")}).optional().describe("Options related to soft reconfiguration")}).describe("Information regarding the neighbor address family binding"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group")}).describe("Information regarding the peer group this neighbor belongs to"),policies:e.YO(e.Ik({id:e.Yj().optional().describe("The policy object ID. Only required for updating or deleting a policy"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),destroy:e.zM().optional().describe("Flag to indicate if the policy should be destroyed")}).optional()).describe("Information regarding the routing policies related to the neighbor"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).describe("Information regarding the router this neighbor peers with")})}),Dd=e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family"),description:e.Yj().optional().describe("Text description of the address family afi and safi (e.g. 'ipv4 unicast') (CLI: 'address-family <afi> <safi>')")}).optional().describe("Information regarding the address family this binding is bound to"),neighbor:e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the neighbor has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor 10.0.42.1 password <password>')")}).optional().describe("Options related to BGP neighbor authentication"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to activate the precautionary check as to whether the client is on a directly connected network. (Inverse of CLI: 'neighbor 10.0.42.1 disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the source loopback interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: 'neighbor 10.0.42.1 update-source Loopback<loopback_interface.name>')"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the source loopback interface")}).optional().describe("Options related to the loopback interface")}).optional().describe("Options related to BGP interfaces")}).optional().describe("Information regarding the BPG neighbor"),neighborAddressFamilyBinding:e.Ik({id:e.Yj().optional().describe("Object ID for the binding"),peering:e.Ik({enabled:e.zM().optional().describe("Whether peering is enabled for this address family and neighbor (CLI: 'neighbor 10.0.42.1 activate')")}).optional().describe("Options related to enabling peering for this address family and neighbor"),weight:e.ai().int().optional().describe("Set default weight for routes from this neighbor (CLI: 'neighbor 10.0.42.1 weight <weight>')"),advertisement:e.Ik({defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this neighbor (CLI: 'neighbor 10.0.42.1 default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor 10.0.42.1 soft-reconfiguration inbound)")}).optional().describe("Options related to soft reconfiguration")}).optional().describe("Information regarding the neighbor address family binding"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the neighbor belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("The peer group name (CLI: 'neighbor 10.0.42.1 peer-group <peer_group.name>')")}).optional().describe("Information regarding the peer group this neighbor belongs to"),policies:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the policy"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),name:e.Yj().optional().describe("The name of the rule list For filter lists, this value corresponds to the list number (CLI: 'neighbor IBGP filter-list <name> in' or 'neighbor 10.10.248.254 prefix-list <name> in')"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")}).optional()).optional().describe("Information regarding the routing policies related to the neighbor"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this neighbor peers with")}).optional(),Rd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),neighborId:e.Yj().describe("Neighbor ID")}),body:e.Ik({router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this neighbor peers with"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group")}).optional().describe("Information regarding the peer group this neighbor belongs to"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to activate the precautionary check as to whether the client is on a directly connected network. (Inverse of CLI: 'neighbor 10.0.42.1 disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor 10.0.42.1 password <password>')"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the source loopback interface")}).optional().describe("Options related to the source loopback interface")}).optional().describe("Options related to the loopback interface")}).optional().describe("Options related to BGP interfaces")}).optional()}),zd=e.Ik({neighborId:e.Yj().optional().describe("Object ID for the neighbor"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this neighbor peers with"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("The peer group name (CLI: 'neighbor 10.0.42.1 peer-group <peer_group.name>')")}).optional().describe("Information regarding the peer group this neighbor belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the neighbor belongs to"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the neighbor has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor 10.0.42.1 password <password>')")}).optional().describe("Options related to BGP neighbor authentication"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to activate the precautionary check as to whether the client is on a directly connected network. (Inverse of CLI: 'neighbor 10.0.42.1 disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the source loopback interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: 'neighbor 10.0.42.1 update-source Loopback<loopback_interface.name>')"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the source loopback interface")}).optional().describe("Options related to the loopback interface")}).optional().describe("Options related to BGP interfaces")}).optional(),Ad=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),neighborId:e.Yj().describe("Neighbor ID")})}),xd=e.Vx(),Nd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group profiles by network ID. This filter uses multiple exact matches."),profileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group profiles by ID. This filter uses multiple exact matches.")})}),Cd=e.Ik({items:e.YO(e.Ik({profileId:e.Yj().optional().describe("Object ID for the peer group profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group profile belongs to"),name:e.Yj().optional().describe("The name for the peer group profile"),description:e.Yj().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the peer group profile has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)")}).optional().describe("Options related to BGP peer authentication"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().optional().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).optional().describe("Information regarding the remote eBGP autonomous system")}).optional().describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: neighbor IBGP update-source Loopback<name>)"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().describe("Options related to BGP interfaces")}).optional()).optional().describe("The top-level propery containing all peer group profiles"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of peer group profiles"),remaining:e.ai().int().optional().describe("The number of peer group profiles remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Ld=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).describe("Information regarding the network the peer group profile belongs to"),name:e.Yj().describe("The name for the peer group profile"),description:e.Yj().optional().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().optional().describe("Options related to eBGP configuration"),password:e.Yj().optional().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).describe("Information regarding the remote eBGP autonomous system")}).describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().optional().describe("Options related to BGP interfaces")})}),Md=e.Ik({profileId:e.Yj().optional().describe("Object ID for the peer group profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group profile belongs to"),name:e.Yj().optional().describe("The name for the peer group profile"),description:e.Yj().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the peer group profile has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)")}).optional().describe("Options related to BGP peer authentication"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().optional().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).optional().describe("Information regarding the remote eBGP autonomous system")}).optional().describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: neighbor IBGP update-source Loopback<name>)"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().describe("Options related to BGP interfaces")}).optional(),Fd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),peerGroupProfileId:e.Yj().describe("Peer group profile ID")}),body:e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID")}).optional().describe("Information regarding the network the peer group profile belongs to"),name:e.Yj().optional().describe("The name for the peer group profile"),description:e.Yj().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().optional().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).optional().describe("Information regarding the remote eBGP autonomous system")}).optional().describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().describe("Options related to BGP interfaces")}).optional()}),Gd=e.Ik({profileId:e.Yj().optional().describe("Object ID for the peer group profile"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group profile belongs to"),name:e.Yj().optional().describe("The name for the peer group profile"),description:e.Yj().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the peer group profile has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)")}).optional().describe("Options related to BGP peer authentication"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().optional().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).optional().describe("Information regarding the remote eBGP autonomous system")}).optional().describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: neighbor IBGP update-source Loopback<name>)"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().describe("Options related to BGP interfaces")}).optional(),Bd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),peerGroupProfileId:e.Yj().describe("Peer group profile ID")})}),qd=e.Vx(),Vd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer groups by network ID. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer groups by router ID. This filter uses multiple exact matches."),profileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer groups by profile ID. This filter uses multiple exact matches."),peerGroupIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer groups by ID. This filter uses multiple exact matches.")})}),Ed=e.Ik({items:e.YO(e.Ik({peerGroupId:e.Yj().optional().describe("Object ID for the peer group"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this peer group belongs to"),profile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile"),name:e.Yj().optional().describe("The name of the the peer group profile")}).optional().describe("Information regarding the profile this peer group belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group belongs to"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")}).optional()).optional().describe("The top-level propery containing all peer groups"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of peer groups"),remaining:e.ai().int().optional().describe("The number of peer groups remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),_d=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).describe("Information regarding the router this peer group belongs to"),profile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile")}).describe("Information regarding the profile this peer group belongs to"),name:e.Yj().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")})}),Ud=e.Ik({peerGroupId:e.Yj().optional().describe("Object ID for the peer group"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this peer group belongs to"),profile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile"),name:e.Yj().optional().describe("The name of the the peer group profile")}).optional().describe("Information regarding the profile this peer group belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group belongs to"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")}).optional(),Hd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 50. Default is 20."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group deployments by network ID. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group deployments by router ID. This filter uses multiple exact matches."),profileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group deployments by profile ID. This filter uses multiple exact matches."),peerGroupIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group deployments by peer group ID. This filter uses multiple exact matches."),afi:e.k5(["ipv4"]).optional().optional().describe("Optional parameter to filter deployments on each peer group by address family identifier (AFI)."),safi:e.k5(["unicast"]).optional().optional().describe("Optional parameter to filter deployments on each peer group by subsequent address family identifier (SAFI).")})}),Qd=e.Ik({items:e.YO(e.Ik({network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")}).optional().describe("Information regarding the peer group"),peerGroupProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile"),name:e.Yj().optional().describe("The name for the peer group profile"),description:e.Yj().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the peer group profile has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)")}).optional().describe("Options related to BGP peer authentication"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().optional().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).optional().describe("Information regarding the remote eBGP autonomous system")}).optional().describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: neighbor IBGP update-source Loopback<name>)"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().describe("Options related to BGP interfaces")}).optional().describe("Information regarding the peer group profile"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this peer group belongs to"),deployments:e.YO(e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID"),description:e.Yj().optional().describe("The address family afi and safi (i.e. 'ipv4 unicast') (CLI: 'address-family <description>')")}).optional().describe("Information regarding the address family the peer group address family binding belongs to"),peerGroupAddressFamilyBinding:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group address family binding")}).optional().describe("Information regarding the peer group address family binding. Only required when updating."),peerGroupAddressFamilyBindingProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group address family binding profile"),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().describe("Information regarding the community attribute for peer groups for a given address family"),name:e.Yj().optional().describe("The name of the peer group address family binding profile"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")}).optional().describe("Information regarding the peer group address family binding profile"),policies:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the policy"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),name:e.Yj().optional().describe("The name of the rule list For filter lists, this value corresponds to the list number (CLI: 'neighbor IBGP filter-list <name> in' or 'neighbor 10.10.248.254 prefix-list <name> in')"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")}).optional()).optional().describe("Information regarding the routing policies")}).optional()).optional().describe("The list of currently configured address family deployments for this BGP peer group")}).optional()).optional().describe("The top-level propery containing all peer group deployments"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of peer group deployments"),remaining:e.ai().int().optional().describe("The number of peer group deployments remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Wd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group overviews by network ID. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group overviews by router ID. This filter uses multiple exact matches."),profileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group overviews by profile ID. This filter uses multiple exact matches."),peerGroupIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group overviews by ID. This filter uses multiple exact matches.")})}),Kd=e.Ik({items:e.YO(e.Ik({peerGroupId:e.Yj().optional().describe("Object ID for the peer group"),counts:e.Ik({listenRanges:e.Ik({total:e.ai().int().optional().describe("Total number of listen ranges for this peer group")}).optional().describe("Information regarding the peer group's listen ranges"),neighbors:e.Ik({total:e.ai().int().optional().describe("Total number of neighbors for this peer group")}).optional().describe("Information regarding the peer group's neighbors")}).optional().describe("Counts related to the peer group")}).optional()).optional().describe("The top-level property containing all peer group overviews"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of peer group overviews"),remaining:e.ai().int().optional().describe("The number of peer group overviews remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Xd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family deployments by network ID. This filter uses multiple exact matches."),peerGroupIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family deployments by peer group"),addressFamilyIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter peer group address family deployments by address family")})}),Jd=e.Ik({items:e.YO(e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID"),description:e.Yj().optional().describe("The address family afi and safi (i.e. 'ipv4 unicast') (CLI: 'address-family <description>')")}).optional().describe("Information regarding the address family the peer group address family binding belongs to"),listenRanges:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the listen range"),cidr:e.Yj().optional().describe("The range of IP addresses this listen range responds to (CLI: 'bgp listen range <cidr>')"),enabled:e.zM().optional().describe("A boolean value determining whether this listen range is enabled for BGP"),description:e.Yj().optional().describe("A description for the listen range")}).optional()).optional().describe("Information regarding the listen ranges for the peer group"),neighbors:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),peering:e.Ik({enabled:e.zM().optional().describe("Flag to indicate if the neighbor should be activated")}).optional().describe("Information regarding the peering configuration for the neighbor")}).optional()).optional().describe("Information regarding the neighbors for the peer group and address family"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")}).optional().describe("Information regarding the peer group"),peerGroupAddressFamilyBinding:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group address family binding")}).optional().describe("Information regarding the peer group address family binding. Only required when updating."),peerGroupAddressFamilyBindingProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group address family binding profile"),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().describe("Information regarding the community attribute for peer groups for a given address family"),name:e.Yj().optional().describe("The name of the peer group address family binding profile"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")}).optional().describe("Information regarding the peer group address family binding profile"),peerGroupProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile"),name:e.Yj().optional().describe("The name for the peer group profile"),description:e.Yj().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the peer group profile has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)")}).optional().describe("Options related to BGP peer authentication"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().optional().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).optional().describe("Information regarding the remote eBGP autonomous system")}).optional().describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: neighbor IBGP update-source Loopback<name>)"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().describe("Options related to BGP interfaces")}).optional().describe("Information regarding the peer group profile"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this peer group belongs to")}).optional()).optional().describe("The top-level property containing all address family peer groups deployments"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of address family peer groups deployments"),remaining:e.ai().int().optional().describe("The number of address family peer groups deployments remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),Zd=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID")}).describe("Information regarding the address family the peer group address family binding belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID")}).describe("Information regarding the network the peer group profile belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group. Only required when updating."),name:e.Yj().optional().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")}).describe("Information regarding the peer group"),peerGroupAddressFamilyBinding:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group address family binding. Only required when updating.")}).optional().optional().describe("Information regarding the peer group address family binding. Only required when updating."),peerGroupAddressFamilyBindingProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group address family binding profile Only required when updating."),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().describe("Information regarding the community attribute for peer groups for a given address family"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.k5(["inbound"]).optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")}).describe("Information regarding the peer group address family binding profile"),peerGroupProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile. Only required when updating."),description:e.Yj().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().optional().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).optional().describe("Information regarding the remote eBGP autonomous system")}).optional().describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().describe("Options related to BGP interfaces")}).describe("Information regarding the peer group profile"),policies:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the filter policy. Only required when updating."),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),destroy:e.zM().optional().describe("Flag to indicate if the filter policy should be destroyed")}).optional()).describe("Information regarding the routing policies"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).describe("Information regarding the router this peer group belongs to")})}),$d=e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID"),description:e.Yj().optional().describe("The address family afi and safi (i.e. 'ipv4 unicast') (CLI: 'address-family <description>')")}).optional().describe("Information regarding the address family the peer group address family binding belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group belongs to"),peerGroup:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")}).optional().describe("Information regarding the peer group"),peerGroupAddressFamilyBinding:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group address family binding")}).optional().describe("Information regarding the peer group address family binding. Only required when updating."),peerGroupAddressFamilyBindingProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group address family binding profile"),advertisement:e.Ik({interval:e.ai().int().optional().describe("Minimal interval between sending BGP routing updates (CLI: 'neighbor IBGP advertisement-interval <interval>')"),defaultRoutes:e.Ik({enabled:e.zM().optional().describe("Whether default route advertisement is enabled for this peer group (CLI: 'neighbor IBGP default-originate')")}).optional().describe("Options related to default route advertisement")}).optional().describe("Options related to route advertisement"),communityAttribute:e.Ik({send:e.Ik({enabled:e.zM().optional().describe("Indication for send community attribute to this peer group (CLI: 'neighbor IBGP send-community')")}).optional().describe("Information regarding the send community attribute to this peer group")}).optional().describe("Information regarding the community attribute for peer groups for a given address family"),name:e.Yj().optional().describe("The name of the peer group address family binding profile"),nextHop:e.Ik({self:e.Ik({enabled:e.zM().optional().describe("Disables the next hop calculation for this peer group (CLI: 'neighbor IBGP next-hop-self')")}).optional().describe("Information regarding the next hop calculation for this neigbor"),unchanged:e.Ik({enabled:e.zM().optional().describe("Enable next-hop-self for both eBGP and iBGP received paths (CLI: 'neighbor IBGP next-hop-unchanged')")}).optional().describe("Information regarding propagating the iBGP paths' next hop unchanged for this peer group")}).optional().describe("Information regarding next hop for peer groups for a given address family"),removePrivateAs:e.Ik({enabled:e.zM().optional().describe("Removes private AS number from outbound updates (CLI: 'neighbor IBGP remove-private-as')")}).optional().describe("Information regarding removal of private AS number from outbound updates"),routeReflector:e.Ik({client:e.Ik({enabled:e.zM().optional().describe("Configures a peer group as Route Reflect client (CLI: 'neighbor IBGP route-reflector-client')")}).optional().describe("Information regarding route reflector clients")}).optional().describe("Information regarding route reflectors"),softReconfiguration:e.Ik({direction:e.Yj().optional().describe("The direction of soft reconfiguration being enabled (CLI: 'neighbor IBGP soft-reconfiguration <soft_reconfiguration>')")}).optional().describe("Options related to soft reconfiguration"),weight:e.ai().int().optional().describe("Set default weight for routes from this peer group (CLI: 'neighbor IBGP weight <weight>')")}).optional().describe("Information regarding the peer group address family binding profile"),peerGroupProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile"),name:e.Yj().optional().describe("The name for the peer group profile"),description:e.Yj().optional().describe("The description of the peer group profile (CLI: 'neighbor EBGP description <description>')"),ebgp:e.Ik({connectedCheck:e.Ik({enabled:e.zM().optional().describe("The option to enable the precautionary check as to whether the client is on a directly connected network  (CLI: 'neighbor IBGP disable-connected-check')")}).optional().describe("Options related to the precautionary check as to whether the client is on a directly connected network"),multihop:e.Ik({maximum:e.ai().int().optional().describe("An integer that configures a BGP device to establish an eBGP peer relationship with indirectly connected networks, setting a max-hop value between the two devices (CLI: 'neighbor IBGP ebgp-multihop <maximum>')")}).optional().describe("Options related to the time to live (TTL) value for the packets carrying BGP messages")}).optional().describe("Options related to eBGP configuration"),authentication:e.Ik({enabled:e.zM().optional().describe("Signifies if the peer group profile has a password configured"),password:e.Yj().optional().describe("BGP password used to authenticate BGP peers and prevent unauthorized access (CLI: 'neighbor IBGP password <password>)")}).optional().describe("Options related to BGP peer authentication"),timers:e.Ik({hold:e.ai().int().optional().describe("Option specifying the maximum time a router will wait for a message from its peer before considering the connection down (CLI: 'neighbor IBGP timers 60 <hold>')"),keepalive:e.ai().int().optional().describe("Option specifying the interval at which periodic keep-alive messages are sent to verify the peer is still reachable (CLI: 'neighbor IBGP timers <keepalive> 180')")}).optional().describe("Options related to timers used to maintain connectivity between BGP peers"),autonomousSystem:e.Ik({remote:e.Ik({number:e.ai().int().optional().describe("Specifies the remote autonomous system number (CLI: 'neighbor EBGP remote-as <number>')")}).optional().describe("Information regarding the remote eBGP autonomous system")}).optional().describe("Information regarding the autonomous system for the BGP neighbors in the peer group"),interfaces:e.Ik({loopback:e.Ik({source:e.Ik({id:e.Yj().optional().describe("The object ID for the loopback source interface"),name:e.Yj().optional().describe("The loopback interface descriptive number (CLI: neighbor IBGP update-source Loopback<name>)"),number:e.ai().int().optional().describe("The loopback interface number ")}).optional().describe("Options related to the BGP loopback source interface")}).optional().describe("Options related to BGP loopback interfaces")}).optional().describe("Options related to BGP interfaces")}).optional().describe("Information regarding the peer group profile"),policies:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the policy"),ruleList:e.Ik({type:e.k5(["Filter list","Prefix list"]).optional().describe("The type of filter list"),name:e.Yj().optional().describe("The name of the rule list For filter lists, this value corresponds to the list number (CLI: 'neighbor IBGP filter-list <name> in' or 'neighbor 10.10.248.254 prefix-list <name> in')"),id:e.Yj().optional().describe("The filter list object ID")}).optional().describe("Information regarding the list of filter rules that the policy uses"),direction:e.k5(["in","out"]).optional().describe("The direction of traffic the policy is applied to (CLI: 'neighbor IBGP filter-list 5 <direction>' or 'neighbor 10.10.248.254 prefix-list NoPrivateNets <direction>')")}).optional()).optional().describe("Information regarding the routing policies"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this peer group belongs to")}).optional(),el=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),peerGroupId:e.Yj().describe("Peer group ID")}),body:e.Ik({router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this peer group belongs to"),profile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile")}).optional().describe("Information regarding the profile this peer group belongs to"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")}).optional()}),tl=e.Ik({peerGroupId:e.Yj().optional().describe("Object ID for the peer group"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the router this peer group belongs to"),profile:e.Ik({id:e.Yj().optional().describe("Object ID for the peer group profile"),name:e.Yj().optional().describe("The name of the the peer group profile")}).optional().describe("Information regarding the profile this peer group belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the peer group belongs to"),name:e.Yj().optional().describe("Name of the peer group (CLI: 'neighbor <name> peer-group')")}).optional(),il=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),peerGroupId:e.Yj().describe("Peer group ID")})}),ol=e.Vx(),rl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routers by network ID. This filter uses multiple exact matches."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routers by serial. This filter uses multiple exact matches."),switchNames:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routers by switch name. The filter uses multiple exact matches."),asNumbers:e.YO(e.ai().int().optional()).optional().optional().describe("Optional parameter to filter routers by autonomous system number. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routers by ID. This filter uses multiple exact matches."),switchStackIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter routers by switch stack id. This filter uses multiple exact matches.")})}),nl=e.Ik({items:e.YO(e.Ik({routerId:e.Yj().optional().describe("Object ID for the router"),autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional().describe("Information regarding the router's autonomous system"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the router belongs to"),stack:e.Ik({id:e.Yj().optional().describe("The switch stack object ID"),name:e.Yj().optional().describe("The switch stack name"),members:e.YO(e.Yj().optional()).optional().describe("The switch stack member serials")}).optional().describe("Information regarding the switch stack the router belongs to, if applicable"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch"),name:e.Yj().optional().describe("The name of the router's switch"),model:e.Yj().optional().describe("The model of the router's switch")}).optional().describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node"),enabled:e.zM().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface"),name:e.Yj().optional().describe("The name of the router's loopback L3 interface (CLI: 'bgp router-id interface Loopback<name>')"),number:e.ai().int().optional().describe("The number of the router's loopback L3 interface ")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).optional().describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")}).optional()).optional().describe("The top-level propery containing all routers"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of routers"),remaining:e.ai().int().optional().describe("The number of routers remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),al=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the router's autonomous system")}).describe("Information regarding the router's autonomous system"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch")}).describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node"),enabled:e.zM().optional().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")})}),sl=e.Ik({routerId:e.Yj().optional().describe("Object ID for the router"),autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional().describe("Information regarding the router's autonomous system"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the router belongs to"),stack:e.Ik({id:e.Yj().optional().describe("The switch stack object ID"),name:e.Yj().optional().describe("The switch stack name"),members:e.YO(e.Yj().optional()).optional().describe("The switch stack member serials")}).optional().describe("Information regarding the switch stack the router belongs to, if applicable"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch"),name:e.Yj().optional().describe("The name of the router's switch"),model:e.Yj().optional().describe("The model of the router's switch")}).optional().describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node"),enabled:e.zM().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface"),name:e.Yj().optional().describe("The name of the router's loopback L3 interface (CLI: 'bgp router-id interface Loopback<name>')"),number:e.ai().int().optional().describe("The number of the router's loopback L3 interface ")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).optional().describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")}).optional(),dl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 50. Default is 20."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router deployments by network ID. This filter uses multiple exact matches."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router deployments by serial. This filter uses multiple exact matches."),switchNames:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router deployments by switch name. The filter uses multiple exact matches."),asNumbers:e.YO(e.ai().int().optional()).optional().optional().describe("Optional parameter to filter router deployments by autonomous system number. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router deployments by router ID. This filter uses multiple exact matches."),switchStackIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router deployments by switch stack id. This filter uses multiple exact matches."),afi:e.k5(["ipv4"]).optional().optional().describe("Optional parameter to filter deployments on each router by address family identifier (AFI)."),safi:e.k5(["unicast"]).optional().optional().describe("Optional parameter to filter deployments on each router by subsequent address family identifier (SAFI).")})}),ll=e.Ik({items:e.YO(e.Ik({autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional().describe("Information regarding the autonomous system the BGP router belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the router belongs to"),stack:e.Ik({id:e.Yj().optional().describe("The switch stack object ID"),name:e.Yj().optional().describe("The switch stack name"),members:e.YO(e.Yj().optional()).optional().describe("The switch stack member serials")}).optional().describe("Information regarding the switch stack the router belongs to, if applicable"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch"),name:e.Yj().optional().describe("The name of the router's switch"),model:e.Yj().optional().describe("The model of the router's switch")}).optional().describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router"),enabled:e.zM().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface"),name:e.Yj().optional().describe("The name of the router's loopback L3 interface (CLI: 'bgp router-id interface Loopback<name>')"),number:e.ai().int().optional().describe("The number of the router's loopback L3 interface ")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).optional().describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")}).optional().describe("Information regarding the BPG router"),deployments:e.YO(e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family"),afi:e.Yj().optional().describe("The address family identifier (AFI) denoting the network layer protocol of the address family (e.g. 'ipv4') (CLI: 'address-family <afi> unicast')"),safi:e.Yj().optional().describe("The subsequent address family identifier (SAFI) denoting the route type and usage of the address family (e.g. 'unicast') (CLI: 'address-family ipv4 <safi>')"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF instance")}).optional().describe("The Virtual Routing and Forwarding (VRF) options for the address family")}).optional().describe("Information regarding the address family"),addressFamilyPrefixes:e.YO(e.Ik({id:e.Yj().optional().describe("The ID of the address family's prefix"),prefix:e.Yj().optional().describe("The IP prefix in CIDR notation (CLI: network <ip-address>)"),enabled:e.zM().optional().describe("A boolean indicating whether the address family prefix is enabled"),description:e.Yj().optional().describe("A description of the address family prefix")}).optional()).optional().describe("The list of network prefixes to which the address family applies"),addressFamilyProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the address family profile"),name:e.Yj().optional().describe("The name describing the address family profile"),ebgp:e.Ik({paths:e.Ik({maximum:e.ai().int().optional().describe("An integer from 1 to 32, which determines how many paths can be installed in the routing table (CLI: 'maximum-paths <maximum>)'")}).optional().describe("Options related to the installation of paths in the routing table")}).optional().describe("Options related to eBGP configuration"),metrics:e.Ik({default:e.ai().int().optional().describe("An integer from 0 to 4,294,967,295, which indicates the IGP cost. A lower number indicates a preferred route. (CLI: 'default-metric <default>')")}).optional().describe("Options related to metrics for redistributing routes"),summarization:e.Ik({auto:e.Ik({enabled:e.zM().optional().describe("An option allowing BGP to automatically aggregate routes based on their network address (CLI: 'auto-summary')")}).optional().describe("Options related to the BGP auto summary feature")}).optional().describe("Options related to summarizing routing information in routing tables"),redistribution:e.Ik({static:e.Ik({enabled:e.zM().optional().describe("An option allowing static routes to be injected into the BGP routing table (CLI: 'redistribute static')")}).optional().describe("Options related to the BGP redistribute static feature"),connected:e.Ik({enabled:e.zM().optional().describe("An option allowing the router to inject locally connected network routes into the BGP routing table (CLI: 'redistribute connected')")}).optional().describe("Options related to the BGP redistribute connected feature")}).optional().describe("Options related to redistribution of routes from one routing domain into another routing domain")}).optional().describe("Information regarding the profile applied to the address family")}).optional()).optional().describe("The list of currently configured address family deployments for this BGP router")}).optional()).optional().describe("The top-level propery containing all router deployments"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of router deployments"),remaining:e.ai().int().optional().describe("The number of router deployments remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),cl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router overviews by network ID. This filter uses multiple exact matches."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router overviews by serial. This filter uses multiple exact matches."),switchNames:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router overviews by switch name. This filter uses multiple exact matches."),asNumbers:e.YO(e.ai().int().optional()).optional().optional().describe("Optional parameter to filter router overviews by autonomous system number. This filter uses multiple exact matches."),routerIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter router overviews by ID. This filter uses multiple exact matches.")})}),pl=e.Ik({items:e.YO(e.Ik({routerId:e.Yj().optional().describe("Object ID for the router"),counts:e.Ik({listenRanges:e.Ik({total:e.ai().int().optional().describe("Total number of listen ranges for this router")}).optional().describe("Information regarding the router's listen ranges"),neighbors:e.Ik({total:e.ai().int().optional().describe("Total number of neighbors for this router")}).optional().describe("Information regarding the router's neighbors"),routes:e.Ik({advertised:e.Ik({total:e.ai().int().optional().describe("Total number of advertised network routes")}).optional().describe("Advertised network routes")}).optional().describe("Information regarding the router's advertised network routes")}).optional().describe("Counts related to the router")}).optional()).optional().describe("The top-level property containing all router overviews"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of router overviews"),remaining:e.ai().int().optional().describe("The number of router overviews remaining based on current pagination location within the dataset")}).optional().describe("The count metadata")}).optional().describe("Count metadata related to this result set")}).optional().describe("Other metadata related to this result set")}).optional(),ul=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID. Only required when updating."),afi:e.k5(["ipv4"]).optional().describe("The address family identifier (AFI) denoting the network layer protocol of the address family (e.g. 'ipv4') (CLI: 'address-family <afi> unicast')"),safi:e.k5(["unicast"]).optional().describe("The subsequent address family identifier (SAFI) denoting the route type and usage of the address family (e.g. 'unicast') (CLI: 'address-family ipv4 <safi>')"),vrf:e.Ik({name:e.Yj().describe("The name of the VRF instance")}).describe("The Virtual Routing and Forwarding (VRF) options for the address family")}).describe("Information regarding the address family"),addressFamilyPrefixes:e.YO(e.Ik({id:e.Yj().optional().describe("The prefix object ID. Only required when updating."),prefix:e.Yj().optional().describe("The IP prefix in CIDR notation (CLI: network <ip-address>)"),enabled:e.zM().optional().describe("A boolean indicating whether the address family prefix is enabled"),description:e.Yj().optional().describe("A description of the address family prefix"),destroy:e.zM().optional().describe("Flag to indicate if the prefix should be destroyed")}).optional()).describe("The list of network prefixes to which the address family applies"),addressFamilyProfile:e.Ik({id:e.Yj().optional().describe("The address family profile object ID. Only required when updating."),ebgp:e.Ik({paths:e.Ik({maximum:e.ai().int().optional().describe("An integer from 1 to 32, which determines how many paths can be installed in the routing table (CLI: 'maximum-paths <maximum>)'")}).optional().describe("Options related to the installation of paths in the routing table")}).optional().describe("Options related to eBGP configuration"),metrics:e.Ik({default:e.ai().int().optional().describe("An integer from 0 to 4,294,967,295, which indicates the IGP cost. A lower number indicates a preferred route. (CLI: 'default-metric <default>')")}).optional().describe("Options related to metrics for redistributing routes"),summarization:e.Ik({auto:e.Ik({enabled:e.zM().optional().describe("An option allowing BGP to automatically aggregate routes based on their network address (CLI: 'auto-summary')")}).optional().describe("Options related to the BGP auto summary feature")}).optional().describe("Options related to summarizing routing information in routing tables"),redistribution:e.Ik({static:e.Ik({enabled:e.zM().optional().describe("An option allowing static routes to be injected into the BGP routing table (CLI: 'redistribute static')")}).optional().describe("Options related to the BGP redistribute static feature"),connected:e.Ik({enabled:e.zM().optional().describe("An option allowing the router to inject locally connected network routes into the BGP routing table (CLI: 'redistribute connected')")}).optional().describe("Options related to the BGP redistribute connected feature")}).optional().describe("Options related to redistribution of routes from one routing domain into another routing domain")}).describe("Information regarding the profile applied to the address family"),autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the router's autonomous system")}).describe("Information regarding the router's autonomous system"),router:e.Ik({id:e.Yj().optional().describe("The router object ID. Only required when updating."),enabled:e.zM().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).optional().describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")}).describe("Information regarding the BPG router"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch")}).describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node")})}),hl=e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("Object ID for the address family"),afi:e.Yj().optional().describe("The address family identifier (AFI) denoting the network layer protocol of the address family (e.g. 'ipv4') (CLI: 'address-family <afi> unicast')"),safi:e.Yj().optional().describe("The subsequent address family identifier (SAFI) denoting the route type and usage of the address family (e.g. 'unicast') (CLI: 'address-family ipv4 <safi>')"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF instance")}).optional().describe("The Virtual Routing and Forwarding (VRF) options for the address family")}).optional().describe("Information regarding the address family"),addressFamilyPrefixes:e.YO(e.Ik({id:e.Yj().optional().describe("The ID of the address family's prefix"),prefix:e.Yj().optional().describe("The IP prefix in CIDR notation (CLI: network <ip-address>)"),enabled:e.zM().optional().describe("A boolean indicating whether the address family prefix is enabled"),description:e.Yj().optional().describe("A description of the address family prefix")}).optional()).optional().describe("The list of network prefixes to which the address family applies"),addressFamilyProfile:e.Ik({id:e.Yj().optional().describe("Object ID for the address family profile"),name:e.Yj().optional().describe("The name describing the address family profile"),ebgp:e.Ik({paths:e.Ik({maximum:e.ai().int().optional().describe("An integer from 1 to 32, which determines how many paths can be installed in the routing table (CLI: 'maximum-paths <maximum>)'")}).optional().describe("Options related to the installation of paths in the routing table")}).optional().describe("Options related to eBGP configuration"),metrics:e.Ik({default:e.ai().int().optional().describe("An integer from 0 to 4,294,967,295, which indicates the IGP cost. A lower number indicates a preferred route. (CLI: 'default-metric <default>')")}).optional().describe("Options related to metrics for redistributing routes"),summarization:e.Ik({auto:e.Ik({enabled:e.zM().optional().describe("An option allowing BGP to automatically aggregate routes based on their network address (CLI: 'auto-summary')")}).optional().describe("Options related to the BGP auto summary feature")}).optional().describe("Options related to summarizing routing information in routing tables"),redistribution:e.Ik({static:e.Ik({enabled:e.zM().optional().describe("An option allowing static routes to be injected into the BGP routing table (CLI: 'redistribute static')")}).optional().describe("Options related to the BGP redistribute static feature"),connected:e.Ik({enabled:e.zM().optional().describe("An option allowing the router to inject locally connected network routes into the BGP routing table (CLI: 'redistribute connected')")}).optional().describe("Options related to the BGP redistribute connected feature")}).optional().describe("Options related to redistribution of routes from one routing domain into another routing domain")}).optional().describe("Information regarding the profile applied to the address family"),autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional().describe("Information regarding the autonomous system the BGP router belongs to"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the router belongs to"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router"),enabled:e.zM().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface"),name:e.Yj().optional().describe("The name of the router's loopback L3 interface (CLI: 'bgp router-id interface Loopback<name>')"),number:e.ai().int().optional().describe("The number of the router's loopback L3 interface ")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).optional().describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")}).optional().describe("Information regarding the BPG router"),stack:e.Ik({id:e.Yj().optional().describe("The switch stack object ID"),name:e.Yj().optional().describe("The switch stack name"),members:e.YO(e.Yj().optional()).optional().describe("The switch stack member serials")}).optional().describe("Information regarding the switch stack the router belongs to, if applicable"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch"),name:e.Yj().optional().describe("The name of the router's switch"),model:e.Yj().optional().describe("The model of the router's switch")}).optional().describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node")}).optional(),bl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID")}).describe("Information regarding the address family"),peerGroups:e.YO(e.Ik({id:e.Yj().describe("The peer group object ID"),destroy:e.zM().optional().optional().describe("Flag to indicate if the peer group should be destroyed"),listenRanges:e.YO(e.Ik({id:e.Yj().optional().describe("The listen range object ID. Required when updating or destroying."),cidr:e.Yj().optional().describe("The range of IP addresses this listen range responds to (CLI: 'bgp listen range <cidr>')"),enabled:e.zM().optional().describe("A boolean value determining whether this listen range is enabled for BGP"),description:e.Yj().optional().describe("A description for the listen range"),destroy:e.zM().optional().describe("Flag to indicate if the listen range should be destroyed")}).optional()).describe("Information regarding the listen ranges for the peer group"),neighbors:e.YO(e.Ik({id:e.Yj().optional().describe("The neighbor object ID. Required when updating or destroying."),peering:e.Ik({enabled:e.zM().optional().describe("Flag to indicate if the neighbor should be activated")}).optional().describe("Information regarding the peering configuration for the neighbor"),destroy:e.zM().optional().describe("Flag to indicate if the neighbor should be destroyed")}).optional()).describe("Information regarding the neighbors for the peer group and address family")})).describe("Information regarding the peer group peers for a router's peer group"),router:e.Ik({id:e.Yj().optional().describe("The router object ID")}).describe("Information regarding the BPG router")})}),fl=e.Ik({addressFamily:e.Ik({id:e.Yj().optional().describe("The address family object ID")}).optional().describe("Information regarding the address family"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the router belongs to"),peerGroups:e.YO(e.Ik({id:e.Yj().optional().describe("The peer group object ID"),listenRanges:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the listen range"),cidr:e.Yj().optional().describe("The range of IP addresses this listen range responds to (CLI: 'bgp listen range <cidr>')"),enabled:e.zM().optional().describe("A boolean value determining whether this listen range is enabled for BGP"),description:e.Yj().optional().describe("A description for the listen range")}).optional()).optional().describe("Information regarding the listen ranges for the peer group"),neighbors:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the neighbor"),description:e.Yj().optional().describe("Text description of the neighbor (CLI: 'neighbor 10.0.42.1 description <description>')"),address:e.Yj().optional().describe("The IP address of the neighbor (CLI: 'neighbor <address>')"),peering:e.Ik({enabled:e.zM().optional().describe("Flag to indicate if the neighbor should be activated")}).optional().describe("Information regarding the peering configuration for the neighbor")}).optional()).optional().describe("Information regarding the neighbors for the peer group and address family")}).optional()).optional().describe("Information regarding the peer group peers for a router's peer group"),router:e.Ik({id:e.Yj().optional().describe("Object ID for the router")}).optional().describe("Information regarding the BPG router")}).optional(),ml=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),routerId:e.Yj().describe("Router ID")}),body:e.Ik({autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the router's autonomous system")}).optional().describe("Information regarding the router's autonomous system"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch")}).optional().describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node"),enabled:e.zM().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).optional().describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")}).optional()}),gl=e.Ik({routerId:e.Yj().optional().describe("Object ID for the router"),autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional().describe("Information regarding the router's autonomous system"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the router belongs to"),stack:e.Ik({id:e.Yj().optional().describe("The switch stack object ID"),name:e.Yj().optional().describe("The switch stack name"),members:e.YO(e.Yj().optional()).optional().describe("The switch stack member serials")}).optional().describe("Information regarding the switch stack the router belongs to, if applicable"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch"),name:e.Yj().optional().describe("The name of the router's switch"),model:e.Yj().optional().describe("The model of the router's switch")}).optional().describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node"),enabled:e.zM().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface"),name:e.Yj().optional().describe("The name of the router's loopback L3 interface (CLI: 'bgp router-id interface Loopback<name>')"),number:e.ai().int().optional().describe("The number of the router's loopback L3 interface ")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).optional().describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")}).optional(),Il=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),routerId:e.Yj().describe("Router ID")})}),vl=e.Vx(),yl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({routers:e.YO(e.Ik({id:e.Yj().describe("The router object ID"),enabled:e.zM().describe("The router object enabled identifier"),destroy:e.zM().optional().optional().describe("Option to destroy a router")})).describe("Information regarding the routers for enablement")})}),kl=e.Ik({routers:e.YO(e.Ik({id:e.Yj().optional().describe("Object ID for the router"),autonomousSystem:e.Ik({id:e.Yj().optional().describe("Object ID for the autonomous system"),number:e.ai().int().optional().describe("The autonomous system number (CLI: 'router bgp <number>')"),description:e.Yj().optional().describe("A description for the autonomous system")}).optional().describe("Information regarding the router's autonomous system"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The network name")}).optional().describe("Information regarding the network the router belongs to"),stack:e.Ik({id:e.Yj().optional().describe("The switch stack object ID"),name:e.Yj().optional().describe("The switch stack name"),members:e.YO(e.Yj().optional()).optional().describe("The switch stack member serials")}).optional().describe("Information regarding the switch stack the router belongs to, if applicable"),switch:e.Ik({serial:e.Yj().optional().describe("Unique serial number for the router's switch"),name:e.Yj().optional().describe("The name of the router's switch"),model:e.Yj().optional().describe("The model of the router's switch")}).optional().describe("The router's switch node. When the router is part of a switch stack, this is the switch stack's active node"),enabled:e.zM().optional().describe("Whether the router is enabled"),bgpIdentifier:e.Ik({address:e.Yj().optional().describe("The router's IP address (CLI: 'bgp router-id <address>')"),interfaces:e.Ik({loopback:e.Ik({id:e.Yj().optional().describe("Object ID for the router's loopback L3 interface"),name:e.Yj().optional().describe("The name of the router's loopback L3 interface (CLI: 'bgp router-id interface Loopback<name>')"),number:e.ai().int().optional().describe("The number of the router's loopback L3 interface ")}).optional().describe("Information regarding the router's loopback L3 interface")}).optional().describe("Information regarding the router's interfaces, if used instead of a direct IP address")}).optional().describe("Information regarding the router's bgp identifier, either an IP address or loopback L3 interface. Exactly one of these fields must be be present")}).optional()).optional().describe("Information regarding the routers for enablement")}).optional(),wl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({vrfIds:e.YO(e.Yj().optional()).optional().optional().describe("IDs of the desired VRFs.")})}),bo=e.Ik({items:e.YO(e.Ik({vrfId:e.Yj().describe("The unique identifier of the VRF (Virtual Routing and Forwarding)"),autoRd:e.zM().optional().optional().describe("Whether the VRF is auto RD"),name:e.Yj().describe("The name of the VRF (Virtual Routing and Forwarding)"),description:e.Yj().optional().optional().describe("Description of the VRF (Virtual Routing and Forwarding)"),routeDistinguisher:e.Yj().describe("RD (Route Distinguisher) for the VRF (Virtual Routing and Forwarding)"),switchFabricId:e.Yj().optional().optional().describe("The ID of the switch fabric this VRF is associated with")})).optional().describe("List of VRFs (Virtual Routing and Forwarding)"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("Length of items array")}).optional().describe("Counts of items array")}).optional().describe("Counts of response arrays")}).optional().describe("Metadata related to the response.")}).optional(),jl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({name:e.Yj().describe("The name of the VRF (Virtual Routing and Forwarding)"),description:e.Yj().optional().optional().describe("Description of the VRF (Virtual Routing and Forwarding)"),routeDistinguisher:e.Yj().describe("RD (Route Distinguisher) for the VRF (Virtual Routing and Forwarding)"),dryrun:e.zM().optional().optional().describe("This parameter is used to validate the request without actually applying the changes.")})}),Yl=e.Ik({vrfId:e.Yj().describe("The unique identifier of the VRF (Virtual Routing and Forwarding)"),autoRd:e.zM().optional().optional().describe("Whether the VRF is auto RD"),name:e.Yj().describe("The name of the VRF (Virtual Routing and Forwarding)"),description:e.Yj().optional().optional().describe("Description of the VRF (Virtual Routing and Forwarding)"),routeDistinguisher:e.Yj().describe("RD (Route Distinguisher) for the VRF (Virtual Routing and Forwarding)"),switchFabricId:e.Yj().optional().optional().describe("The ID of the switch fabric this VRF is associated with")}),Tl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),vrfId:e.Yj().describe("Vrf ID")}),body:e.Ik({name:e.Yj().optional().describe("The name of the VRF (Virtual Routing and Forwarding)"),description:e.Yj().optional().describe("Description of the VRF (Virtual Routing and Forwarding)"),routeDistinguisher:e.Yj().optional().describe("RD (Route Distinguisher) for the VRF (Virtual Routing and Forwarding)"),dryrun:e.zM().optional().describe("This parameter is used to validate the request without actually applying the changes.")}).optional()}),Pl=e.Ik({vrfId:e.Yj().describe("The unique identifier of the VRF (Virtual Routing and Forwarding)"),autoRd:e.zM().optional().optional().describe("Whether the VRF is auto RD"),name:e.Yj().describe("The name of the VRF (Virtual Routing and Forwarding)"),description:e.Yj().optional().optional().describe("Description of the VRF (Virtual Routing and Forwarding)"),routeDistinguisher:e.Yj().describe("RD (Route Distinguisher) for the VRF (Virtual Routing and Forwarding)"),switchFabricId:e.Yj().optional().optional().describe("The ID of the switch fabric this VRF is associated with")}),Ol=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),vrfId:e.Yj().describe("Vrf ID")})}),Sl=e.Vx(),Dl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter device by network ID. This filter uses multiple exact matches.")})}),Rl=e.Ik({items:e.YO(e.Ik({devices:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial of the switch"),name:e.Yj().optional().describe("Name of the switch"),mac:e.Yj().optional().describe("MAC address of the switch")}).optional()).optional().describe("List of paired switches"),network:e.Ik({id:e.Yj().optional().describe("Network ID")}).optional().describe("Network information")}).optional()).optional().describe("List of unprovisioned switch stacks"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("Total")}).optional().describe("Items")}).optional().describe("Counts")}).optional().describe("Metadata relevant to the paginated dataset")}).optional(),zl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter device by network ID. This filter uses multiple exact matches.")})}),fo=e.YO(e.Ik({id:e.Yj().optional().describe("ID of the SVL Workflow"),switchStackId:e.Yj().optional().describe("ID of the Switch stack"),name:e.Yj().optional().describe("Name of the Switch stack"),mac:e.Yj().optional().describe("MAC address of the Switch stack"),members:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the device"),name:e.Yj().optional().describe("Name of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),role:e.k5(["active","member","standby"]).optional().describe("Role of the device"),links:e.Ik({ports:e.YO(e.Yj().optional()).optional().describe("StackWise Virtual Link Port Names"),dualActiveDetection:e.YO(e.Yj().optional()).optional().describe("Dual Active Detection Link Port Names")}).optional().describe("Links for StackWise Virtual")}).optional()).optional().describe("Members of the Stack"),status:e.k5(["applySVLConfiguration","canceled","complete","failed","reload","stuck","unreachable"]).optional().describe("Current stage of SVL Stack"),hasFailed:e.zM().optional().describe("Whether or not stack creation failed to complete successfully"),steps:e.YO(e.Ik({stepName:e.Yj().optional().describe("Name of the performed step"),startedAt:e.Yj().optional().describe("When the step finished"),completedAt:e.Yj().optional().describe("When the step finished"),status:e.k5(["complete","failed","running"]).optional().describe("The step's status")}).optional()).optional().describe("The steps that have run")}).optional()).optional(),Al=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({mode:e.k5(["loopback","routed","vlan"]).optional().optional().describe("Optional parameter to filter L3 interfaces by mode."),protocol:e.k5(["ipv4","ipv6"]).optional().optional().describe("Optional parameter to filter L3 interfaces by protocol."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter the result set by the included set of network IDs"),perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 20."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")})}),mo=e.Ik({items:e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway"),dhcp:e.Ik({mode:e.k5(["off","relay","server"]).optional().describe("The DHCP mode for the interface")}).optional().describe("DHCP settings"),networkId:e.Yj().optional().describe("Network ID"),switchStackId:e.Yj().optional().describe("Switch stack ID")})).optional().describe("The top-level property containing the interfaces data."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items (interfaces) in the dataset"),remaining:e.ai().int().optional().describe("The number of items (interfaces) in the dataset available on subsequent pages.")}).optional().describe("Counts relating to the items.")}).optional().describe("Counts relating to the dataset.")}).optional().describe("Metadata relating to the dataset."),errors:e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The interface ID that caused the error."),message:e.Yj().optional().describe("The error message.")}).optional()).optional().describe("Errors encountered while processing the request.")}).optional(),xl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({interfaceIds:e.YO(e.Yj().optional()).describe("List of interface IDs to update"),changes:e.Ik({vlanId:e.ai().int().optional().describe("The VLAN this routed interface is on. VLAN must be between 1 and 4094."),multicastRouting:e.Yj().optional().describe("Enables or disables multicast support if multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'.         Default is 'disabled'."),ospf:e.Ik({v2:e.Ik({area:e.Yj().optional().describe("The OSPF area to which this interface should belong. Set to the identifier of an existing OSPF             area or use 'disabled' to remove the OSPF V2 setting."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower             priority."),passive:e.zM().optional().describe("When true, OSPF will not run on the interface, but the subnet will still be advertised.")}).optional().describe("V2 OSPF settings for use with IPv4"),v3:e.Ik({area:e.Yj().optional().describe("The OSPF area to which this interface should belong. Set to the identifier of an existing OSPF area             or use 'disabled' to remove the OSPF V3 setting."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower             priority."),passive:e.zM().optional().describe("When true, OSPF will not run on the interface, but the subnet will still be advertised.")}).optional().describe("V3 OSPF settings for use with IPv6.")}).optional().describe("OSPF settings")}).describe("Hash of changes to be applied to each interface.")})}),Nl=e.Ik({items:e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway"),dhcp:e.Ik({mode:e.k5(["off","relay","server"]).optional().describe("The DHCP mode for the interface")}).optional().describe("DHCP settings"),networkId:e.Yj().optional().describe("Network ID"),switchStackId:e.Yj().optional().describe("Switch stack ID"),updated:e.zM().optional().describe("The update status of the interface")}).optional()).optional().describe("The top-level property containing the interfaces data."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items (interfaces) in the dataset"),remaining:e.ai().int().optional().describe("The number of items (interfaces) in the dataset available on subsequent pages.")}).optional().describe("Counts relating to the items.")}).optional().describe("Counts relating to the dataset.")}).optional().describe("Metadata relating to the dataset."),errors:e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The interface ID that caused the error."),message:e.Yj().optional().describe("The error message.")}).optional()).optional().describe("Errors encountered while processing the request.")}).optional(),Cl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({interfaceIds:e.YO(e.Yj().optional()).describe("Ids of the static routes to be deleted")})}),go=e.Ik({items:e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway"),dhcp:e.Ik({mode:e.k5(["off","relay","server"]).optional().describe("The DHCP mode for the interface")}).optional().describe("DHCP settings"),networkId:e.Yj().optional().describe("Network ID"),switchStackId:e.Yj().optional().describe("Switch stack ID"),deleted:e.zM().optional().describe("The delete status of the interface")}).optional()).optional().describe("The top-level property containing the interfaces data."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items (interfaces) in the dataset"),remaining:e.ai().int().optional().describe("The number of items (interfaces) in the dataset available on subsequent pages.")}).optional().describe("Counts relating to the items.")}).optional().describe("Counts relating to the dataset.")}).optional().describe("Metadata relating to the dataset."),errors:e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The interface ID that caused the error."),message:e.Yj().optional().describe("The error message.")}).optional()).optional().describe("Errors encountered while processing the request.")}).optional(),Ll=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 10 - 1000. Default is 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),fabricId:e.Yj().optional().optional().describe("Fabric ID to filter the switch fabric devices by"),configurationUpdatedAfter:e.Yj().optional().optional().describe("Optional parameter to filter items to switches where the configuration has been updated after the given timestamp."),mac:e.Yj().optional().optional().describe("Optional parameter to filter items to switches with MAC addresses that contain the search term or are an exact match."),macs:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter items to switches that have one of the provided MAC addresses."),name:e.Yj().optional().optional().describe("Optional parameter to filter items to switches with names that contain the search term or are an exact match."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter items to switches in one of the provided networks."),portProfileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter items to switches that contain switchports belonging to one of the specified port profiles."),serial:e.Yj().optional().optional().describe("Optional parameter to filter items to switches with serial number that contains the search term or are an exact match."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter items to switches that have one of the provided serials.")})}),Ml=e.Ik({items:e.YO(e.Ik({name:e.Yj().optional().describe("The name of the switch."),serial:e.Yj().optional().describe("The serial number of the switch."),mac:e.Yj().optional().describe("The MAC address of the switch."),network:e.Ik({name:e.Yj().optional().describe("The name of the network."),id:e.Yj().optional().describe("The ID of the network.")}).optional().describe("Identifying information of the switch's network."),model:e.Yj().optional().describe("The model of the switch."),switchFabricRoles:e.YO(e.Yj().optional()).optional().describe("The roles of the switch in the fabric"),fabricId:e.Yj().optional().describe("The ID of the fabric the switch belongs to"),online:e.zM().optional().describe("True if the switch is online, false if it is offline"),lanIp:e.Yj().optional().describe("The LAN IP address of the switch"),loopbackIp:e.Yj().optional().describe("The loopback IP address of the switch from loopback interface 100 with infra_loopback usage"),tags:e.YO(e.Yj().optional()).optional().describe("The tags associated with the switch"),stackId:e.Yj().optional().describe("The ID of the stack"),members:e.YO(e.Ik({name:e.Yj().optional().describe("The name of the switch."),serial:e.Yj().optional().describe("The serial number of the switch."),mac:e.Yj().optional().describe("The MAC address of the switch."),network:e.Ik({name:e.Yj().optional().describe("The name of the network."),id:e.Yj().optional().describe("The ID of the network.")}).optional().describe("Identifying information of the switch's network."),model:e.Yj().optional().describe("The model of the switch.")}).optional()).optional().describe("The members of the stack"),deviceType:e.Yj().optional().describe("The type of device (switch or stack)")}).optional()).optional().describe("Switches"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items in the dataset"),remaining:e.ai().int().optional().describe("The number of items in the dataset that are available on subsequent pages")}).optional().describe("Counts relating to the paginated items")}).optional().describe("Counts relating to the paginated dataset")}).optional().describe("Metadata relevant to the paginated dataset")}).optional(),Fl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({items:e.YO(e.Ik({serial:e.Yj().optional().optional().describe("Serial number of the switch"),stackId:e.Yj().optional().optional().describe("ID of the stack"),switchFabricRoles:e.YO(e.Yj().optional()).describe("The roles of the switch in the fabric")})).describe("The list of switch fabric devices to update")})}),Gl=e.Ik({items:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the switch"),stackId:e.Yj().optional().describe("ID of the stack"),switchFabricRoles:e.YO(e.Yj().optional()).optional().describe("The roles of the switch in the fabric")}).optional()).optional().describe("The list of switch fabric devices that were updated"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items updated")}).optional().describe("Counts relating to the updated items")}).optional().describe("Counts relating to the updated items")}).optional().describe("Metadata relevant to the updated items")}).optional(),Bl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({fabricId:e.Yj().describe("Fabric ID to filter the switch fabric devices by")})}),ql=e.Ik({nodes:e.YO(e.Ik({derivedId:e.Yj().optional().describe("Derived ID of the switch"),name:e.Yj().optional().describe("Name of the switch"),serial:e.Yj().optional().describe("Serial number of the switch"),mac:e.Yj().optional().describe("MAC address of the switch"),network:e.Ik({id:e.Yj().optional().describe("Network ID"),name:e.Yj().optional().describe("Network name")}).optional().describe("Network details of the switch"),fabric:e.Ik({parent:e.Ik({id:e.Yj().optional().describe("Fabric parent ID")}).optional().describe("Parent fabric details"),roles:e.YO(e.Yj().optional()).optional().describe("Roles of the switch in the fabric")}).optional().describe("Fabric details of the switch")}).optional()).optional().describe("The list of switches in the topology"),links:e.YO(e.Ik({linkId:e.Yj().optional().describe("Link ID"),sourceNode:e.Ik({derivedId:e.Yj().optional().describe("Derived ID of the source node"),serial:e.Yj().optional().describe("Serial number of the source node"),switchPort:e.Ik({id:e.Yj().optional().describe("Source switch port ID"),name:e.Yj().optional().describe("Source switch port name")}).optional().describe("Source switch port details")}).optional().describe("Source node details"),targetNode:e.Ik({derivedId:e.Yj().optional().describe("Derived ID of the target node"),serial:e.Yj().optional().describe("Serial number of the target node"),switchPort:e.Ik({id:e.Yj().optional().describe("Target switch port ID"),name:e.Yj().optional().describe("Target switch port name")}).optional().describe("Target switch port details")}).optional().describe("Target node details")}).optional()).optional().describe("The connections between switches in the topology")}).optional(),Vl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")})}),El=e.YO(e.Ik({id:e.Yj().optional().describe("The ID of the fabric."),name:e.Yj().optional().describe("Name of the fabric entity."),bgpAsn:e.Yj().optional().describe("BGP ASN for the fabric entity."),underlayLoopbackIpPool:e.Yj().optional().describe("Underlay Loopback Ip Pool for the fabric nodes."),underlayIpPool:e.Yj().optional().describe("Underlay Ip Pool for the fabric nodes."),skipUnderlayGeneration:e.zM().optional().describe("Whether to skip underlay generation for the fabric."),status:e.k5(["deployed","staged"]).optional().describe('Status of the fabric entity. Must be one of: ["staged", "deployed"]'),devices:e.YO(e.Yj().optional()).optional().describe("List of devices in the fabric."),stacks:e.YO(e.ai().int().optional()).optional().describe("List of stacks in the fabric."),createdAt:e.Yj().optional().describe("Creation timestamp of the fabric entity."),updatedAt:e.Yj().optional().describe("Last updated timestamp of the fabric entity.")}).optional()).optional(),_l=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({name:e.Yj().describe("Name of the fabric entity."),bgpAsn:e.Yj().describe("BGP ASN for the fabric entity."),underlayLoopbackIpPool:e.Yj().describe("Underlay Loopback Ip Pool for the fabric nodes."),underlayIpPool:e.Yj().optional().optional().describe("Underlay IP Pool for the fabric nodes. Accepts IPv4 subnets."),status:e.Yj().describe("Status of the fabric entity."),config:e.Yj().describe("Configuration for the fabric entity."),skipUnderlayGeneration:e.zM().optional().optional().describe("Skip underlay configuration generation during fabric creation. Defaults to false.")})}),Ul=e.Ik({id:e.Yj().optional().describe("The ID of the fabric."),name:e.Yj().optional().describe("Name of the fabric entity."),bgpAsn:e.Yj().optional().describe("BGP ASN for the fabric entity."),underlayLoopbackIpPool:e.Yj().optional().describe("Underlay Loopback Ip Pool for the fabric nodes."),underlayIpPool:e.Yj().optional().describe("Underlay Ip Pool for the fabric nodes."),skipUnderlayGeneration:e.zM().optional().describe("Whether to skip underlay generation for the fabric."),status:e.k5(["deployed","staged"]).optional().describe('Status of the fabric entity. Must be one of: ["staged", "deployed"]'),devices:e.YO(e.Yj().optional()).optional().describe("List of devices in the fabric."),stacks:e.YO(e.ai().int().optional()).optional().describe("List of stacks in the fabric."),config:e.Yj().optional().describe("Configuration for the fabric entity. It represents either the deployed configuration or the staged configuration."),createdAt:e.Yj().optional().describe("Creation timestamp of the fabric entity."),updatedAt:e.Yj().optional().describe("Last updated timestamp of the fabric entity.")}).optional(),Hl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),fabricId:e.Yj().describe("Fabric ID")})}),Ql=e.Ik({id:e.Yj().optional().describe("The ID of the fabric."),name:e.Yj().optional().describe("Name of the fabric entity."),bgpAsn:e.Yj().optional().describe("BGP ASN for the fabric entity."),underlayLoopbackIpPool:e.Yj().optional().describe("Underlay Loopback Ip Pool for the fabric nodes."),underlayIpPool:e.Yj().optional().describe("Underlay Ip Pool for the fabric nodes."),skipUnderlayGeneration:e.zM().optional().describe("Whether to skip underlay generation for the fabric."),status:e.k5(["deployed","staged"]).optional().describe('Status of the fabric entity. Must be one of: ["staged", "deployed"]'),devices:e.YO(e.Yj().optional()).optional().describe("List of devices in the fabric."),stacks:e.YO(e.ai().int().optional()).optional().describe("List of stacks in the fabric."),config:e.Yj().optional().describe("Configuration for the fabric entity. It represents either the deployed configuration or the staged configuration."),createdAt:e.Yj().optional().describe("Creation timestamp of the fabric entity."),updatedAt:e.Yj().optional().describe("Last updated timestamp of the fabric entity.")}).optional(),Wl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),fabricId:e.Yj().describe("Fabric ID")}),body:e.Ik({name:e.Yj().optional().describe("Name of the fabric entity."),bgpAsn:e.Yj().optional().describe("BGP ASN for the fabric entity."),underlayLoopbackIpPool:e.Yj().optional().describe("Underlay Loopback Ip Pool for the fabric nodes."),underlayIpPool:e.Yj().optional().describe("Underlay IP Pool for the fabric nodes. Accepts IPv4 subnets."),status:e.Yj().optional().describe("Status of the fabric entity."),config:e.Yj().optional().describe("Configuration for the fabric entity."),skipUnderlayGeneration:e.zM().optional().describe("Skip underlay configuration generation during fabric updates. Defaults to false.")}).optional()}),Kl=e.Ik({id:e.Yj().optional().describe("The ID of the fabric."),name:e.Yj().optional().describe("Name of the fabric entity."),bgpAsn:e.Yj().optional().describe("BGP ASN for the fabric entity."),underlayLoopbackIpPool:e.Yj().optional().describe("Underlay Loopback Ip Pool for the fabric nodes."),underlayIpPool:e.Yj().optional().describe("Underlay Ip Pool for the fabric nodes."),skipUnderlayGeneration:e.zM().optional().describe("Whether to skip underlay generation for the fabric."),status:e.k5(["deployed","staged"]).optional().describe('Status of the fabric entity. Must be one of: ["staged", "deployed"]'),devices:e.YO(e.Yj().optional()).optional().describe("List of devices in the fabric."),stacks:e.YO(e.ai().int().optional()).optional().describe("List of stacks in the fabric."),config:e.Yj().optional().describe("Configuration for the fabric entity. It represents either the deployed configuration or the staged configuration."),createdAt:e.Yj().optional().describe("Creation timestamp of the fabric entity."),updatedAt:e.Yj().optional().describe("Last updated timestamp of the fabric entity.")}).optional(),Xl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),fabricId:e.Yj().describe("Fabric ID")})}),Jl=e.Vx(),Zl=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),fabricId:e.Yj().describe("Fabric ID")}),body:e.Ik({useNewEngine:e.zM().optional().describe("Use the new deployment engine. Defaults to true.")}).optional()}),$l=e.Vx(),ec=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),fabricId:e.Yj().describe("Fabric ID")})}),tc=e.Ik({id:e.Yj().optional().describe("The ID of the fabric."),name:e.Yj().optional().describe("Name of the fabric entity."),vrfCount:e.Ik({deployed:e.ai().int().optional().describe("Number of deployed VRFs"),staged:e.ai().int().optional().describe("Number of staged VRFs")}).optional().describe("Count of VRFs in the fabric"),fabricSubnetCount:e.Ik({deployed:e.ai().int().optional().describe("Number of deployed SVI subnets"),staged:e.ai().int().optional().describe("Number of staged SVI subnets")}).optional().describe("Count of SVI subnets in the fabric"),underlaySubnetCount:e.Ik({deployed:e.ai().int().optional().describe("Number of deployed underlay subnets")}).optional().describe("Count of underlay subnets in the fabric"),borderConfiguration:e.Ik({deployed:e.ai().int().optional().describe("Number of deployed OSPF configurations"),staged:e.ai().int().optional().describe("Number of staged OSPF configurations")}).optional().describe("Border configuration details")}).optional(),ic=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID"),fabricId:e.Yj().describe("Fabric ID")})}),oc=e.Ik({id:e.Yj().optional().describe("The ID of the fabric."),name:e.Yj().optional().describe("Name of the fabric."),capacity:e.Ik({macRoutes:e.ai().int().optional().describe("Number of MAC routes"),ipRoutes:e.ai().int().optional().describe("Number of IP routes")}).optional().describe("Capacity statistics"),bgpPeers:e.Ik({online:e.ai().int().optional().describe("Number of online BGP peers"),offline:e.ai().int().optional().describe("Number of offline BGP peers")}).optional().describe("BGP peer statistics"),extBorderPeers:e.Ik({online:e.ai().int().optional().describe("Number of online external border peers"),offline:e.ai().int().optional().describe("Number of offline external border peers")}).optional().describe("External border peer statistics"),vxlanTunnels:e.Ik({online:e.ai().int().optional().describe("Number of online VXLAN tunnels"),offline:e.ai().int().optional().describe("Number of offline VXLAN tunnels")}).optional().describe("VXLAN tunnel statistics"),overlaySubnets:e.Ik({online:e.ai().int().optional().describe("Number of online overlay subnets"),offline:e.ai().int().optional().describe("Number of offline overlay subnets")}).optional().describe("Overlay subnet statistics")}).optional(),rc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),fabricId:e.Yj().describe("Fabric ID to filter the neighbor statistics by"),nodeType:e.Yj().optional().optional().describe("Filter neighbor statistics by node type. 'ibgp' filters for L2VPN address family, 'ebgp' filters for IPv4/IPv6 unicast address families. Valid values: ibgp, ebgp")})}),nc=e.Ik({items:e.YO(e.Ik({id:e.Yj().optional().describe("The ID of the BGP neighbor stat."),serial:e.Yj().optional().describe("The serial number of the node."),name:e.Yj().optional().describe("The name of the node"),switchFabricId:e.Yj().optional().describe("The ID of the switch fabric."),remoteIp:e.Yj().optional().describe("Remote IP address of the BGP neighbor."),remoteAsn:e.Yj().optional().describe("Remote ASN of the BGP neighbor."),addressFamilyType:e.Yj().optional().describe("Address family type."),niName:e.Yj().optional().describe("Network instance name for the BGP neighbor."),connection:e.Ik({}).optional().describe("Connection information for the BGP neighbor."),state:e.Yj().optional().describe("Connection state of the BGP neighbor."),mode:e.Yj().optional().describe("Connection mode of the BGP neighbor."),upTime:e.Yj().optional().describe("Uptime of the BGP neighbor."),rcvKeepAlives:e.ai().int().optional().describe("Number of received keep-alive messages."),rcvNotifs:e.ai().int().optional().describe("Number of received notification messages."),rcvOpens:e.ai().int().optional().describe("Number of received open messages."),rcvRouteRefreshes:e.ai().int().optional().describe("Number of received route refresh messages."),rcvUpdates:e.ai().int().optional().describe("Number of received update messages."),sentKeepAlives:e.ai().int().optional().describe("Number of sent keep-alive messages."),sentNotifs:e.ai().int().optional().describe("Number of sent notification messages."),sentOpens:e.ai().int().optional().describe("Number of sent open messages."),sentRouteRefreshes:e.ai().int().optional().describe("Number of sent route refresh messages."),sentUpdates:e.ai().int().optional().describe("Number of sent update messages.")}).optional()).optional().describe("List of neighbor statistics"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items in the dataset"),remaining:e.ai().int().optional().describe("The number of items in the dataset that are available on subsequent pages")}).optional().describe("Counts relating to the paginated items")}).optional().describe("Counts relating to the paginated dataset")}).optional().describe("Metadata relevant to the paginated dataset")}).optional(),ac=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),fabricId:e.Yj().describe("Fabric ID to filter the NVE statistics by")})}),sc=e.Ik({items:e.YO(e.Ik({id:e.Yj().optional().describe("The ID of the NVE stat."),serial:e.Yj().optional().describe("The serial number of the node."),name:e.Yj().optional().describe("The name of the node."),switchFabricId:e.Yj().optional().describe("The ID of the switch fabric."),nveVniVrf:e.Yj().optional().describe("NVE VNI VRF name."),peerIpAddress:e.Yj().optional().describe("Peer IP address."),peerState:e.Yj().optional().describe("Peer state."),peerUpTime:e.Yj().optional().describe("Peer uptime."),rcvPkts:e.ai().int().optional().describe("Number of received packets."),sentPkts:e.ai().int().optional().describe("Number of sent packets."),vniCategory:e.Yj().optional().describe("VNI category."),vlanId:e.Yj().optional().describe("VLAN ID."),vniId:e.Yj().optional().describe("VNI ID.")}).optional()).optional().describe("List of NVE statistics"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items in the dataset"),remaining:e.ai().int().optional().describe("The number of items in the dataset that are available on subsequent pages")}).optional().describe("Counts relating to the paginated items")}).optional().describe("Counts relating to the paginated dataset")}).optional().describe("Metadata relevant to the paginated dataset")}).optional(),dc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({fabricId:e.Yj().describe("Fabric ID to filter the overlay statistics by")})}),lc=e.YO(e.Ik({serial:e.Yj().optional().describe("Device serial number"),name:e.Yj().optional().describe("Device name"),vlan:e.ai().int().optional().describe("VLAN ID"),subnet:e.Yj().optional().describe("Subnet CIDR"),vrf:e.Yj().optional().describe("VRF name"),l2Vni:e.ai().int().optional().describe("Layer 2 VNI"),l3Vni:e.ai().int().optional().describe("Layer 3 VNI"),flooding:e.zM().optional().describe("Flood enabled status"),vtepIp:e.Yj().optional().describe("VTEP IP address"),multicastIp:e.Yj().optional().describe("Multicast IP address"),coreIf:e.Yj().optional().describe("Core interface"),state:e.Yj().optional().describe("Connection state")}).optional()).optional(),cc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),configurationUpdatedAfter:e.Yj().optional().optional().describe("Filter results by whether or not the device's configuration has been updated after the given timestamp"),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by network."),productTypes:e.YO(e.k5(["appliance","camera","cellularGateway","secureConnect","sensor","switch","systemsManager","wireless","wirelessController"]).optional()).optional().optional().describe("Optional parameter to filter devices by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect."),tags:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by tags."),tagsFilterType:e.k5(["withAllTags","withAnyTags"]).optional().optional().describe("Optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected."),name:e.Yj().optional().optional().describe("Optional parameter to filter devices by name. All returned devices will have a name that contains the search term or is an exact match."),mac:e.Yj().optional().optional().describe("Optional parameter to filter devices by MAC address. All returned devices will have a MAC address that contains the search term or is an exact match."),serial:e.Yj().optional().optional().describe("Optional parameter to filter devices by serial number. All returned devices will have a serial number that contains the search term or is an exact match."),model:e.Yj().optional().optional().describe("Optional parameter to filter devices by model. All returned devices will have a model that contains the search term or is an exact match."),macs:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by one or more MAC addresses. All returned devices will have a MAC address that is an exact match."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by one or more serial numbers. All returned devices will have a serial number that is an exact match."),sensorMetrics:e.YO(e.k5(["apparentPower","battery","button","co2","current","door","downstreamPower","energy","frequency","humidity","indoorAirQuality","noise","pm25","powerFactor","realPower","remoteLockoutSwitch","temperature","tvoc","voltage","water"]).optional()).optional().optional().describe("Optional parameter to filter devices by the metrics that they provide. Only applies to sensor devices."),sensorAlertProfileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by the alert profiles that are bound to them. Only applies to sensor devices."),models:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match.")})}),pc=e.YO(e.Ik({name:e.Yj().optional().describe("Name of the device"),lat:e.ai().optional().describe("Latitude of the device"),lng:e.ai().optional().describe("Longitude of the device"),address:e.Yj().optional().describe("Physical address of the device"),notes:e.Yj().optional().describe("Notes for the device, limited to 255 characters"),tags:e.YO(e.Yj().optional()).optional().describe("List of tags assigned to the device"),networkId:e.Yj().optional().describe("ID of the network the device belongs to"),serial:e.Yj().optional().describe("Serial number of the device"),model:e.Yj().optional().describe("Model of the device"),imei:e.Yj().optional().describe("IMEI of the device, if applicable"),mac:e.Yj().optional().describe("MAC address of the device"),lanIp:e.Yj().optional().describe("LAN IP address of the device"),firmware:e.Yj().optional().describe("Firmware version of the device"),productType:e.Yj().optional().describe("Product type of the device"),details:e.YO(e.Ik({name:e.Yj().optional().describe("Additional property name"),value:e.Yj().optional().describe("Additional property value")}).optional()).optional().describe("Additional device information")}).optional()).optional(),uc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by network ids."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by serials."),statuses:e.YO(e.k5(["alerting","offline","online"]).optional()).optional().optional().describe('Optional parameter to filter devices by statuses. Valid statuses are ["online", "alerting", "offline", "dormant"].'),productTypes:e.YO(e.k5(["appliance","camera","cellularGateway","secureConnect","sensor","switch","systemsManager","wireless","wirelessController"]).optional()).optional().optional().describe("An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect."),powerSuppliesStatuses:e.YO(e.k5(["available","connected","disconnected","powered","powering","standby"]).optional()).optional().optional().describe("An optional parameter to filter power supply by status. Valid types are disconnected, connected, powered, available, powering and standby"),models:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by models."),tags:e.YO(e.Yj().optional()).optional().optional().describe("An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below)."),tagsFilterType:e.k5(["withAllTags","withAnyTags"]).optional().optional().describe("An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected."),configurationUpdatedAfter:e.Yj().optional().optional().describe("Optional parameter to filter results by whether or not the device's configuration has been updated after the given timestamp"),useCachedData:e.zM().optional().optional().describe("Use mtun data for device statuses. This is less accurate, but quicker. This should only be used on selective Dashboard pages.")})}),hc=e.YO(e.Ik({name:e.Yj().optional().describe("Device Name"),serial:e.Yj().optional().describe("Device Serial Number"),mac:e.Yj().optional().describe("MAC Address"),publicIp:e.Yj().optional().describe("Public IP Address"),networkId:e.Yj().optional().describe("Network ID"),status:e.Yj().optional().describe("Device Status"),lastReportedAt:e.Yj().optional().describe("Device Last Reported Location"),lanIp:e.Yj().optional().describe("LAN IP Address"),gateway:e.Yj().optional().describe("IP Gateway"),ipType:e.Yj().optional().describe("IP Type"),primaryDns:e.Yj().optional().describe("Primary DNS"),secondaryDns:e.Yj().optional().describe("Secondary DNS"),productType:e.Yj().optional().describe("Product Type"),components:e.Ik({powerSupplies:e.YO(e.Ik({slot:e.ai().int().optional().describe("Slot the power supply is in"),serial:e.Yj().optional().describe("Serial of the power supply"),model:e.Yj().optional().describe("Model of the power supply"),status:e.k5(["available","connected","disconnected","powered","powering","standby"]).optional().describe("Status of the power supply"),poe:e.Ik({unit:e.Yj().optional().describe("Unit of the PoE maximum"),maximum:e.ai().int().optional().describe("Maximum PoE this power supply can provide when connected to the current switch model")}).optional().describe("PoE info of the power supply")}).optional()).optional().describe("Power Supplies")}).optional().describe("Components"),model:e.Yj().optional().describe("Model"),tags:e.YO(e.Yj().optional()).optional().describe("Tags")}).optional()).optional(),bc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({productTypes:e.YO(e.k5(["appliance","camera","cellularGateway","secureConnect","sensor","switch","systemsManager","wireless","wirelessController"]).optional()).optional().optional().describe("An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("An optional parameter to filter device statuses by network."),useCachedData:e.zM().optional().optional().describe("Query the OrganizationSummary table for device status overview. The additional data should not be available to customers.")})}),fc=e.Ik({counts:e.Ik({byStatus:e.Ik({online:e.ai().int().optional().describe("online count"),alerting:e.ai().int().optional().describe("alerting count"),offline:e.ai().int().optional().describe("offline count"),dormant:e.ai().int().optional().describe("dormant count")}).optional().describe("byStatus")}).optional().describe("counts")}).optional(),mc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 14 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 14 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter device availabilities history by device serial numbers"),productTypes:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter device availabilities history by device product types"),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter device availabilities history by network IDs"),statuses:e.YO(e.k5(["alerting","offline","online"]).optional()).optional().optional().describe("Optional parameter to filter device availabilities history by device statuses"),categories:e.YO(e.k5(["reboot","status","upgrade"]).optional()).optional().optional().describe("Optional parameter to filter device availabilities history by categories of status, reboot, or upgrade"),networkTags:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter device availabilities history by network tags. The filtering is case-sensitive. If tags are included, 'networkTagsFilterType' should also be included (see below)."),networkTagsFilterType:e.k5(["withAllTags","withAnyTags"]).optional().optional().describe("An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected."),t0Beta:e.Yj().optional().optional().describe("The beginning of the timespan for the data"),t1Beta:e.Yj().optional().optional().describe("The end of the timespan for the data. The latest possible time that t1Beta can be is 31 days into the past"),timespanBeta:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespanBeta, do not specify t0Beta and t1Beta. Maximum is 31 days. Default is 1 day."),deviceTags:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter device availabilities history by device tags. The filtering is case-sensitive. If tags are included, 'deviceTagsFilterType' should also be included (see below)."),deviceTagsFilterType:e.k5(["withAllTags","withAnyTags"]).optional().optional().describe("An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.")})}),gc=e.YO(e.Ik({ts:e.Yj().optional().describe("Timestamp, in iso8601 format, at which the event happened"),category:e.k5(["reboot","status","upgrade"]).optional().describe("Category of event: status, reboot, or upgrade"),device:e.Ik({serial:e.Yj().optional().describe("Device serial number"),name:e.Yj().optional().describe("Device name"),productType:e.k5(["appliance","camera","cellularGateway","cloudGateway","sensor","switch","systemsManager","wireless"]).optional().describe("Device product type."),model:e.Yj().optional().describe("Device model"),tags:e.YO(e.Yj().optional()).optional().describe("Device tags")}).optional().describe("Device information"),details:e.Ik({old:e.YO(e.Ik({name:e.Yj().optional().describe("Name of the detail"),value:e.Yj().optional().describe("Value of the detail")}).optional()).optional().describe("Details about the old status"),new:e.YO(e.Ik({name:e.Yj().optional().describe("Name of the detail"),value:e.Yj().optional().describe("Value of the detail")}).optional()).optional().describe("Details about the new status")}).optional().describe("Details about the status changes"),network:e.Ik({id:e.Yj().optional().describe("Network id"),name:e.Yj().optional().describe("Network name"),url:e.Yj().optional().describe("Network dashboard url"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags")}).optional().describe("Network information")}).optional()).optional(),Ic=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({models:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter devices by networkId."),productTypes:e.YO(e.k5(["appliance","camera","campusGateway","cellularGateway","secureConnect","sensor","switch","systemsManager","wireless","wirelessController"]).optional()).optional().optional().describe("Optional parameter to filter device by device product types. This filter uses multiple exact matches.")})}),vc=e.Ik({counts:e.YO(e.Ik({model:e.Yj().optional().describe("Device model"),total:e.ai().int().optional().describe("Total number of devices for the model")}).optional()).optional().describe("Counts of devices per model")}).optional(),yc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),models:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter networks by one or more device models. All returned networks will have at least one device model that is an exact match.")})}),kc=e.Ik({items:e.YO(e.Ik({networkId:e.Yj().optional().describe("Network ID"),name:e.Yj().optional().describe("Network name"),timeZone:e.Yj().optional().describe("Network time zone")}).optional()).optional().describe("List of networks"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items in the dataset"),remaining:e.ai().int().optional().describe("The number of items in the dataset that are available on subsequent pages")}).optional().describe("Counts relating to the paginated items")}).optional().describe("Counts relating to the paginated dataset")}).optional().describe("Metadata relevant to the paginated dataset")}).optional(),wc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({configTemplateId:e.Yj().optional().optional().describe("An optional parameter that is the ID of a config template. Will return all networks bound to that template."),isBoundToConfigTemplate:e.zM().optional().optional().describe("An optional parameter to filter config template bound networks. If configTemplateId is set, this cannot be false."),tags:e.YO(e.Yj().optional()).optional().optional().describe("An optional parameter to filter networks by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below)."),tagsFilterType:e.k5(["withAllTags","withAnyTags"]).optional().optional().describe("An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected."),productTypes:e.YO(e.k5(["appliance","camera","cellularGateway","secureConnect","sensor","switch","systemsManager","wireless","wirelessController"]).optional()).optional().optional().describe("An optional parameter to filter networks by product type. Results will have at least one of the included product types."),hasOrgAdminVideoAccess:e.zM().optional().optional().describe("An optional parameter, when true, only the networks in which organization admins have video access to will be returned."),perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")})}),jc=e.YO(e.Ik({id:e.Yj().optional().describe("Network ID"),organizationId:e.Yj().optional().describe("Organization ID"),name:e.Yj().optional().describe("Network name"),productTypes:e.YO(e.Yj().optional()).optional().describe("List of the product types that the network supports"),timeZone:e.Yj().optional().describe("Timezone of the network"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags"),enrollmentString:e.Yj().optional().describe("Enrollment string for the network"),url:e.Yj().optional().describe("URL to the network Dashboard UI"),notes:e.Yj().optional().describe("Notes for the network"),isBoundToConfigTemplate:e.zM().optional().describe("If the network is bound to a config template")}).optional()).optional(),Yc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({name:e.Yj().describe("The name of the new network"),productTypes:e.YO(e.k5(["appliance","camera","cellularGateway","secureConnect","sensor","switch","systemsManager","wireless","wirelessController"]).optional()).describe("The product type(s) of the new network. If more than one type is included, the network will be a combined network."),tags:e.YO(e.Yj().optional()).optional().optional().describe("A list of tags to be applied to the network"),timeZone:e.Yj().optional().optional().describe("The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>"),copyFromNetworkId:e.Yj().optional().optional().describe("The ID of the network to copy configuration from. Other provided parameters will override the copied configuration, except type which must match this network's type exactly."),notes:e.Yj().optional().optional().describe("Add any notes or additional information about this network here.")})}),Tc=e.Ik({id:e.Yj().optional().describe("Network ID"),organizationId:e.Yj().optional().describe("Organization ID"),name:e.Yj().optional().describe("Network name"),productTypes:e.YO(e.Yj().optional()).optional().describe("List of the product types that the network supports"),timeZone:e.Yj().optional().describe("Timezone of the network"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags"),enrollmentString:e.Yj().optional().describe("Enrollment string for the network"),url:e.Yj().optional().describe("URL to the network Dashboard UI"),notes:e.Yj().optional().describe("Notes for the network"),isBoundToConfigTemplate:e.zM().optional().describe("If the network is bound to a config template")}).optional(),Pc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({name:e.Yj().describe("The name of the combined network"),networkIds:e.YO(e.Yj().optional()).describe("A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network"),enrollmentString:e.Yj().optional().optional().describe("A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.")})}),Oc=e.Ik({resultingNetwork:e.Ik({id:e.Yj().optional().describe("Network ID"),organizationId:e.Yj().optional().describe("Organization ID"),name:e.Yj().optional().describe("Network name"),productTypes:e.YO(e.Yj().optional()).optional().describe("List of the product types that the network supports"),timeZone:e.Yj().optional().describe("Timezone of the network"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags"),enrollmentString:e.Yj().optional().describe("Enrollment string for the network"),url:e.Yj().optional().describe("URL to the network Dashboard UI"),notes:e.Yj().optional().describe("Notes for the network"),isBoundToConfigTemplate:e.zM().optional().describe("If the network is bound to a config template")}).optional().describe("Network after the combination")}).optional(),Sc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Filter results by network id(s)."),vlanId:e.Yj().optional().optional().describe("Filter results by VLAN ID."),mac:e.YO(e.Yj().optional()).optional().optional().describe("Filter results by mac address(es)."),days:e.ai().int().describe("Filter results by when client was last connected, max 45 days.")})}),Dc=e.Ik({}).optional(),Rc=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter by network"),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter by serial number.  All returned devices will have a serial number that is an exact match."),macs:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter by one or more MAC addresses belonging to devices. All devices returned belong to MAC addresses that are an exact match."),firmwareUpgradeBatchIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter by firmware upgrade batch ids."),upgradeStatuses:e.YO(e.k5(["canceled","completed","scheduled","started"]).optional()).optional().optional().describe("Optional parameter to filter by firmware upgrade statuses."),currentUpgradesOnly:e.zM().optional().optional().describe("Optional parameter to filter to only current or pending upgrade statuses"),limitPerDevice:e.ai().optional().optional().describe("Optional parameter to limit the number of upgrade statuses returned per device. If omitted, a value of 5 is used.")})}),$t=["Completed","Scheduled","Skipped","Canceled","Started"],Io=["download-complete","download-retrying","download-started","install-retrying","install-started","upgrade-canceled","upgrade-complete","upgrade-failed","upgrade-retry-scheduled","upgrade-scheduled","upgrade-skipped","verification-started"],xt=["canceled","complete","failed","rescheduled","retrying","scheduled","skipped","started"],zc=e.YO(e.Ik({checkinFinishedAt:e.Yj().nullable().describe("The time the device checkin finished"),checkinStartedAt:e.Yj().nullable().describe("The time the device checkin started"),detailedStatus:e.k5(Io).nullable().describe("The detailed status of the device upgrade"),deviceStatus:e.k5($t).describe("Status of the device upgrade"),downloadFinishedAt:e.Yj().nullable().describe("The time the device upgrade download finished"),downloadStartedAt:e.Yj().nullable().describe("The time the device upgrade download started"),downloadStatus:e.k5(xt).nullable().describe("The status of the device upgrade download"),installFinishedAt:e.Yj().nullable().describe("The time the device upgrade install finished"),installStartedAt:e.Yj().nullable().describe("The time the device upgrade install started"),installStatus:e.k5(xt).nullable().describe("The status of the device upgrade install"),name:e.Yj().describe("Name assigned to the device"),serial:e.Yj().describe("Serial of the device"),verifyFinishedAt:e.Yj().nullable().describe("The time the device upgrade verification finished"),verifyStartedAt:e.Yj().nullable().describe("The time the device upgrade verification started"),verifyStatus:e.k5(xt).nullable().describe("The status of the device upgrade verification"),upgrade:e.Ik({time:e.Yj().describe("Start time of the upgrade"),fromVersion:e.Ik({id:e.Yj().describe("ID of the initial firmware version"),shortName:e.Yj().describe("Firmware version short name"),releaseDate:e.Yj().describe("Release date of the firmware version")}).describe("The initial version of the device"),toVersion:e.Ik({id:e.Yj().describe("ID of the initial firmware version"),shortName:e.Yj().describe("Firmware version short name"),releaseDate:e.Yj().describe("Release date of the firmware version")}).describe("Version the device is upgrading to"),status:e.k5($t).describe("Status of the upgrade"),id:e.Yj().describe("ID of the upgrade"),upgradeBatchId:e.Yj().nullable().describe("ID of the upgrade batch"),staged:e.Ik({group:e.Ik({id:e.Yj().optional().describe("Id of the staged upgrade group")}).optional().describe("The staged upgrade group")}).optional().describe("Staged upgrade")}).describe("The devices upgrade details and status")})),Ac=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),status:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter the upgrade by status."),productType:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter the upgrade by product type."),productTypes:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter the upgrade by product type.")})}),xc=e.YO(e.Ik({upgradeId:e.Yj().optional().describe("The upgrade"),upgradeBatchId:e.Yj().optional().describe("The upgrade batch"),network:e.Ik({id:e.Yj().optional().describe("ID of network"),name:e.Yj().optional().describe("The network")}).optional().describe("Network of the upgrade"),status:e.Yj().optional().describe("Status of upgrade event: [Cancelled, Completed]"),time:e.Yj().optional().describe("Scheduled start time"),completedAt:e.Yj().optional().describe("Timestamp when upgrade completed. Null if status pending."),productTypes:e.Yj().optional().describe("product upgraded [wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor]"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version ID"),shortName:e.Yj().optional().describe("Firmware version short name"),firmware:e.Yj().optional().describe("Firmware name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("ID of the upgrade's target version"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version ID"),shortName:e.Yj().optional().describe("Firmware version short name"),firmware:e.Yj().optional().describe("Firmware name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("ID of the upgrade's starting version")}).optional()).optional(),Nc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),query:e.Ik({mode:e.k5(["loopback","routed","vlan"]).optional().optional().describe("Optional parameter to filter L3 interfaces by mode."),protocol:e.k5(["ipv4","ipv6"]).optional().optional().describe("Optional parameter to filter L3 interfaces by protocol.")})}),vo=e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway")}).optional()).optional(),Cc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial"),interfaceId:e.Yj().describe("Interface ID")})}),Lc=e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway")}).optional(),Mc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial"),interfaceId:e.Yj().describe("Interface ID")}),body:e.Ik({name:e.Yj().optional().describe("A friendly name or description for the interface or VLAN (max length 128 characters)."),subnet:e.Yj().optional().describe("The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24)."),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode (CS 17.18 or higher required)"),interfaceIp:e.Yj().optional().describe("The IP address that will be used for Layer 3 routing on this VLAN or subnet. This cannot be the same         as the device management IP."),multicastRouting:e.k5(["IGMP snooping querier","disabled","enabled"]).optional().describe("Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'."),vlanId:e.ai().int().optional().describe("The VLAN this L3 interface is on. VLAN must be between 1 and 4094."),defaultGateway:e.Yj().optional().describe("The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a L3 interface. Required if this is the first IPv4 interface."),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink."),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink."),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPF will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("The OSPF routing settings of the interface."),ospfV3:e.Ik({area:e.Yj().optional().describe("The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("The OSPFv3 routing settings of the interface."),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'."),prefix:e.Yj().optional().describe("The IPv6 prefix of the interface. Required if IPv6 object is included."),address:e.Yj().optional().describe("The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'."),gateway:e.Yj().optional().describe("The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured."),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("The IPv6 settings of the interface."),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to.")}).optional().describe("The VRF settings of the interface. Requires IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("The loopback number")}).optional().describe("The loopback settings of the interface."),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only applicable to Catalyst switches")}).optional()}),Fc=e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway")}).optional(),Gc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial"),interfaceId:e.Yj().describe("Interface ID")})}),Bc=e.Vx(),qc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),body:e.Ik({dryrun:e.zM().optional().optional().describe("This parameter is used to validate the request without actually applying the changes."),name:e.Yj().describe("A friendly name or description for the interface or VLAN (max length 128 characters)."),mode:e.k5(["loopback","routed","vlan"]).optional().optional().describe("L3 Interface mode, can be one of 'vlan', 'routed' or 'loopback'. Default is 'vlan'. CS 17.18 or higher is required for 'routed' mode."),subnet:e.Yj().optional().optional().describe("The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24)."),switchPortId:e.Yj().optional().optional().describe("Switch Port ID when in Routed mode (CS 17.18 or higher required)"),interfaceIp:e.Yj().optional().optional().describe("The IP address that will be used for Layer 3 routing on this VLAN or subnet. This cannot be the same         as the device management IP."),multicastRouting:e.k5(["IGMP snooping querier","disabled","enabled"]).optional().optional().describe("Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'."),vlanId:e.ai().int().optional().optional().describe("The VLAN this L3 interface is on. VLAN must be between 1 and 4094."),defaultGateway:e.Yj().optional().optional().describe("The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a L3 interface. Required if this is the first IPv4 interface."),uplinkV4:e.zM().optional().optional().describe("When true, this interface is used as static IPv4 uplink."),candidateUplinkV4:e.zM().optional().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().optional().describe("When true, this interface is used as static IPv6 uplink."),staticV4Dns1:e.Yj().optional().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPF will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().optional().describe("The OSPF routing settings of the interface."),ospfV3:e.Ik({area:e.Yj().optional().describe("The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().optional().describe("The OSPFv3 routing settings of the interface."),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'."),prefix:e.Yj().optional().describe("The IPv6 prefix of the interface. Required if IPv6 object is included."),address:e.Yj().optional().describe("The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'."),gateway:e.Yj().optional().describe("The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured."),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().optional().describe("The IPv6 settings of the interface."),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to.")}).optional().optional().describe("The VRF settings of the interface. Requires IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("The loopback number")}).optional().optional().describe("The loopback settings of the interface."),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().optional().describe("VRRP configuration for the L3 interface.  This is only applicable to Catalyst switches")})}),yo=e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway")}).optional(),Vc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")})}),Ec=e.Ik({name:e.Yj().optional().describe("Name of the device"),lat:e.ai().optional().describe("Latitude of the device"),lng:e.ai().optional().describe("Longitude of the device"),address:e.Yj().optional().describe("Physical address of the device"),notes:e.Yj().optional().describe("Notes for the device, limited to 255 characters"),tags:e.YO(e.Yj().optional()).optional().describe("List of tags assigned to the device"),networkId:e.Yj().optional().describe("ID of the network the device belongs to"),serial:e.Yj().optional().describe("Serial number of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),lanIp:e.Yj().optional().describe("LAN IP address of the device"),firmware:e.Yj().optional().describe("Firmware version of the device"),floorPlanId:e.Yj().optional().describe("The floor plan to associate to this device. null disassociates the device from the floorplan."),details:e.YO(e.Ik({name:e.Yj().optional().describe("Additional property name"),value:e.Yj().optional().describe("Additional property value")}).optional()).optional().describe("Additional device information"),beaconIdParams:e.Ik({uuid:e.Yj().optional().describe("The UUID to be used in the beacon identifier"),major:e.ai().int().optional().describe("The major number to be used in the beacon identifier"),minor:e.ai().int().optional().describe("The minor number to be used in the beacon identifier")}).optional().describe("Beacon Id parameters with an identifier and major and minor versions")}).optional(),_c=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),body:e.Ik({name:e.Yj().optional().describe("The name of a device"),tags:e.YO(e.Yj().optional()).optional().describe("The list of tags of a device"),lat:e.ai().optional().describe("The latitude of a device"),lng:e.ai().optional().describe("The longitude of a device"),address:e.Yj().optional().describe("The address of a device"),notes:e.Yj().optional().describe("The notes for the device. String. Limited to 255 characters."),moveMapMarker:e.zM().optional().describe("Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified."),switchProfileId:e.Yj().optional().describe("The ID of a switch template to bind to the device (for available switch templates, see the 'Switch Templates' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch template, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template."),floorPlanId:e.Yj().optional().describe("The floor plan to associate to this device. null disassociates the device from the floorplan.")}).optional()}),Uc=e.Ik({name:e.Yj().optional().describe("Name of the device"),lat:e.ai().optional().describe("Latitude of the device"),lng:e.ai().optional().describe("Longitude of the device"),address:e.Yj().optional().describe("Physical address of the device"),notes:e.Yj().optional().describe("Notes for the device, limited to 255 characters"),tags:e.YO(e.Yj().optional()).optional().describe("List of tags assigned to the device"),networkId:e.Yj().optional().describe("ID of the network the device belongs to"),serial:e.Yj().optional().describe("Serial number of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),lanIp:e.Yj().optional().describe("LAN IP address of the device"),firmware:e.Yj().optional().describe("Firmware version of the device"),floorPlanId:e.Yj().optional().describe("The floor plan to associate to this device. null disassociates the device from the floorplan."),details:e.YO(e.Ik({name:e.Yj().optional().describe("Additional property name"),value:e.Yj().optional().describe("Additional property value")}).optional()).optional().describe("Additional device information"),beaconIdParams:e.Ik({uuid:e.Yj().optional().describe("The UUID to be used in the beacon identifier"),major:e.ai().int().optional().describe("The major number to be used in the beacon identifier"),minor:e.ai().int().optional().describe("The minor number to be used in the beacon identifier")}).optional().describe("Beacon Id parameters with an identifier and major and minor versions")}).optional(),Hc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 30 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 14 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 30 minutes and be less than or equal to 14 days. The default is 30 minutes.")})}),Qc=e.Ik({perfScore:e.ai().optional().describe("Utilization for the MX device")}).optional(),Wc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 31 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day."),types:e.YO(e.k5(["assoc","auth","connection","deauth","dhcp","disassoc","dns","roam","sticky"]).optional()).optional().optional().describe("A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'."),band:e.k5(["2.4","5","6"]).optional().optional().describe("Filter results by band. Valid bands are '2.4', '5' or '6'."),ssidNumber:e.ai().int().optional().optional().describe("Filter results by SSID. If not specified, events for all SSIDs will be returned."),severities:e.YO(e.k5(["bad","good","info","warn"]).optional()).optional().optional().describe("A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'."),clientId:e.Yj().optional().optional().describe("Filter results by client ID. If not specified, events for all clients will be returned.")})}),Kc=e.YO(e.Ik({occurredAt:e.Yj().optional().describe("Timestamp at which the event occurred"),band:e.k5(["2.4","5","6"]).optional().describe("Wireless band the event occurred on"),ssidNumber:e.ai().int().optional().describe("Number of the SSID the event occurred in"),type:e.k5(["assoc","auth","connection","deauth","dhcp","disassoc","dns","roam","sticky"]).optional().describe("Event type"),subtype:e.Yj().optional().describe("Event subtype"),severity:e.Yj().optional().describe("Event severity"),durationMs:e.ai().int().optional().describe("Duration of the event in milliseconds"),channel:e.ai().int().optional().describe("Wireless channel the event occurred over"),rssi:e.ai().int().optional().describe("RSSI recorded at the time of the event"),eventData:e.Ik({}).optional().describe("Additional information relevant to the given event. Properties vary based on event type."),clientId:e.Yj().optional().describe("ID of the client the event occurred for"),clientMac:e.Yj().optional().describe("MAC address of the client"),clientDescription:e.Yj().optional().describe("Description of the client")}).optional()).optional(),Xc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")})}),Jc=e.Ik({sourceMac:e.Yj().optional().describe("Source MAC address"),ports:e.Ik({}).optional().describe("Mapping of ports to lldp and/or cdp information")}).optional(),Zc=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 60 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 31 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day."),resolution:e.ai().int().optional().optional().describe("The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60."),uplink:e.k5(["cellular","wan1","wan2","wan3"]).optional().optional().describe("The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1."),ip:e.Yj().describe("The destination IP used to obtain the requested stats. This is required.")})}),$c=e.YO(e.Ik({startTime:e.Yj().optional().describe("Start time of the sample"),endTime:e.Yj().optional().describe("End time of the sample"),lossPercent:e.ai().optional().describe("Percentage of packets lost"),latencyMs:e.ai().optional().describe("Latency in milliseconds"),goodput:e.ai().int().optional().describe("Number of useful information bits delivered"),jitter:e.ai().optional().describe("Jitter, in milliseconds")}).optional()).optional(),ep=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),body:e.Ik({duration:e.ai().int().optional().describe("The duration in seconds. Must be between 5 and 120. Default is 20 seconds"),period:e.ai().int().optional().describe("The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds"),duty:e.ai().int().optional().describe("The duty cycle as the percent active. Must be between 10 and 90. Default is 50.")}).optional()}),tp=e.Ik({duration:e.ai().int().optional().describe("The duration in seconds. Will be between 5 and 120. Default is 20 seconds"),period:e.ai().int().optional().describe("The period in milliseconds. Will be between 100 and 1000. Default is 160 milliseconds"),duty:e.ai().int().optional().describe("The duty cycle as the percent active. Will be between 10 and 90. Default is 50")}).optional(),ip=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.")})}),op=e.YO(e.Ik({id:e.Yj().optional().describe("The ID of the client"),mac:e.Yj().optional().describe("The MAC address of the client"),description:e.Yj().optional().describe("Short description of the client"),mdnsName:e.Yj().optional().describe("The client's MDNS name"),dhcpHostname:e.Yj().optional().describe("The client's DHCP hostname"),user:e.Yj().optional().describe("The client user's name"),ip:e.Yj().optional().describe("The IP address of the client"),vlan:e.Yj().optional().describe("The client-assigned name of the VLAN the client is connected to"),namedVlan:e.Yj().optional().describe("The owner-assigned name of the VLAN the client is connected to"),switchport:e.Yj().optional().describe("The name of the switchport with clients on it, if the device is a switch"),adaptivePolicyGroup:e.Yj().optional().describe("A description of the adaptive policy group"),usage:e.Ik({sent:e.ai().optional().describe("Usage sent by the client"),recv:e.ai().optional().describe("Usage received by the client")}).optional().describe("Client usage data for sent and received")}).optional()).optional(),rp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),ko=e.YO(e.Ik({id:e.Yj().optional().describe("The ID for the link aggregation."),meta:e.Ik({serial:e.Yj().optional().describe("Switch serial"),switchStackId:e.Yj().optional().describe("ID of switch stack."),switchProfileId:e.Yj().optional().describe("Id of switch profile."),aggrId:e.Yj().optional().describe("The ID of aggregation.")}).optional().describe("Aggregation details."),switchPorts:e.YO(e.Ik({serial:e.Yj().optional().describe("The serial number for the switch port."),portId:e.Yj().optional().describe("The ID for the switch port.")}).optional()).optional().describe("The ID for the link aggregation.")}).optional()).optional(),np=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({switchPorts:e.YO(e.Ik({serial:e.Yj().describe("Serial number of the switch."),portId:e.Yj().describe('Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").')})).optional().describe("Array of switch or stack ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported."),switchProfilePorts:e.YO(e.Ik({profile:e.Yj().describe("Profile identifier."),portId:e.Yj().describe('Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").')})).optional().describe("Array of switch profile ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.")}).optional()}),ap=e.Ik({id:e.Yj().optional().describe("The ID for the link aggregation."),switchPorts:e.YO(e.Ik({serial:e.Yj().optional().describe("The serial number for the switch port."),portId:e.Yj().optional().describe("The ID for the switch port.")}).optional()).optional().describe("The ID for the link aggregation.")}).optional(),sp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),linkAggregationId:e.Yj().describe("Link aggregation ID")}),body:e.Ik({switchPorts:e.YO(e.Ik({serial:e.Yj().describe("Serial number of the switch."),portId:e.Yj().describe('Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").')})).optional().describe("Array of switch or stack ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported."),switchProfilePorts:e.YO(e.Ik({profile:e.Yj().describe("Profile identifier."),portId:e.Yj().describe('Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").')})).optional().describe("Array of switch profile ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.")}).optional()}),dp=e.Ik({id:e.Yj().optional().describe("The ID for the link aggregation."),switchPorts:e.YO(e.Ik({serial:e.Yj().optional().describe("The serial number for the switch port."),portId:e.Yj().optional().describe("The ID for the switch port.")}).optional()).optional().describe("The ID for the link aggregation.")}).optional(),lp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),linkAggregationId:e.Yj().describe("Link aggregation ID")})}),cp=e.Vx(),pp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),up=e.Ik({vlan:e.ai().int().optional().describe("Management VLAN"),useCombinedPower:e.zM().optional().describe("The use Combined Power as the default behavior of secondary power supplies on supported devices."),powerExceptions:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the switch"),powerType:e.k5(["combined","redundant","useNetworkSetting"]).optional().describe("Per switch exception (combined, redundant, useNetworkSetting)")}).optional()).optional().describe('Exceptions on a per switch basis to "useCombinedPower"'),uplinkClientSampling:e.Ik({enabled:e.zM().optional().describe("Enable client sampling on uplink")}).optional().describe("Uplink client sampling"),macBlocklist:e.Ik({enabled:e.zM().optional().describe("Enable MAC blocklist for switches in the network")}).optional().describe("MAC blocklist"),uplinkSelection:e.Ik({failback:e.Ik({enabled:e.zM().optional().describe("Enable preferred uplink failback.")}).optional().describe("If a preferred uplink ever goes offline, we will periodically reattempt it."),candidates:e.Yj().optional().describe("'all' lets devices try any potential interface for uplink. 'designated' enables configuration of candidates via the Routing & DHCP page.")}).optional().describe("Settings related to uplink selection on IOS-XE switches.")}).optional(),hp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({vlan:e.ai().int().optional().describe("Management VLAN"),useCombinedPower:e.zM().optional().describe("The use Combined Power as the default behavior of secondary power supplies on supported devices."),powerExceptions:e.YO(e.Ik({serial:e.Yj().describe("Serial number of the switch"),powerType:e.k5(["combined","redundant","useNetworkSetting"]).describe("Per switch exception (combined, redundant, useNetworkSetting)")})).optional().describe('Exceptions on a per switch basis to "useCombinedPower"'),uplinkClientSampling:e.Ik({enabled:e.zM().describe("Enable uplink client sampling")}).describe("Uplink client sampling"),macBlocklist:e.Ik({enabled:e.zM().describe("Enable MAC blocklist")}).describe("MAC blocklist"),uplinkSelection:e.Ik({failback:e.Ik({enabled:e.zM().describe("Enable preferred uplink failback.")}).describe("If a preferred uplink ever goes offline, we will periodically reattempt it."),candidates:e.k5(["all","designated"]).describe("'all' lets devices try any potential interface. 'designated' restricts to specified candidates (configured via the Routing & DHCP page).")}).describe("Settings related to uplink selection on IOS-XE switches.")}).optional()}),bp=e.Ik({vlan:e.ai().int().optional().describe("Management VLAN"),useCombinedPower:e.zM().optional().describe("The use Combined Power as the default behavior of secondary power supplies on supported devices."),powerExceptions:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the switch"),powerType:e.k5(["combined","redundant","useNetworkSetting"]).optional().describe("Per switch exception (combined, redundant, useNetworkSetting)")}).optional()).optional().describe('Exceptions on a per switch basis to "useCombinedPower"'),uplinkClientSampling:e.Ik({enabled:e.zM().optional().describe("Enable client sampling on uplink")}).optional().describe("Uplink client sampling"),macBlocklist:e.Ik({enabled:e.zM().optional().describe("Enable MAC blocklist for switches in the network")}).optional().describe("MAC blocklist"),uplinkSelection:e.Ik({failback:e.Ik({enabled:e.zM().optional().describe("Enable preferred uplink failback.")}).optional().describe("If a preferred uplink ever goes offline, we will periodically reattempt it."),candidates:e.Yj().optional().describe("'all' lets devices try any potential interface for uplink. 'designated' enables configuration of candidates via the Routing & DHCP page.")}).optional().describe("Settings related to uplink selection on IOS-XE switches.")}).optional(),fp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),mp=e.YO(e.Ik({id:e.Yj().optional().describe("ID of the Switch stack"),name:e.Yj().optional().describe("Name of the Switch stack"),serials:e.YO(e.Yj().optional()).optional().describe("Serials of the switches in the switch stack"),isMonitorOnly:e.zM().optional().describe("Tells if stack is Monitored Stack."),members:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the device"),name:e.Yj().optional().describe("Name of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),role:e.k5(["active","member","standby"]).optional().describe("Role of the device")}).optional()).optional().describe("Members of the Stack")}).optional()).optional(),gp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({name:e.Yj().describe("The name of the new stack"),serials:e.YO(e.Yj().optional()).describe("An array of switch serials to be added into the new stack"),stackWiseVirtual:e.Ik({links:e.YO(e.Ik({serial:e.Yj().optional().describe("The serial of the device these details relate to"),ports:e.YO(e.Yj().optional()).optional().describe("List of switch port identifiers to be assigned as StackWise Virtual links"),dualActiveDetection:e.Ik({ports:e.YO(e.Yj().optional()).optional().describe("List of switch port identifiers to be assigned as Dual Active Detection links")}).optional().describe("Dual Active Detection link details")}).optional()).optional().describe("Array of devices forming SVL Stack")}).optional().optional().describe("Config information needed for creating an SVL stack")})}),Ip=e.Ik({id:e.Yj().optional().describe("ID of the Switch stack"),name:e.Yj().optional().describe("Name of the Switch stack"),serials:e.YO(e.Yj().optional()).optional().describe("Serials of the switches in the switch stack"),isMonitorOnly:e.zM().optional().describe("Tells if stack is Monitored Stack."),members:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the device"),name:e.Yj().optional().describe("Name of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),role:e.k5(["active","member","standby"]).optional().describe("Role of the device")}).optional()).optional().describe("Members of the Stack")}).optional(),vp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID")})}),yp=e.Ik({id:e.Yj().optional().describe("ID of the Switch stack"),name:e.Yj().optional().describe("Name of the Switch stack"),serials:e.YO(e.Yj().optional()).optional().describe("Serials of the switches in the switch stack"),isMonitorOnly:e.zM().optional().describe("Tells if stack is Monitored Stack."),members:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the device"),name:e.Yj().optional().describe("Name of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),role:e.k5(["active","member","standby"]).optional().describe("Role of the device")}).optional()).optional().describe("Members of the Stack")}).optional(),kp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID")})}),wp=e.Vx(),jp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID")}),body:e.Ik({serial:e.Yj().describe("The serial of the switch to be added")})}),Yp=e.Ik({id:e.Yj().optional().describe("ID of the Switch stack"),name:e.Yj().optional().describe("Name of the Switch stack"),serials:e.YO(e.Yj().optional()).optional().describe("Serials of the switches in the switch stack"),isMonitorOnly:e.zM().optional().describe("Tells if stack is Monitored Stack."),members:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the device"),name:e.Yj().optional().describe("Name of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),role:e.k5(["active","member","standby"]).optional().describe("Role of the device")}).optional()).optional().describe("Members of the Stack")}).optional(),Tp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID")}),body:e.Ik({serial:e.Yj().describe("The serial of the switch to be removed")})}),Pp=e.Ik({id:e.Yj().optional().describe("ID of the Switch stack"),name:e.Yj().optional().describe("Name of the Switch stack"),serials:e.YO(e.Yj().optional()).optional().describe("Serials of the switches in the switch stack"),isMonitorOnly:e.zM().optional().describe("Tells if stack is Monitored Stack."),members:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the device"),name:e.Yj().optional().describe("Name of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),role:e.k5(["active","member","standby"]).optional().describe("Role of the device")}).optional()).optional().describe("Members of the Stack")}).optional(),Op=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID")}),query:e.Ik({mode:e.k5(["loopback","routed","vlan"]).optional().optional().describe("Optional parameter to filter L3 interfaces by mode."),protocol:e.k5(["ipv4","ipv6"]).optional().optional().describe("Optional parameter to filter L3 interfaces by protocol.")}).optional()}),wo=e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address")}).optional().describe("IPv6 addressing"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback settings"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway")}).optional()).optional(),Sp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID")}),body:e.Ik({name:e.Yj().describe("A friendly name or description for the interface or VLAN (max length 128 characters)."),mode:e.k5(["loopback","routed","vlan"]).optional().optional().describe("L3 Interface mode, can be one of 'vlan', 'routed' or 'loopback'. Default is 'vlan'."),subnet:e.Yj().optional().optional().describe("The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24)."),switchPortId:e.Yj().optional().optional().describe("Switch Port ID when in Routed mode"),interfaceIp:e.Yj().optional().optional().describe("The IP address that will be used for Layer 3 routing on this VLAN or subnet. This cannot be the same         as the device management IP."),multicastRouting:e.k5(["IGMP snooping querier","disabled","enabled"]).optional().optional().describe("Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'."),vlanId:e.ai().int().optional().optional().describe("The VLAN this L3 interface is on. VLAN must be between 1 and 4094."),defaultGateway:e.Yj().optional().optional().describe("The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a L3 interface. Required if this is the first IPv4 interface."),uplinkV4:e.zM().optional().optional().describe("When true, this interface is used as static IPv4 uplink."),uplinkV6:e.zM().optional().optional().describe("When true, this interface is used as static IPv6 uplink."),staticV4Dns1:e.Yj().optional().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPF will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().optional().describe("The OSPF routing settings of the interface."),ospfV3:e.Ik({area:e.Yj().optional().describe("The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().optional().describe("The OSPFv3 routing settings of the interface."),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'."),prefix:e.Yj().optional().describe("The IPv6 prefix of the interface. Required if IPv6 object is included."),address:e.Yj().optional().describe("The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'."),gateway:e.Yj().optional().describe("The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured."),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address")}).optional().optional().describe("The IPv6 settings of the interface."),loopback:e.Ik({number:e.ai().int().optional().describe("The number of the loopback interface. Required if mode is 'loopback'.")}).optional().optional().describe("The loopback settings of the interface."),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to.")}).optional().optional().describe("The VRF settings of the interface."),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6")}).optional().describe("IPv6 VRRP configuration")}).optional().optional().describe("VRRP configuration for the L3 interface.  This is only applicable to Catalyst switches"),serial:e.Yj().optional().optional().describe("Serial of the Routed Port Switch in Stack. Required when in Routed mode along with switchPortId.")})}),jo=e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address")}).optional().describe("IPv6 addressing"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback interface number")}).optional().describe("Loopback settings"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway")}).optional(),Dp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID"),interfaceId:e.Yj().describe("Interface ID")})}),Rp=e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address")}).optional().describe("IPv6 addressing"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback interface number")}).optional().describe("Loopback interface settings"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway")}).optional(),zp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID"),interfaceId:e.Yj().describe("Interface ID")}),body:e.Ik({name:e.Yj().optional().describe("A friendly name or description for the interface or VLAN (max length 128 characters)."),subnet:e.Yj().optional().describe("The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24)."),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),interfaceIp:e.Yj().optional().describe("The IP address that will be used for Layer 3 routing on this VLAN or subnet. This cannot be the same         as the device management IP."),multicastRouting:e.k5(["IGMP snooping querier","disabled","enabled"]).optional().describe("Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'."),vlanId:e.ai().int().optional().describe("The VLAN this L3 interface is on. VLAN must be between 1 and 4094."),defaultGateway:e.Yj().optional().describe("The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a L3 interface. Required if this is the first IPv4 interface."),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink."),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPF will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("The OSPF routing settings of the interface."),ospfV3:e.Ik({area:e.Yj().optional().describe("The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("The OSPFv3 routing settings of the interface."),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'."),prefix:e.Yj().optional().describe("The IPv6 prefix of the interface. Required if IPv6 object is included."),address:e.Yj().optional().describe("The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'."),gateway:e.Yj().optional().describe("The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured."),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address")}).optional().describe("The IPv6 settings of the interface."),loopback:e.Ik({number:e.ai().int().optional().describe("The number of the loopback. Required if mode is 'loopback'.")}).optional().describe("The loopback settings of the interface."),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to.")}).optional().describe("The VRF settings of the interface."),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only applicable to Catalyst switches"),serial:e.Yj().optional().describe("Serial of the Routed Port Switch in Stack. Required when in Routed mode along with switchPortId.")}).optional()}),Ap=e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address")}).optional().describe("IPv6 addressing"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback settings"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches")}).optional(),xp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID"),interfaceId:e.Yj().describe("Interface ID")})}),Np=e.Vx(),Cp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),Lp=e.YO(e.Ik({name:e.Yj().optional().describe("Name of the device"),lat:e.ai().optional().describe("Latitude of the device"),lng:e.ai().optional().describe("Longitude of the device"),address:e.Yj().optional().describe("Physical address of the device"),notes:e.Yj().optional().describe("Notes for the device, limited to 255 characters"),tags:e.YO(e.Yj().optional()).optional().describe("List of tags assigned to the device"),networkId:e.Yj().optional().describe("ID of the network the device belongs to"),serial:e.Yj().optional().describe("Serial number of the device"),model:e.Yj().optional().describe("Model of the device"),mac:e.Yj().optional().describe("MAC address of the device"),lanIp:e.Yj().optional().describe("LAN IP address of the device"),firmware:e.Yj().optional().describe("Firmware version of the device"),floorPlanId:e.Yj().optional().describe("The floor plan to associate to this device. null disassociates the device from the floorplan."),details:e.YO(e.Ik({name:e.Yj().optional().describe("Additional property name"),value:e.Yj().optional().describe("Additional property value")}).optional()).optional().describe("Additional device information"),beaconIdParams:e.Ik({uuid:e.Yj().optional().describe("The UUID to be used in the beacon identifier"),major:e.ai().int().optional().describe("The major number to be used in the beacon identifier"),minor:e.ai().int().optional().describe("The minor number to be used in the beacon identifier")}).optional().describe("Beacon Id parameters with an identifier and major and minor versions")}).optional()).optional(),Mp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({serial:e.Yj().describe("The serial of a device")})}),Fp=e.Vx(),Gp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({addAtomically:e.zM().optional().optional().describe("Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true.")}),body:e.Ik({serials:e.YO(e.Yj().optional()).describe("A list of serials of devices to claim"),detailsByDevice:e.YO(e.Ik({serial:e.Yj().describe("The serial of the device these details relate to"),details:e.YO(e.Ik({name:e.Yj().describe("Name of device detail"),value:e.Yj().optional().optional().describe("Value of device detail")})).describe("An array of details")})).optional().optional().describe("Optional details for claimed devices (currently only used for Catalyst devices)")})}),Bp=e.Ik({serials:e.YO(e.Yj().optional()).optional().describe("The serials of the devices"),errors:e.YO(e.Ik({serial:e.Yj().describe("The serial of the device"),errors:e.YO(e.Yj().optional()).describe("The errors for the device")})).optional().describe("Errors for devices that were not added")}).optional(),qp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({size:e.k5(["100","large","medium","small","xlarge"]).describe("The size of the vMX you claim. It can be one of: small, medium, large, xlarge, 100")})}),Vp=e.Ik({name:e.Yj().optional().describe("Name of the device"),lat:e.ai().optional().describe("Latitude of the device"),lng:e.ai().optional().describe("Longitude of the device"),address:e.Yj().optional().describe("Physical address of the device"),notes:e.Yj().optional().describe("Notes for the device, limited to 255 characters"),tags:e.YO(e.Yj().optional()).optional().describe("List of tags assigned to the device"),networkId:e.Yj().optional().describe("ID of the network the device belongs to"),serial:e.Yj().optional().describe("Serial number of the device"),model:e.Yj().optional().describe("Model of the device"),imei:e.Yj().optional().describe("IMEI of the device, if applicable"),mac:e.Yj().optional().describe("MAC address of the device"),lanIp:e.Yj().optional().describe("LAN IP address of the device"),firmware:e.Yj().optional().describe("Firmware version of the device"),productType:e.Yj().optional().describe("Product type of the device"),details:e.YO(e.Ik({name:e.Yj().optional().describe("Additional property name"),value:e.Yj().optional().describe("Additional property value")}).optional()).optional().describe("Additional device information")}).optional(),Ep=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),_p=e.Ik({id:e.Yj().optional().describe("Network ID"),organizationId:e.Yj().optional().describe("Organization ID"),name:e.Yj().optional().describe("Network name"),productTypes:e.YO(e.Yj().optional()).optional().describe("List of the product types that the network supports"),timeZone:e.Yj().optional().describe("Timezone of the network"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags"),enrollmentString:e.Yj().optional().describe("Enrollment string for the network"),url:e.Yj().optional().describe("URL to the network Dashboard UI"),notes:e.Yj().optional().describe("Notes for the network"),isBoundToConfigTemplate:e.zM().optional().describe("If the network is bound to a config template")}).optional(),Up=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({name:e.Yj().optional().describe("The name of the network"),timeZone:e.Yj().optional().describe("The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>"),tags:e.YO(e.Yj().optional()).optional().describe("A list of tags to be applied to the network"),enrollmentString:e.Yj().optional().describe("A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break."),notes:e.Yj().optional().describe("Add any notes or additional information about this network here.")}).optional()}),Hp=e.Ik({id:e.Yj().optional().describe("Network ID"),organizationId:e.Yj().optional().describe("Organization ID"),name:e.Yj().optional().describe("Network name"),productTypes:e.YO(e.Yj().optional()).optional().describe("List of the product types that the network supports"),timeZone:e.Yj().optional().describe("Timezone of the network"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags"),enrollmentString:e.Yj().optional().describe("Enrollment string for the network"),url:e.Yj().optional().describe("URL to the network Dashboard UI"),notes:e.Yj().optional().describe("Notes for the network"),isBoundToConfigTemplate:e.zM().optional().describe("If the network is bound to a config template")}).optional(),Qp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),Wp=e.Vx(),Kp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),Xp=e.Ik({resultingNetworks:e.YO(e.Ik({id:e.Yj().optional().describe("Network ID"),organizationId:e.Yj().optional().describe("Organization ID"),name:e.Yj().optional().describe("Network name"),productTypes:e.YO(e.Yj().optional()).optional().describe("List of the product types that the network supports"),timeZone:e.Yj().optional().describe("Timezone of the network"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags"),enrollmentString:e.Yj().optional().describe("Enrollment string for the network"),url:e.Yj().optional().describe("URL to the network Dashboard UI"),notes:e.Yj().optional().describe("Notes for the network"),isBoundToConfigTemplate:e.zM().optional().describe("If the network is bound to a config template")}).optional()).optional().describe("Networks after the split")}).optional(),Jp=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({configTemplateId:e.Yj().describe("The ID of the template to which the network should be bound."),autoBind:e.zM().optional().optional().describe("Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.")})}),Zp=e.Ik({id:e.Yj().optional().describe("Network ID"),organizationId:e.Yj().optional().describe("Organization ID"),name:e.Yj().optional().describe("Network name"),productTypes:e.YO(e.Yj().optional()).optional().describe("List of the product types that the network supports"),timeZone:e.Yj().optional().describe("Timezone of the network"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags"),enrollmentString:e.Yj().optional().describe("Enrollment string for the network"),url:e.Yj().optional().describe("URL to the network Dashboard UI"),notes:e.Yj().optional().describe("Notes for the network"),isBoundToConfigTemplate:e.zM().optional().describe("If the network is bound to a config template"),configTemplateId:e.Yj().optional().describe("ID of the config template the network is being bound to")}).optional(),$p=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({retainConfigs:e.zM().optional().describe("Optional boolean to retain all the current configs given by the template.")}).optional()}),eu=e.Ik({id:e.Yj().optional().describe("Network ID"),organizationId:e.Yj().optional().describe("Organization ID"),name:e.Yj().optional().describe("Network name"),productTypes:e.YO(e.Yj().optional()).optional().describe("List of the product types that the network supports"),timeZone:e.Yj().optional().describe("Timezone of the network"),tags:e.YO(e.Yj().optional()).optional().describe("Network tags"),enrollmentString:e.Yj().optional().describe("Enrollment string for the network"),url:e.Yj().optional().describe("URL to the network Dashboard UI"),notes:e.Yj().optional().describe("Notes for the network"),isBoundToConfigTemplate:e.zM().optional().describe("If the network is bound to a config template")}).optional(),tu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 30 days from today."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days."),deviceType:e.k5(["appliance","combined","switch","wireless"]).optional().optional().describe("Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage.")})}),iu=e.YO(e.Ik({application:e.Yj().optional().describe("Traffic application"),destination:e.Yj().optional().describe("Traffic destination"),protocol:e.Yj().optional().describe("Traffic protocol"),port:e.ai().int().optional().describe("Traffic port"),sent:e.ai().optional().describe("Traffic sent in kb"),recv:e.ai().optional().describe("Traffic received in kb"),numClients:e.ai().int().optional().describe("Number of clients with traffic"),activeTime:e.ai().int().optional().describe("Active time with traffic"),flows:e.ai().int().optional().describe("Number of traffic flows")}).optional()).optional(),ou=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")})}),ru=e.YO(e.Ik({}).optional()).optional(),nu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 791 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 791 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day."),resolution:e.ai().int().optional().optional().describe("The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.")})}),au=e.YO(e.Ik({t0:e.ai().int().optional().describe("The latency history bucket start time in seconds"),t1:e.ai().int().optional().describe("The latency history bucket end time in seconds"),latencyBinsByCategory:e.Ik({backgroundTraffic:e.Ik({.5:e.ai().int().optional().describe("The latency bucket for background traffic in 0.5 seconds"),"1.0":e.ai().int().optional().describe("The latency bucket for background traffic in 1.0 seconds"),"2.0":e.ai().int().optional().describe("The latency bucket for background traffic in 2.0 seconds"),"4.0":e.ai().int().optional().describe("The latency bucket for background traffic in 4.0 seconds"),"8.0":e.ai().int().optional().describe("The latency bucket for background traffic in 8.0 seconds"),"16.0":e.ai().int().optional().describe("The latency bucket for background traffic in 16.0 seconds"),"32.0":e.ai().int().optional().describe("The latency bucket for background traffic in 32.0 seconds"),"64.0":e.ai().int().optional().describe("The latency bucket for background traffic in 64.0 seconds"),"128.0":e.ai().int().optional().describe("The latency bucket for background traffic in 128.0 seconds"),"256.0":e.ai().int().optional().describe("The latency bucket for background traffic in 256.0 seconds"),"512.0":e.ai().int().optional().describe("The latency bucket for background traffic in 512.0 seconds"),"1024.0":e.ai().int().optional().describe("The latency bucket for background traffic in 1024.0 seconds"),"2048.0":e.ai().int().optional().describe("The latency bucket for background traffic in 2048.0 seconds")}).optional().describe("The time bucket's background traffic latency history"),bestEffortTraffic:e.Ik({.5:e.ai().int().optional().describe("The latency bucket for best effort traffic in 0.5 seconds"),"1.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 1.0 seconds"),"2.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 2.0 seconds"),"4.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 4.0 seconds"),"8.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 8.0 seconds"),"16.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 16.0 seconds"),"32.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 32.0 seconds"),"64.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 64.0 seconds"),"128.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 128.0 seconds"),"256.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 256.0 seconds"),"512.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 512.0 seconds"),"1024.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 1024.0 seconds"),"2048.0":e.ai().int().optional().describe("The latency bucket for best effort traffic in 2048.0 seconds")}).optional().describe("The time bucket's best effort traffic latency history"),videoTraffic:e.Ik({.5:e.ai().int().optional().describe("The latency bucket for video traffic in 0.5 seconds"),"1.0":e.ai().int().optional().describe("The latency bucket for video traffic in 1.0 seconds"),"2.0":e.ai().int().optional().describe("The latency bucket for video traffic in 2.0 seconds"),"4.0":e.ai().int().optional().describe("The latency bucket for video traffic in 4.0 seconds"),"8.0":e.ai().int().optional().describe("The latency bucket for video traffic in 8.0 seconds"),"16.0":e.ai().int().optional().describe("The latency bucket for video traffic in 16.0 seconds"),"32.0":e.ai().int().optional().describe("The latency bucket for video traffic in 32.0 seconds"),"64.0":e.ai().int().optional().describe("The latency bucket for video traffic in 64.0 seconds"),"128.0":e.ai().int().optional().describe("The latency bucket for video traffic in 128.0 seconds"),"256.0":e.ai().int().optional().describe("The latency bucket for video traffic in 256.0 seconds"),"512.0":e.ai().int().optional().describe("The latency bucket for video traffic in 512.0 seconds"),"1024.0":e.ai().int().optional().describe("The latency bucket for video traffic in 1024.0 seconds"),"2048.0":e.ai().int().optional().describe("The latency bucket for video traffic in 2048.0 seconds")}).optional().describe("The time bucket's video traffic latency history"),voiceTraffic:e.Ik({.5:e.ai().int().optional().describe("The latency bucket for voice traffic in 0.5 seconds"),"1.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 1.0 seconds"),"2.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 2.0 seconds"),"4.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 4.0 seconds"),"8.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 8.0 seconds"),"16.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 16.0 seconds"),"32.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 32.0 seconds"),"64.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 64.0 seconds"),"128.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 128.0 seconds"),"256.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 256.0 seconds"),"512.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 512.0 seconds"),"1024.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 1024.0 seconds"),"2048.0":e.ai().int().optional().describe("The latency bucket for voice traffic in 2048.0 seconds")}).optional().describe("The time bucket's voice traffic latency history")}).optional().describe("The latency buckets by category")}).optional()).optional(),su=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),sortOrder:e.k5(["ascending","descending"]).optional().optional().describe("Sorted order of entries. Order options are 'ascending' and 'descending'. Default is 'ascending'."),t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 31 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day."),types:e.YO(e.k5(["assoc","auth","connection","deauth","dhcp","disassoc","dns","roam","sticky"]).optional()).optional().optional().describe("A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'."),band:e.k5(["2.4","5","6"]).optional().optional().describe("Filter results by band. Valid bands are '2.4', '5' or '6'."),ssidNumber:e.ai().int().optional().optional().describe("Filter results by SSID. If not specified, events for all SSIDs will be returned."),includedSeverities:e.YO(e.k5(["bad","good","info","warn"]).optional()).optional().optional().describe("A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'."),deviceSerial:e.Yj().optional().optional().describe("Filter results by an AP's serial number.")})}),du=e.YO(e.Ik({occurredAt:e.Yj().optional().describe("Timestamp at which the event occurred"),band:e.k5(["2.4","5","6"]).optional().describe("Wireless band the event occurred on"),ssidNumber:e.ai().int().optional().describe("Number of the SSID the event occurred in"),type:e.k5(["assoc","auth","connection","deauth","dhcp","disassoc","dns","roam","sticky"]).optional().describe("Event type"),subtype:e.Yj().optional().describe("Event subtype"),severity:e.Yj().optional().describe("Event severity"),durationMs:e.ai().int().optional().describe("Duration of the event in milliseconds"),channel:e.ai().int().optional().describe("Wireless channel the event occurred over"),rssi:e.ai().int().optional().describe("RSSI recorded at the time of the event"),eventData:e.Ik({}).optional().describe("Additional information relevant to the given event. Properties vary based on event type."),deviceSerial:e.Yj().optional().describe("Serial number of the device the event occurred for"),captureId:e.Yj().optional().describe("Id of the packet capture triggered for the event, if any")}).optional()).optional(),lu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day."),perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),getInternalData:e.zM().optional().optional().describe("Provide extra fields in response to render the Clients List page. The additional data should not be available to customers."),clientsOptimizedQuery:e.zM().optional().optional().describe("Parameter to denote the use of optimized queries."),ssidNumber:e.ai().int().optional().optional().describe("Filter clients that were seen on an SSID. Does not support MX Wireless SSIDs."),statuses:e.YO(e.k5(["Offline","Online"]).optional()).optional().optional().describe("Filters clients based on status. Can be one of 'Online' or 'Offline'."),ip:e.Yj().optional().optional().describe("Filters clients based on a partial or full match for the ip address field."),ip6:e.Yj().optional().optional().describe("Filters clients based on a partial or full match for the ip6 address field."),ip6Local:e.Yj().optional().optional().describe("Filters clients based on a partial or full match for the ip6Local address field."),mac:e.Yj().optional().optional().describe("Filters clients based on a partial or full match for the mac address field."),os:e.Yj().optional().optional().describe("Filters clients based on a partial or full match for the os (operating system) field."),pskGroup:e.Yj().optional().optional().describe("Filters clients based on partial or full match for the iPSK name field."),description:e.Yj().optional().optional().describe("Filters clients based on a partial or full match for the description field."),vlan:e.Yj().optional().optional().describe("Filters clients based on the full match for the VLAN field."),namedVlan:e.Yj().optional().optional().describe("Filters clients based on the partial or full match for the named VLAN field."),recentDeviceConnections:e.YO(e.k5(["Wired","Wireless"]).optional()).optional().optional().describe("Filters clients based on recent connection type. Can be one of 'Wired' or 'Wireless'."),policyAssigned:e.zM().optional().optional().describe("When true, returns only clients with a policy. Otherwise it behaves the same as there is no policyAssigned param"),clientTypes:e.YO(e.k5(["clientVpn"]).optional()).optional().optional().describe("Filter clients based on their type. Can be one of 'clientVpn'.")})}),cu=e.YO(e.Ik({id:e.Yj().optional().describe("The ID of the client"),mac:e.Yj().optional().describe("The MAC address of the client"),ip:e.Yj().optional().describe("The IP address of the client"),ip6:e.Yj().optional().describe("The IPv6 address of the client"),description:e.Yj().optional().describe("Short description of the client"),firstSeen:e.ai().int().optional().describe("Timestamp client was first seen in the network"),lastSeen:e.ai().int().optional().describe("Timestamp client was last seen in the network"),manufacturer:e.Yj().optional().describe("Manufacturer of the client"),os:e.Yj().optional().describe("The operating system of the client"),user:e.Yj().optional().describe("The username of the user of the client"),vlan:e.Yj().optional().describe("The name of the VLAN that the client is connected to"),ssid:e.Yj().optional().describe("The name of the SSID that the client is connected to"),switchport:e.Yj().optional().describe("The switch port that the client is connected to"),wirelessCapabilities:e.Yj().optional().describe("Wireless capabilities of the client"),smInstalled:e.zM().optional().describe("Status of SM for the client"),recentDeviceMac:e.Yj().optional().describe("The MAC address of the node that the device was last connected to"),status:e.k5(["Offline","Online"]).optional().describe("The connection status of the client"),usage:e.Ik({sent:e.ai().optional().describe("Usage sent by the client"),recv:e.ai().optional().describe("Usage received by the client")}).optional().describe("Usage, sent and received"),namedVlan:e.Yj().optional().describe("Named VLAN of the client"),adaptivePolicyGroup:e.Yj().optional().describe("The adaptive policy group of the client"),deviceTypePrediction:e.Yj().optional().describe("Prediction of the client's device type"),recentDeviceSerial:e.Yj().optional().describe("The serial of the node the device was last connected to"),recentDeviceName:e.Yj().optional().describe("The name of the node the device was last connected to"),recentDeviceConnection:e.k5(["Wired","Wireless"]).optional().describe("Client's most recent connection type"),notes:e.Yj().optional().describe("Notes on the client"),ip6Local:e.Yj().optional().describe("Local IPv6 address of the client"),groupPolicy8021x:e.Yj().optional().describe("802.1x group policy of the client"),pskGroup:e.Yj().optional().describe("iPSK name of the client"),smAnyConnectAppVersion:e.Yj().optional().describe("App version of Cisco AnyConnect"),smOsVersion:e.Yj().optional().describe("Operating system version of client"),smSerialNumber:e.Yj().optional().describe("Serial number of client"),lastMDMCheckin:e.Yj().optional().describe("Last MDM checkin of client"),ownerUsername:e.Yj().optional().describe("SM username of the client"),ownerEmail:e.Yj().optional().describe("SM owner of the client"),ownerFullname:e.Yj().optional().describe("Name of SM owner of the client"),isTrustedAccessDevice:e.zM().optional().describe("Status of Trusted Access on the client")}).optional()).optional(),pu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({clients:e.YO(e.Ik({mac:e.Yj().describe("The MAC address of the client. Required."),name:e.Yj().optional().optional().describe("The display name for the client. Optional. Limited to 255 bytes."),message:e.Yj().optional().optional().describe(`For clients with 'devicePolicy' set to "Blocked", this will be the display message. Optional.`)})).describe("The array of clients to provision"),devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal","Per connection"]).describe("The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`),policiesBySecurityAppliance:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Normal"]).optional().describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.")}).optional().optional().describe("An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)"),policiesBySsid:e.Ik({0:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),1:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),2:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),3:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),4:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),5:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),6:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),7:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),8:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),9:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),10:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),11:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),12:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),13:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID"),14:e.Ik({devicePolicy:e.k5(["Allowed","Blocked","Group policy","Normal"]).describe("The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe(`The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.`)}).describe("The number for the SSID")}).optional().optional().describe("An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy")})}),uu=e.Ik({clients:e.YO(e.Ik({mac:e.Yj().optional().describe("The MAC address of the client"),clientId:e.Yj().optional().describe("The identifier of the client"),name:e.Yj().optional().describe("The name of the client"),message:e.Yj().optional().describe("The client's display message if its group policy is 'Blocked'")}).optional()).optional().describe("The list of clients to provision"),devicePolicy:e.Yj().optional().describe("The name of the client's policy"),groupPolicyId:e.Yj().optional().describe("The group policy identifier of the client")}).optional(),hu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 30 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 31 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day."),perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")})}),bu=e.YO(e.Ik({ts:e.Yj().optional().describe("The timestamp"),total:e.ai().optional().describe("The total traffic over a time range for clients on a network"),upstream:e.ai().optional().describe("The upstream traffic over a time range for clients on a network"),downstream:e.ai().optional().describe("The downstream traffic over a time range for clients on a network")}).optional()).optional(),fu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")})}),mu=e.YO(e.Ik({received:e.ai().optional().describe("Usage received by the client on a given day"),sent:e.ai().optional().describe("Usage sent by the client on a given day"),ts:e.Yj().optional().describe("The day's timestamp")}).optional()).optional(),gu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")})}),Iu=e.YO(e.Ik({ts:e.Yj().optional().describe("The start time from which daily traffic data was collected"),application:e.Yj().optional().describe("The name of the application the client is connected to"),destination:e.Yj().optional().describe("The IP or web address the client is connected to"),protocol:e.Yj().optional().describe("The client protocol"),port:e.ai().int().optional().describe("The port the client is connected to"),recv:e.ai().optional().describe("Usage received by the client"),sent:e.ai().optional().describe("Usage sent by the client"),numFlows:e.ai().int().optional().describe("The number of flows the client has"),activeSeconds:e.ai().int().optional().describe("The amount of seconds the client was active")}).optional()).optional(),vu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 31 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day."),resolution:e.ai().int().optional().optional().describe("The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800.")})}),yu=e.Ik({counts:e.Ik({total:e.ai().int().optional().describe("The total number of clients on a network"),withHeavyUsage:e.ai().int().optional().describe("The total number of clients with heavy usage on a network")}).optional().describe("The number of clients on a network over a given time range"),usages:e.Ik({average:e.ai().int().optional().describe("The average usage of all clients on a network in kilobytes"),withHeavyUsageAverage:e.ai().int().optional().describe("The average usage of all clients with heavy usage on a network in kilobytes")}).optional().describe("The average usage of the clients on a network over a given time range")}).optional(),ku=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")}),query:e.Ik({getInternalData:e.zM().optional().optional().describe("Provide extra fields in response to render the Client Details page. The additional data should not be available to customers.")})}),wu=e.Ik({id:e.Yj().optional().describe("The ID of the client"),mac:e.Yj().optional().describe("The MAC address of the client"),ip:e.Yj().optional().describe("The IP address of the client"),ip6:e.Yj().optional().describe("The IPv6 address of the client"),description:e.Yj().optional().describe("Short description of the client"),firstSeen:e.ai().int().optional().describe("Timestamp client was first seen in the network"),lastSeen:e.ai().int().optional().describe("Timestamp client was last seen in the network"),manufacturer:e.Yj().optional().describe("Manufacturer of the client"),os:e.Yj().optional().describe("The operating system of the client"),user:e.Yj().optional().describe("The username of the user of the client"),vlan:e.Yj().optional().describe("The client-assigned name of the VLAN the client is connected to"),namedVlan:e.Yj().optional().describe("The owner-assigned name of the VLAN the client is connected to"),ssid:e.Yj().optional().describe("The name of the SSID that the client is connected to"),switchport:e.Yj().optional().describe("The switch port that the client is connected to"),wirelessCapabilities:e.Yj().optional().describe("Wireless capabilities of the client"),smInstalled:e.zM().optional().describe("Status of SM for the client"),recentDeviceMac:e.Yj().optional().describe("The MAC address of the node that the device was last connected to"),recentDeviceName:e.Yj().optional().describe("The name of the node that the device was last connected to"),recentDeviceSerial:e.Yj().optional().describe("The serial of the node that the device was last connected to"),recentDeviceConnection:e.k5(["Wired","Wireless"]).optional().describe("Client's most recent connection type"),clientVpnConnections:e.YO(e.Ik({remoteIp:e.Yj().optional().describe("The IP address of the VPN the client last connected to"),connectedAt:e.ai().int().optional().describe("The time the client last connected to the VPN"),disconnectedAt:e.ai().int().optional().describe("The time the client last disconnectd from the VPN")}).optional()).optional().describe("VPN connections associated with the client"),lldp:e.YO(e.YO(e.Yj().optional()).optional()).optional().describe("The link layer discover protocol settings for the client"),cdp:e.YO(e.YO(e.Yj().optional()).optional()).optional().describe("The Cisco discover protocol settings for the client"),status:e.k5(["Offline","Online"]).optional().describe("The connection status of the client"),notes:e.Yj().optional().describe("The notes associated with the client"),deviceTypePrediction:e.Yj().optional().describe("Prediction of the client's device type")}).optional(),ju=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")}),body:e.Ik({getInternalData:e.zM().optional().describe("Provide extra fields in response to render the Client Details page. The additional data should not be available to customers."),notes:e.Yj().optional().describe("The value to update the client notes to."),description:e.Yj().optional().describe("The value to update the client description to.")}).optional()}),Yu=e.Ik({id:e.Yj().optional().describe("The ID of the client"),mac:e.Yj().optional().describe("The MAC address of the client"),ip:e.Yj().optional().describe("The IP address of the client"),ip6:e.Yj().optional().describe("The IPv6 address of the client"),description:e.Yj().optional().describe("Short description of the client"),firstSeen:e.ai().int().optional().describe("Timestamp client was first seen in the network"),lastSeen:e.ai().int().optional().describe("Timestamp client was last seen in the network"),manufacturer:e.Yj().optional().describe("Manufacturer of the client"),os:e.Yj().optional().describe("The operating system of the client"),user:e.Yj().optional().describe("The username of the user of the client"),vlan:e.Yj().optional().describe("The client-assigned name of the VLAN the client is connected to"),namedVlan:e.Yj().optional().describe("The owner-assigned name of the VLAN the client is connected to"),ssid:e.Yj().optional().describe("The name of the SSID that the client is connected to"),switchport:e.Yj().optional().describe("The switch port that the client is connected to"),wirelessCapabilities:e.Yj().optional().describe("Wireless capabilities of the client"),smInstalled:e.zM().optional().describe("Status of SM for the client"),recentDeviceMac:e.Yj().optional().describe("The MAC address of the node that the device was last connected to"),recentDeviceName:e.Yj().optional().describe("The name of the node that the device was last connected to"),recentDeviceSerial:e.Yj().optional().describe("The serial of the node that the device was last connected to"),recentDeviceConnection:e.k5(["Wired","Wireless"]).optional().describe("Client's most recent connection type"),clientVpnConnections:e.YO(e.Ik({remoteIp:e.Yj().optional().describe("The IP address of the VPN the client last connected to"),connectedAt:e.ai().int().optional().describe("The time the client last connected to the VPN"),disconnectedAt:e.ai().int().optional().describe("The time the client last disconnectd from the VPN")}).optional()).optional().describe("VPN connections associated with the client"),lldp:e.YO(e.YO(e.Yj().optional()).optional()).optional().describe("The link layer discover protocol settings for the client"),cdp:e.YO(e.YO(e.Yj().optional()).optional()).optional().describe("The Cisco discover protocol settings for the client"),status:e.k5(["Offline","Online"]).optional().describe("The connection status of the client"),notes:e.Yj().optional().describe("The notes associated with the client"),deviceTypePrediction:e.Yj().optional().describe("Prediction of the client's device type")}).optional(),Tu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")})}),Pu=e.Ik({mac:e.Yj().optional().describe("The MAC address of the client"),devicePolicy:e.Yj().optional().describe("The name of the client's policy"),groupPolicyId:e.Yj().optional().describe("The group policy identifier of the client"),policiesBySsid:e.YO(e.Ik({ssidNumber:e.ai().int().optional().describe("The SSID number for the policy rule"),devicePolicy:e.Yj().optional().describe("The device policy applied to the client for this SSID"),groupPolicyId:e.Yj().optional().describe("The group policy identifier for this SSID")}).optional()).optional().describe("The policies applied to the client by SSID")}).optional(),Ou=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")}),body:e.Ik({devicePolicy:e.Yj().describe("The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required."),groupPolicyId:e.Yj().optional().optional().describe("[Optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID.")})}),Su=e.Ik({mac:e.Yj().optional().describe("The MAC address of the client"),devicePolicy:e.Yj().optional().describe("The name of the client's policy"),groupPolicyId:e.Yj().optional().describe("The group policy identifier of the client"),policiesBySsid:e.YO(e.Ik({ssidNumber:e.ai().int().optional().describe("The SSID number for the policy rule"),devicePolicy:e.Yj().optional().describe("The device policy applied to the client for this SSID"),groupPolicyId:e.Yj().optional().describe("The group policy identifier for this SSID")}).optional()).optional().describe("The policies applied to the client by SSID")}).optional(),Du=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 31 days.")})}),Ru=e.YO(e.Ik({}).optional()).optional(),zu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({clients:e.Yj().describe("A list of client keys, MACs or IPs separated by comma."),ssidNumber:e.ai().int().optional().optional().describe("An SSID number to include. If not specified, events for all SSIDs will be returned."),perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 31 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.")})}),Au=e.YO(e.Ik({}).optional()).optional(),xu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({clients:e.Yj().describe("A list of client keys, MACs or IPs separated by comma."),ssidNumber:e.ai().int().optional().optional().describe("An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned."),perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 31 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.")})}),Nu=e.YO(e.Ik({}).optional()).optional(),Cu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")}),query:e.Ik({includeAllSplashTypes:e.zM().optional().optional().describe("Include all SSIDs and VLANs that a client has been associated to, not just SSIDs with Click-through splash enabled. Defaults to false.")})}),Lu=e.Ik({}).optional(),Mu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),clientId:e.Yj().describe("Client ID")}),body:e.Ik({ssids:e.Ik({0:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 0"),1:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 1"),2:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 2"),3:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 3"),4:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 4"),5:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 5"),6:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 6"),7:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 7"),8:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 8"),9:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 9"),10:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 10"),11:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 11"),12:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 12"),13:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 13"),14:e.Ik({isAuthorized:e.zM().optional().describe("New authorization status for the SSID (true, false).")}).optional().describe("Splash authorization for SSID 14")}).describe("The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs")})}),Fu=e.Ik({}).optional(),Gu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")})}),Bu=e.Ik({upgradeWindow:e.Ik({dayOfWeek:e.k5(["fri","friday","mon","monday","sat","saturday","sun","sunday","thu","thursday","tue","tuesday","wed","wednesday"]).optional().describe("Day of the week"),hourOfDay:e.k5(["0:00","10:00","11:00","12:00","13:00","14:00","15:00","16:00","17:00","18:00","19:00","1:00","20:00","21:00","22:00","23:00","2:00","3:00","4:00","5:00","6:00","7:00","8:00","9:00"]).optional().describe("Hour of the day")}).optional().describe("Upgrade window for devices in network"),timezone:e.Yj().optional().describe("The timezone for the network"),products:e.Ik({wireless:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),upgradeStrategy:e.k5(["minimizeClientDowntime","minimizeUpgradeTime"]).optional().describe("The strategy that network devices will use to perform the upgrade. If unspecified, the scheduled upgrade will use the default strategy for the network."),predownloadFirmware:e.zM().optional().describe("Whether or not the network devices will predownload the firmware image in advance of the actual upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),appliance:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),switch:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware"),postponeInitialDeviceUpgrade:e.Ik({enabled:e.zM().optional().describe("Whether or not the network has enabled the setting")}).optional().describe("The network setting to postpone initial firmware upgrades to the maintenance window")}).optional().describe("The network device to be updated"),camera:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),cellularGateway:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),sensor:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),wirelessController:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),campusGateway:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),secureConnect:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated")}).optional().describe("The network devices to be updated")}).optional(),qu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({upgradeWindow:e.Ik({dayOfWeek:e.k5(["fri","friday","mon","monday","sat","saturday","sun","sunday","thu","thursday","tue","tuesday","wed","wednesday"]).optional().describe("Day of the week"),hourOfDay:e.k5(["0:00","10:00","11:00","12:00","13:00","14:00","15:00","16:00","17:00","18:00","19:00","1:00","20:00","21:00","22:00","23:00","2:00","3:00","4:00","5:00","6:00","7:00","8:00","9:00"]).optional().describe("Hour of the day")}).optional().describe("Upgrade window for devices in network"),timezone:e.Yj().optional().describe("The timezone for the network"),products:e.Ik({wireless:e.Ik({nextUpgrade:e.Ik({upgradeStrategy:e.k5(["minimizeClientDowntime","minimizeUpgradeTime"]).optional().describe("The strategy that network devices will use to perform the upgrade. If unspecified, the scheduled upgrade will use the default strategy for the network."),predownloadFirmware:e.zM().optional().describe("Whether or not the network devices will predownload the firmware image in advance of the actual upgrade"),time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),appliance:e.Ik({nextUpgrade:e.Ik({time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),switch:e.Ik({nextUpgrade:e.Ik({time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware"),postponeInitialDeviceUpgrade:e.Ik({enabled:e.zM().optional().describe("Whether or not the network has enabled the setting")}).optional().describe("The network setting to postpone initial firmware upgrades to the maintenance window")}).optional().describe("The network device to be updated"),camera:e.Ik({nextUpgrade:e.Ik({time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),cellularGateway:e.Ik({nextUpgrade:e.Ik({time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),sensor:e.Ik({nextUpgrade:e.Ik({time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),wirelessController:e.Ik({nextUpgrade:e.Ik({time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),campusGateway:e.Ik({nextUpgrade:e.Ik({upgradeStrategy:e.k5(["minimizeClientDowntime","minimizeUpgradeTime"]).optional().describe("The strategy that network devices will use to perform the upgrade. If unspecified, the scheduled upgrade will use the default strategy for the network."),predownloadFirmware:e.zM().optional().describe("Whether or not the network devices will predownload the firmware image in advance of the actual upgrade"),time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),secureConnect:e.Ik({nextUpgrade:e.Ik({time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),switchCatalyst:e.Ik({nextUpgrade:e.Ik({time:e.Yj().optional().describe("The time of the last successful upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("The version ID")}).optional().describe("The version to be updated to"),useIssu:e.zM().optional().describe("Attempt upgrade using ISSU")}).optional().describe("The pending firmware upgrade if it exists"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated")}).optional().describe("Contains information about the network to update")}).optional()}),Vu=e.Ik({upgradeWindow:e.Ik({dayOfWeek:e.k5(["fri","friday","mon","monday","sat","saturday","sun","sunday","thu","thursday","tue","tuesday","wed","wednesday"]).optional().describe("Day of the week"),hourOfDay:e.k5(["0:00","10:00","11:00","12:00","13:00","14:00","15:00","16:00","17:00","18:00","19:00","1:00","20:00","21:00","22:00","23:00","2:00","3:00","4:00","5:00","6:00","7:00","8:00","9:00"]).optional().describe("Hour of the day")}).optional().describe("Upgrade window for devices in network"),timezone:e.Yj().optional().describe("The timezone for the network"),products:e.Ik({wireless:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),upgradeStrategy:e.k5(["minimizeClientDowntime","minimizeUpgradeTime"]).optional().describe("The strategy that network devices will use to perform the upgrade. If unspecified, the scheduled upgrade will use the default strategy for the network."),predownloadFirmware:e.zM().optional().describe("Whether or not the network devices will predownload the firmware image in advance of the actual upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),appliance:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),switch:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware"),postponeInitialDeviceUpgrade:e.Ik({enabled:e.zM().optional().describe("Whether or not the network has enabled the setting")}).optional().describe("The network setting to postpone initial firmware upgrades to the maintenance window")}).optional().describe("The network device to be updated"),camera:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),cellularGateway:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),sensor:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),wirelessController:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),campusGateway:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated"),secureConnect:e.Ik({currentVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the current version on the device"),lastUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the last successful firmware upgrade"),fromVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded from"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device upgraded to")}).optional().describe("Details of the last firmware upgrade on the device"),nextUpgrade:e.Ik({time:e.Yj().optional().describe("Timestamp of the next scheduled firmware upgrade"),toVersion:e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional().describe("Details of the version the device will upgrade to if it exists")}).optional().describe("Details of the next firmware upgrade on the device"),isUpgradeAvailable:e.zM().optional().describe("Whether or not an upgraded firmware version is available"),availableVersions:e.YO(e.Ik({id:e.Yj().optional().describe("Firmware version identifier"),firmware:e.Yj().optional().describe("Name of the firmware version"),shortName:e.Yj().optional().describe("Firmware version short name"),releaseType:e.Yj().optional().describe("Release type of the firmware version"),releaseDate:e.Yj().optional().describe("Release date of the firmware version")}).optional()).optional().describe("Firmware versions available for upgrade"),participateInNextBetaRelease:e.zM().optional().describe("Whether or not the network wants beta firmware")}).optional().describe("The network device to be updated")}).optional().describe("The network devices to be updated")}).optional(),Yo=k.v1.enhanceEndpoints({addTagTypes:[se.BX]}).injectEndpoints({endpoints:function(s){var n=s.query;return{fetchNetworkSwitchLinkAggregations:n({query:function(t){var i=t.path.networkId;return"networks/".concat(i,"/switch/linkAggregations")},transformResponse:(0,Ae._j)(ko,"networks/:networkId/switch/linkAggregations"),providesTags:[se.BX]})}}}),Eu=Yo.useFetchNetworkSwitchLinkAggregationsQuery,ei=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Nt=e.Ay.object({rendezvousPointId:e.Ay.string(),interfaceIp:e.Ay.string(),multicastGroup:e.Ay.string(),serial:e.Ay.string().optional(),switchStackId:e.Ay.string().optional(),interfaceName:e.Ay.string().optional(),vrf:e.Ay.object({name:e.Ay.string().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings")}),To=e.Ay.array(Nt),Po=["create","destroy","update"],Oo=e.Ay.object({resource:e.Ay.string(),operation:e.Ay.enum(Po)}),So=e.Ay.object({completed:e.Ay.boolean(),failed:e.Ay.boolean(),errors:e.Ay.array(e.Ay.string()),createdResources:e.Ay.array(e.Ay.any())}),Do=e.Ay.object({id:e.Ay.string(),organizationId:e.Ay.string(),confirmed:e.Ay.boolean(),synchronous:e.Ay.boolean(),status:So,actions:e.Ay.array(Oo)}),dt="RendezvousPointsTag",It=k.v1.enhanceEndpoints({addTagTypes:[dt]}).injectEndpoints({endpoints:function(s){var n=s.query,t=s.mutation;return{getNetworkRendezvousPoints:n({query:function(i){var a=i.networkId;return{url:"networks/".concat(a,"/switch/routing/multicast/rendezvousPoints")}},transformResponse:function(i,a,o){var l=To.safeParse(i);return l.success||console.warn("Invalid schema received for getNetworkRendezvousPoints",JSON.stringify(o),l.error),i},providesTags:[dt]}),createNetworkRendezvousPoint:t({query:function(i){var a=i.networkId,o=ei(i,["networkId"]);return{url:"networks/".concat(a,"/switch/routing/multicast/rendezvousPoints"),method:"POST",body:o}},transformResponse:function(i,a,o){var l=Nt.safeParse(i);return l.success||console.warn("Invalid schema received for createNetworkRendezvousPoint",JSON.stringify(o),l.error),i},invalidatesTags:[dt]}),updateNetworkRendezvousPoint:t({query:function(i){var a=i.networkId,o=i.rendezvousPointId,l=ei(i,["networkId","rendezvousPointId"]);return{url:"networks/".concat(a,"/switch/routing/multicast/rendezvousPoints/").concat(o),method:"PUT",body:l}},transformResponse:function(i,a,o){var l=Nt.safeParse(i);return l.success||console.warn("Invalid schema received for updateNetworkRendezvousPoint",JSON.stringify(o),l.error),i},invalidatesTags:[dt]}),bulkNetworkRendezvousPointDelete:t({query:function(i){var a=i.organizationId,o=i.networkId,l=i.rendezvousPointIds;return{url:"organizations/".concat(a,"/actionBatches"),method:"POST",body:{confirmed:!0,synchronous:!0,actions:l.map(function(u){return{resource:"/networks/".concat(o,"/switch/routing/multicast/rendezvousPoints/").concat(u),operation:"destroy"}})}}},transformResponse:function(i,a,o){var l=Do.safeParse(i);return l.success||console.warn("Invalid schema received for bulkNetworkRendezvousPointDelete",JSON.stringify(o),l.error),i},invalidatesTags:[dt]})}}}),_u=It.useGetNetworkRendezvousPointsQuery,Uu=It.useCreateNetworkRendezvousPointMutation,Hu=It.useUpdateNetworkRendezvousPointMutation,Qu=It.useBulkNetworkRendezvousPointDeleteMutation,Wu=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),query:e.Ik({vrf:e.Yj().optional().describe("The VRF to return the OSPF routing configuration for. When not provided, the default VRF is used.")})}),Ro=e.Ik({enabled:e.zM().optional().describe("Boolean value to enable or disable OSPF routing. OSPF routing is disabled by default."),helloTimerInSeconds:e.ai().int().optional().describe("Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds."),deadTimerInSeconds:e.ai().int().optional().describe("Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535"),areas:e.YO(e.Ik({areaId:e.Yj().optional().describe("OSPF area ID"),areaName:e.Yj().optional().describe("Name of the OSPF area"),areaType:e.k5(["normal","nssa","stub"]).optional().describe('Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]')})).optional().describe("OSPF areas"),v3:e.Ik({enabled:e.zM().optional().describe("Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default."),helloTimerInSeconds:e.ai().int().optional().describe("Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds."),deadTimerInSeconds:e.ai().int().optional().describe("Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535"),areas:e.YO(e.Ik({areaId:e.Yj().optional().describe("OSPF area ID"),areaName:e.Yj().optional().describe("Name of the OSPF area"),areaType:e.k5(["normal","nssa","stub"]).optional().describe('Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]')})).optional().describe("OSPF v3 areas")}).optional().describe("OSPF v3 configuration"),md5AuthenticationEnabled:e.zM().optional().describe("Boolean value to enable or disable MD5 authentication. MD5 authentication is disabled by default."),md5AuthenticationKey:e.Ik({id:e.ai().int().optional().describe("MD5 authentication key index. Key index must be between 1 to 255"),passphrase:e.Yj().optional().describe("MD5 authentication passphrase")}).optional().describe("MD5 authentication credentials. This param is only relevant if md5AuthenticationEnabled is true"),vrf:e.Ik({name:e.Yj().optional().describe("name of the VRF associated with the OSPF configuration")}).optional().describe("VRF setting of this OSPF")}).optional(),Ku=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID")}),body:e.Ik({switch:e.Ik({serial:e.Yj().optional().describe("The serial of the switch"),stackId:e.Yj().optional().describe("The id of the switch stack")}).describe("The switch or switch stack that the interface belongs to."),serial:e.Yj().optional().optional().describe("Serial of the Routed Port Switch in Stack. Required when in Routed mode along with switchPortId."),name:e.Yj().describe("A friendly name or description for the interface or VLAN (max length 128 characters)."),mode:e.k5(["loopback","oob_management","routed","vlan"]).optional().optional().describe("L3 Interface mode, can be one of 'vlan', 'routed', 'loopback'. Default is 'vlan'. CS 17.18 or higher is required for 'routed' mode."),subnet:e.Yj().optional().optional().describe("The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24)."),switchPortId:e.Yj().optional().optional().describe("Switch Port ID when in Routed mode (CS 17.18 or higher required)"),interfaceIp:e.Yj().optional().nullable().describe("The IP address that will be used for Layer 3 routing on this VLAN or subnet. This cannot be the same         as the device management IP."),multicastRouting:e.k5(["IGMP snooping querier","disabled","enabled"]).optional().optional().describe("Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'."),vlanId:e.ai().int().optional().optional().describe("The VLAN this L3 interface is on. VLAN must be between 1 and 4094."),defaultGateway:e.Yj().optional().optional().describe("The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a L3 interface. Required if this is the first IPv4 interface."),uplinkV4:e.zM().optional().optional().describe("When true, this interface is used as static IPv4 uplink."),candidateUplinkV4:e.zM().optional().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().optional().describe("When true, this interface is used as static IPv6 uplink."),staticV4Dns1:e.Yj().optional().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPF will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().optional().describe("The OSPF routing settings of the interface."),ospfV3:e.Ik({area:e.Yj().optional().describe("The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().optional().describe("The OSPFv3 routing settings of the interface."),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'."),prefix:e.Yj().optional().nullable().describe("The IPv6 prefix of the interface. Required if IPv6 object is included."),address:e.Yj().optional().nullable().describe("The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'."),gateway:e.Yj().optional().describe("The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured."),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().optional().describe("The IPv6 settings of the interface."),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to.")}).optional().optional().describe("The VRF settings of the interface. Requires IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("The loopback number")}).optional().optional().describe("The loopback settings of the interface."),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().optional().describe("VRRP configuration for the L3 interface.  This is only applicable to Catalyst switches"),dhcpMode:e.k5(["dhcpDisabled","dhcpRelay","dhcpServer"]).optional().optional().describe(`The DHCP mode options for the switch interface
       ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')`),dhcpRelayServerIps:e.YO(e.Yj().optional()).optional().optional().describe("The DHCP relay server IPs to which DHCP packets would get relayed for the switch interface"),dhcpLeaseTime:e.k5(["1 day","1 hour","1 week","12 hours","30 minutes","4 hours"]).optional().optional().describe(`The DHCP lease time config for the dhcp server running on switch interface
        ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')`),dhcpDefaultRouterOption:e.k5(["switch","custom"]).optional().describe("Whether to use this switch or custom IP addresses as the default gateway for DHCP clients."),dhcpDefaultRouterIps:e.Yj().optional().describe('IP address(es) of routers to use as default gateways when `dhcpDefaultRouterOption` is set to "custom".'),dhcpDomainName:e.Yj().optional().describe(`The "domain" portion of a node's Fully Qualified Domain Name (FQDN).`),dnsNameserversOption:e.k5(["custom","googlePublicDns","openDns"]).optional().optional().describe(`The DHCP name server option for the dhcp server running on the switch interface
        ('googlePublicDns', 'openDns' or 'custom')`),dnsCustomNameservers:e.YO(e.Yj().optional()).optional().optional().describe(`The DHCP name server IPs when DHCP name server option is
        'custom'`),bootOptionsEnabled:e.zM().optional().optional().describe(`Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch
        interface`),bootNextServer:e.Yj().optional().optional().describe("The PXE boot server IP for the DHCP server running on the switch interface"),bootFileName:e.Yj().optional().optional().describe("The PXE boot server filename for the DHCP server running on the switch interface"),dhcpOptions:e.YO(e.Ik({code:e.Yj().describe("The code for DHCP option which should be from 2 to 254"),type:e.k5(["hex","integer","ip","text"]).describe(`The type of the DHCP option which should be one of
          ('text', 'ip', 'integer' or 'hex')`),value:e.Yj().describe("The value of the DHCP option")})).optional().optional().describe("Array of DHCP options consisting of code, type and value for the DHCP server running on the switch interface"),reservedIpRanges:e.YO(e.Ik({start:e.Yj().describe("The starting IP address of the reserved IP range"),end:e.Yj().describe("The ending IP address of the reserved IP range"),comment:e.Yj().optional().optional().describe("The comment for the reserved IP range")})).optional().optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch interface"),fixedIpAssignments:e.YO(e.Ik({name:e.Yj().describe("The name of the client which has fixed IP address"),mac:e.Yj().describe("The MAC address of the client which has fixed IP address"),ip:e.Yj().describe("The IP address of the client which has fixed IP address assigned to it")})).optional().optional().describe("Array of DHCP fixed IP assignments for the DHCP server running on the switch interface")})}),zo=e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","oob_management","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway"),dhcpMode:e.Yj().optional().describe("The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')"),dhcpRelayServerIps:e.YO(e.Yj().optional()).optional().describe("The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface"),dhcpLeaseTime:e.Yj().optional().describe("The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')"),dhcpDefaultRouterOption:e.k5(["switch","custom"]).optional().describe("Whether to use this switch or custom IP addresses as the default gateway for DHCP clients."),dhcpDefaultRouterIps:e.Yj().optional().describe('IP address(es) of routers to use as default gateways when `dhcpDefaultRouterOption` is set to "custom".'),dhcpDomainName:e.Yj().optional().describe(`The "domain" portion of a node's Fully Qualified Domain Name (FQDN).`),dnsNameserversOption:e.Yj().optional().describe("The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')"),dnsCustomNameservers:e.YO(e.Yj().optional()).optional().describe("The DHCP name server IPs when DHCP name server option is 'custom'"),bootOptionsEnabled:e.zM().optional().describe("Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface"),bootNextServer:e.Yj().optional().describe("The PXE boot server IP for the DHCP server running on the switch stack interface"),bootFileName:e.Yj().optional().describe("The PXE boot server file name for the DHCP server running on the switch stack interface"),dhcpOptions:e.YO(e.Ik({code:e.Yj().optional().describe("The code for DHCP option which should be from 2 to 254"),type:e.Yj().optional().describe("The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')"),value:e.Yj().optional().describe("The value of the DHCP option")}).optional()).optional().describe("Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface"),reservedIpRanges:e.YO(e.Ik({start:e.Yj().optional().describe("The starting IP address of the reserved IP range"),end:e.Yj().optional().describe("The ending IP address of the reserved IP range"),comment:e.Yj().optional().describe("The comment for the reserved IP range")}).optional()).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface"),fixedIpAssignments:e.YO(e.Ik({name:e.Yj().optional().describe("The name of the client which has fixed IP address"),mac:e.Yj().optional().describe("The MAC address of the client which has fixed IP address"),ip:e.Yj().optional().describe("The IP address of the client which has fixed IP address assigned to it")}).optional()).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface")}).optional(),Ao=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),interfaceId:e.Yj().describe("Interface ID")}),body:e.Ik({switch:e.Ik({serial:e.Yj().optional().describe("The serial of the switch"),stackId:e.Yj().optional().describe("The id of the switch stack")}).describe("The switch or switch stack that the interface belongs to."),serial:e.Yj().optional().optional().describe("Serial of the Routed Port Switch in Stack. Required when in Routed mode along with switchPortId."),name:e.Yj().optional().optional().describe("A friendly name or description for the interface or VLAN (max length 128 characters)."),mode:e.k5(["loopback","oob_management","routed","vlan"]).optional().optional().describe("L3 Interface mode, can be one of 'vlan', 'routed', 'loopback'. Default is 'vlan'. CS 17.18 or higher is required for 'routed' mode."),subnet:e.Yj().optional().nullable().describe("The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24)."),switchPortId:e.Yj().optional().optional().describe("Switch Port ID when in Routed mode (CS 17.18 or higher required)"),interfaceIp:e.Yj().optional().nullable().describe("The IP address that will be used for Layer 3 routing on this VLAN or subnet. This cannot be the same         as the device management IP."),multicastRouting:e.k5(["IGMP snooping querier","disabled","enabled"]).optional().optional().describe("Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'."),vlanId:e.ai().int().optional().optional().describe("The VLAN this L3 interface is on. VLAN must be between 1 and 4094."),defaultGateway:e.Yj().optional().optional().describe("The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a L3 interface. Required if this is the first IPv4 interface."),uplinkV4:e.zM().optional().optional().describe("When true, this interface is used as static IPv4 uplink."),candidateUplinkV4:e.zM().optional().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().optional().describe("When true, this interface is used as static IPv6 uplink."),staticV4Dns1:e.Yj().optional().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPF will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().optional().describe("The OSPF routing settings of the interface."),ospfV3:e.Ik({area:e.Yj().optional().describe("The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'."),cost:e.ai().int().optional().describe("The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority."),isPassiveEnabled:e.zM().optional().describe("When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised."),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().optional().describe("The OSPFv3 routing settings of the interface."),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'."),prefix:e.Yj().optional().nullable().describe("The IPv6 prefix of the interface. Required if IPv6 object is included."),address:e.Yj().optional().nullable().describe("The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'."),gateway:e.Yj().optional().describe("The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured."),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().optional().describe("The IPv6 settings of the interface."),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to.")}).optional().optional().describe("The VRF settings of the interface. Requires IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("The loopback number")}).optional().optional().describe("The loopback settings of the interface."),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().optional().describe("VRRP configuration for the L3 interface.  This is only applicable to Catalyst switches"),dhcpMode:e.k5(["dhcpDisabled","dhcpRelay","dhcpServer"]).optional().optional().describe(`The DHCP mode options for the switch interface
       ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')`),dhcpRelayServerIps:e.YO(e.Yj().optional()).optional().optional().describe("The DHCP relay server IPs to which DHCP packets would get relayed for the switch interface"),dhcpLeaseTime:e.k5(["1 day","1 hour","1 week","12 hours","30 minutes","4 hours"]).optional().optional().describe(`The DHCP lease time config for the dhcp server running on switch interface
        ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')`),dhcpDefaultRouterOption:e.k5(["switch","custom"]).optional().describe("Whether to use this switch or custom IP addresses as the default gateway for DHCP clients."),dhcpDefaultRouterIps:e.Yj().optional().describe('IP address(es) of routers to use as default gateways when `dhcpDefaultRouterOption` is set to "custom".'),dhcpDomainName:e.Yj().optional().describe(`The "domain" portion of a node's Fully Qualified Domain Name (FQDN).`),dnsNameserversOption:e.k5(["custom","googlePublicDns","openDns"]).optional().optional().describe(`The DHCP name server option for the dhcp server running on the switch interface
        ('googlePublicDns', 'openDns' or 'custom')`),dnsCustomNameservers:e.YO(e.Yj().optional()).optional().optional().describe(`The DHCP name server IPs when DHCP name server option is
        'custom'`),bootOptionsEnabled:e.zM().optional().optional().describe(`Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch
        interface`),bootNextServer:e.Yj().optional().optional().describe("The PXE boot server IP for the DHCP server running on the switch interface"),bootFileName:e.Yj().optional().optional().describe("The PXE boot server filename for the DHCP server running on the switch interface"),dhcpOptions:e.YO(e.Ik({code:e.Yj().describe("The code for DHCP option which should be from 2 to 254"),type:e.k5(["hex","integer","ip","text"]).describe(`The type of the DHCP option which should be one of
          ('text', 'ip', 'integer' or 'hex')`),value:e.Yj().describe("The value of the DHCP option")})).optional().optional().describe("Array of DHCP options consisting of code, type and value for the DHCP server running on the switch interface"),reservedIpRanges:e.YO(e.Ik({start:e.Yj().describe("The starting IP address of the reserved IP range"),end:e.Yj().describe("The ending IP address of the reserved IP range"),comment:e.Yj().optional().optional().describe("The comment for the reserved IP range")})).optional().optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch interface"),fixedIpAssignments:e.YO(e.Ik({name:e.Yj().describe("The name of the client which has fixed IP address"),mac:e.Yj().describe("The MAC address of the client which has fixed IP address"),ip:e.Yj().describe("The IP address of the client which has fixed IP address assigned to it")})).optional().optional().describe("Array of DHCP fixed IP assignments for the DHCP server running on the switch interface")})}),Xu=e.Ik({interfaceId:e.Yj().optional().describe("The ID"),name:e.Yj().optional().describe("The name"),mode:e.k5(["loopback","oob_management","routed","vlan"]).optional().describe("The mode"),subnet:e.Yj().optional().describe("IPv4 subnet"),interfaceIp:e.Yj().optional().describe("IPv4 address"),serial:e.Yj().optional().describe("Device serial"),switchPortId:e.Yj().optional().describe("Switch Port ID when in Routed mode"),switchFabricId:e.Yj().optional().describe("Switch Fabric ID this interface belongs to"),multicastRouting:e.Yj().optional().describe("Multicast routing status"),vlanId:e.ai().int().optional().describe("VLAN ID"),uplinkV4:e.zM().optional().describe("When true, this interface is used as static IPv4 uplink"),candidateUplinkV4:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv4 Uplink."),uplinkV6:e.zM().optional().describe("When true, this interface is used as static IPv6 uplink"),staticV4Dns1:e.Yj().optional().describe("Primary IPv4 DNS server address"),staticV4Dns2:e.Yj().optional().describe("Secondary IPv4 DNS server address"),ospfSettings:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv4 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPF network type")}).optional().describe("IPv4 OSPF Settings"),ospfV3:e.Ik({area:e.Yj().optional().describe("Area ID"),cost:e.ai().int().optional().describe("OSPF Cost"),isPassiveEnabled:e.zM().optional().describe("Disable sending Hello packets on this interface's IPv6 area"),networkType:e.k5(["broadcast","point-to-point"]).optional().describe("OSPFv3 network type")}).optional().describe("IPv6 OSPF Settings"),ipv6:e.Ik({assignmentMode:e.Yj().optional().describe("Assignment mode"),address:e.Yj().optional().describe("IPv6 address"),prefix:e.Yj().optional().describe("IPv6 subnet"),gateway:e.Yj().optional().describe("IPv6 gateway"),staticV6Dns1:e.Yj().optional().describe("Primary IPv6 DNS server address"),staticV6Dns2:e.Yj().optional().describe("Secondary IPv6 DNS server address"),candidateUplink:e.zM().optional().describe("When true, this interface is a UAC candidate for IPv6 Uplink.")}).optional().describe("IPv6 addressing"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this interface belongs to")}).optional().describe("VRF settings. Included on networks with IOS XE 17.18 or higher"),loopback:e.Ik({number:e.ai().int().optional().describe("Loopback number")}).optional().describe("Loopback Interface settings"),vrrp:e.Ik({ipv4:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv4"),address:e.Yj().optional().describe("Virtual IPv4 address"),group:e.ai().int().optional().describe("VRRP group number for IPv4"),priority:e.ai().int().optional().describe("VRRP priority for IPv4"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv4 VRRP preemption configuration")}).optional().describe("IPv4 VRRP configuration"),ipv6:e.Ik({enabled:e.zM().optional().describe("Indicates if VRRP is enabled for IPv6"),address:e.Yj().optional().describe("Virtual IPv6 address"),group:e.ai().int().optional().describe("VRRP group number for IPv6"),priority:e.ai().int().optional().describe("VRRP priority for IPv6"),preemption:e.Ik({enabled:e.zM().optional().describe("Preemptively assume Primary role if it has a higher priority than the current Primary")}).optional().describe("IPv6 VRRP preemption configuration")}).optional().describe("IPv6 VRRP configuration")}).optional().describe("VRRP configuration for the L3 interface.  This is only present for Catalyst switches"),defaultGateway:e.Yj().optional().describe("IPv4 default gateway"),dhcpMode:e.Yj().optional().describe("The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')"),dhcpRelayServerIps:e.YO(e.Yj().optional()).optional().describe("The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface"),dhcpLeaseTime:e.Yj().optional().describe("The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')"),dhcpDefaultRouterOption:e.k5(["switch","custom"]).optional().describe("Whether to use this switch or custom IP addresses as the default gateway for DHCP clients."),dhcpDefaultRouterIps:e.Yj().optional().describe('IP address(es) of routers to use as default gateways when `dhcpDefaultRouterOption` is set to "custom".'),dhcpDomainName:e.Yj().optional().describe(`The "domain" portion of a node's Fully Qualified Domain Name (FQDN).`),dnsNameserversOption:e.Yj().optional().describe("The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')"),dnsCustomNameservers:e.YO(e.Yj().optional()).optional().describe("The DHCP name server IPs when DHCP name server option is 'custom'"),bootOptionsEnabled:e.zM().optional().describe("Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface"),bootNextServer:e.Yj().optional().describe("The PXE boot server IP for the DHCP server running on the switch stack interface"),bootFileName:e.Yj().optional().describe("The PXE boot server file name for the DHCP server running on the switch stack interface"),dhcpOptions:e.YO(e.Ik({code:e.Yj().optional().describe("The code for DHCP option which should be from 2 to 254"),type:e.Yj().optional().describe("The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')"),value:e.Yj().optional().describe("The value of the DHCP option")}).optional()).optional().describe("Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface"),reservedIpRanges:e.YO(e.Ik({start:e.Yj().optional().describe("The starting IP address of the reserved IP range"),end:e.Yj().optional().describe("The ending IP address of the reserved IP range"),comment:e.Yj().optional().describe("The comment for the reserved IP range")}).optional()).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface"),fixedIpAssignments:e.YO(e.Ik({name:e.Yj().optional().describe("The name of the client which has fixed IP address"),mac:e.Yj().optional().describe("The MAC address of the client which has fixed IP address"),ip:e.Yj().optional().describe("The IP address of the client which has fixed IP address assigned to it")}).optional()).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface")}).optional(),ti=k.v1.enhanceEndpoints({addTagTypes:[se.Ye]}).injectEndpoints({endpoints:function(s){var n=s.mutation;return{createNetworkDhcpInterface:n({query:function(t){var i=t.path.networkId,a=t.body;return{url:"networks/".concat(i,"/switch/routing/interfaces/l3"),method:"POST",body:a}},transformResponse:function(t,i,a){var o=zo.safeParse(t);return o.success||console.warn("Invalid schema received for createNetworkDhcpInterface",JSON.stringify(a),o.error),t},invalidatesTags:[se.Ye]}),updateNetworkDhcpInterface:n({query:function(t){var i=t.path,a=i.networkId,o=i.interfaceId,l=t.body;return{url:"networks/".concat(a,"/switch/routing/interfaces/l3/").concat(o),method:"PUT",body:l}},transformResponse:function(t,i,a){var o=Ao.safeParse(t);return o.success||console.warn("Invalid schema received for updateNetworkDhcpInterface",JSON.stringify(a),o.error),t},invalidatesTags:[se.Ye]})}}}),Ju=ti.useCreateNetworkDhcpInterfaceMutation,Zu=ti.useUpdateNetworkDhcpInterfaceMutation,xo=k.v1.injectEndpoints({endpoints:function(s){var n=s.query;return{getSwitchRoutingOspf:n({query:function(t){var i=t.path.networkId,a=t.query;return{url:"networks/".concat(i,"/switch/routing/ospf"),method:"GET",query:a}},transformResponse:function(t,i,a){var o=Ro.safeParse(t);return o.success||console.warn("Invalid schema received for getSwitchRoutingOspf",JSON.stringify(a),o.error),t}})}}}),$u=xo.useGetSwitchRoutingOspfQuery,eh=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID")}),body:e.Ik({name:e.Yj().optional().optional().describe("Name or description for layer 3 static route"),subnet:e.Yj().describe("The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("IP address of the next hop device to which the device sends its traffic for the subnet"),advertiseViaOspfEnabled:e.zM().optional().optional().describe("Option to advertise static route via OSPF"),preferOverOspfRoutesEnabled:e.zM().optional().optional().describe("Option to prefer static route over OSPF routes"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().optional().describe("The VRF settings of the interface.")})}),No=e.Ik({staticRouteId:e.Yj().describe("The identifier of a layer 3 static route"),name:e.Yj().optional().optional().describe("The name or description of the layer 3 static route"),subnet:e.Yj().describe("The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("The IP address of the router to which traffic for this destination network should be sent"),managementNextHop:e.Yj().optional().optional().describe("Optional fallback IP address for management traffic"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().optional().describe("VRF settings"),advertiseViaOspfEnabled:e.zM().optional().optional().describe("Option to advertise static routes via OSPF"),preferOverOspfRoutesEnabled:e.zM().optional().optional().describe("Option to prefer static routes over OSPF routes")}),th=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID"),staticRouteId:e.Yj().describe("Static route ID")}),body:e.Ik({name:e.Yj().optional().describe("Name or description for layer 3 static route"),subnet:e.Yj().optional().describe("The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().optional().describe("IP address of the next hop device to which the device sends its traffic for the subnet"),managementNextHop:e.Yj().optional().describe("Optional fallback IP address for management traffic"),advertiseViaOspfEnabled:e.zM().optional().describe("Option to advertise static route via OSPF"),preferOverOspfRoutesEnabled:e.zM().optional().describe("Option to prefer static route over OSPF routes"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().describe("The VRF settings of the interface.")}).optional()}),Co=e.Ik({staticRouteId:e.Yj().describe("The identifier of a layer 3 static route"),name:e.Yj().optional().optional().describe("The name or description of the layer 3 static route"),subnet:e.Yj().describe("The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("The IP address of the router to which traffic for this destination network should be sent"),managementNextHop:e.Yj().optional().optional().describe("Optional fallback IP address for management traffic"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().optional().describe("VRF settings"),advertiseViaOspfEnabled:e.zM().optional().optional().describe("Option to advertise static routes via OSPF"),preferOverOspfRoutesEnabled:e.zM().optional().optional().describe("Option to prefer static routes over OSPF routes")}),ii=k.v1.enhanceEndpoints({addTagTypes:[se.Ye]}).injectEndpoints({endpoints:function(s){var n=s.mutation,t=s.query;return{getSwitchStackInterfaces:t({query:function(i){var a=i.path,o=a.networkId,l=a.switchStackId;return"networks/".concat(o,"/switch/stacks/").concat(l,"/routing/interfaces")},transformResponse:(0,Ae._j)(wo,"networks/:networkId/switch/stacks/:switchStackId/routing/interfaces"),providesTags:[se.Ye]}),createSwitchStackInterface:n({query:function(i){var a=i.path,o=a.networkId,l=a.switchStackId,u=i.body;return{url:"networks/".concat(o,"/switch/stacks/").concat(l,"/routing/interfaces"),method:"POST",body:u}},transformResponse:function(i,a,o){var l=jo.safeParse(i);return l.success||console.warn("Invalid schema received for createSwitchStackInterface",JSON.stringify(o),l.error),i},invalidatesTags:[se.Ye]})}}}),ih=ii.useCreateSwitchStackInterfaceMutation,oh=ii.useGetSwitchStackInterfacesQuery,oi=k.v1.enhanceEndpoints({addTagTypes:[se.jr]}).injectEndpoints({endpoints:function(s){var n=s.mutation;return{createNetworkSwitchStackRoutingStaticRoute:n({query:function(t){var i=t.path,a=i.networkId,o=i.switchStackId,l=t.body;return{url:"networks/".concat(a,"/switch/stacks/").concat(o,"/routing/staticRoutes"),method:"POST",body:l}},transformResponse:function(t,i,a){var o=No.safeParse(t);return o.success||console.warn("Invalid schema received for createNetworkSwitchStackRoutingStaticRoute",JSON.stringify(a),o.error),t},invalidatesTags:[se.jr]}),updateNetworkSwitchStackRoutingStaticRoute:n({query:function(t){var i=t.path,a=i.networkId,o=i.switchStackId,l=i.staticRouteId,u=t.body;return{url:"networks/".concat(a,"/switch/stacks/").concat(o,"/routing/staticRoutes/").concat(l),method:"PUT",body:u}},transformResponse:function(t,i,a){var o=Co.safeParse(t);return o.success||console.warn("Invalid schema received for updateNetworkSwitchStackRoutingStaticRoute",JSON.stringify(a),o.error),t},invalidatesTags:[se.jr]})}}}),rh=oi.useCreateNetworkSwitchStackRoutingStaticRouteMutation,nh=oi.useUpdateNetworkSwitchStackRoutingStaticRouteMutation,ah=e.Ik({path:e.Ik({networkId:e.Yj().describe("Network ID"),switchStackId:e.Yj().describe("Switch stack ID"),interfaceId:e.Yj().describe("Interface ID")})}),Lo=e.Ik({dhcpMode:e.k5(["dhcpDisabled","dhcpServer","dhcpRelay"]).optional().describe("The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')"),dhcpRelayServerIps:e.YO(e.Yj()).optional().describe("The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface"),dhcpLeaseTime:e.Yj().optional().describe("The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')"),dhcpDefaultRouterOption:e.k5(["switch","custom"]).optional().describe("Whether to use this switch or custom IP addresses as the default gateway for DHCP clients."),dhcpDefaultRouterIps:e.Yj().optional().describe('IP address(es) of routers to use as default gateways when `dhcpDefaultRouterOption` is set to "custom".'),dhcpDomainName:e.Yj().optional().describe(`The "domain" portion of a node's Fully Qualified Domain Name (FQDN).`),dnsNameserversOption:e.Yj().optional().describe("The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')"),dnsCustomNameservers:e.YO(e.Yj().optional()).optional().describe("The DHCP name server IPs when DHCP name server option is 'custom'"),bootOptionsEnabled:e.zM().optional().describe("Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface"),bootNextServer:e.Yj().optional().describe("The PXE boot server IP for the DHCP server running on the switch stack interface"),bootFileName:e.Yj().optional().describe("The PXE boot server file name for the DHCP server running on the switch stack interface"),dhcpOptions:e.YO(e.Ik({code:e.Yj().describe("The code for DHCP option which should be from 2 to 254"),type:e.k5(["text","ip","integer","hex"]).describe("The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')"),value:e.Yj().describe("The value of the DHCP option")})).optional().describe("Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface"),reservedIpRanges:e.YO(e.Ik({start:e.Yj().describe("The starting IP address of the reserved IP range"),end:e.Yj().describe("The ending IP address of the reserved IP range"),comment:e.Yj().optional().describe("The comment for the reserved IP range")})).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface"),fixedIpAssignments:e.YO(e.Ik({name:e.Yj().describe("The name of the client which has fixed IP address"),mac:e.Yj().describe("The MAC address of the client which has fixed IP address"),ip:e.Yj().describe("The IP address of the client which has fixed IP address assigned to it")})).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface")}).optional(),Mo=k.v1.injectEndpoints({endpoints:function(s){var n=s.query;return{fetchNetworkSwitchStackInterfaceDhcp:n({query:function(t){var i=t.path,a=i.interfaceId,o=i.networkId,l=i.switchStackId;return{url:"networks/".concat(o,"/switch/stacks/").concat(l,"/routing/interfaces/").concat(a,"/dhcp"),method:"GET"}},transformResponse:function(t,i,a){var o=Lo.safeParse(t);return o.success||console.warn("Invalid schema received for fetchDeviceInterfaceDhcp",JSON.stringify(a),o.error),t}})}}}),sh=Mo.useFetchNetworkSwitchStackInterfaceDhcpQuery,Fo=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Go=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},dh=null,Bo=e.Ay.object({id:e.Ay.string(),name:e.Ay.string(),serials:e.Ay.array(e.Ay.string()),members:e.Ay.array(e.Ay.object({serial:e.Ay.string(),name:e.Ay.string(),mac:ve,model:e.Ay.string(),role:e.Ay.enum(["active","member","standby"]).optional()}))}),qo=e.Ay.array(Bo),lh=null,ch=e.Ay.object({networkId:e.Ay.string().describe("Network ID").nonempty(),name:e.Ay.string().describe("The name of the new stack"),serials:e.Ay.array(e.Ay.string()).describe("An array of switch serials to be added into the new stack"),stackWiseVirtual:e.Ay.object({links:e.Ay.array(e.Ay.object({serial:e.Ay.string().describe("The serial of the device these details relate to"),ports:e.Ay.array(e.Ay.string()).describe("List of switch port identifiers to be assigned as StackWise Virtual links"),dualActiveDetection:e.Ay.object({ports:e.Ay.array(e.Ay.string()).describe("List of switch port identifiers to be assigned as Dual Active Detection links")}).describe("Dual Active Detection link details")})).describe("Array of devices forming SVL Stack")}).optional().describe("Config information needed for creating an SVL stack")}),Vo=e.Ay.object({id:e.Ay.string().describe("The ID of the stack")}),ri="getNetworkSwitchStacksTag",Ct=function(s){return{type:ri,id:s}},Lt=Ct("ALL"),ni="getNetworkSwitchStackProvisioningStatus",Mt=function(s){return{type:ni,id:s}},ai=Mt("ALL"),vt=k.v1.enhanceEndpoints({addTagTypes:[ri,ni]}).injectEndpoints({endpoints:function(s){return{getNetworkSwitchStacks:s.query({query:function(n){var t=n.networkId;return{url:"networks/".concat(t,"/switch/stacks")}},transformResponse:function(n,t,i){var a=qo.safeParse(n);return a.success||console.warn("Invalid schema received for getNetworkSwitchStacks",JSON.stringify(i),a.error),n},providesTags:function(n){var t,i=[Lt],a=(t=n?.map(function(o){return Ct(o.id)}))!==null&&t!==void 0?t:[];return i.concat(a)}}),bulkRemoveNetworkSwitchStacks:s.mutation({invalidatesTags:function(n,t,i){var a=[];return a=a.concat(i.switchStackIds.map(Ct)),a=a.concat(i.switchStackIds.map(Mt)),a},queryFn:function(n,t,i,a){return Fo(void 0,void 0,void 0,function(){var o,l,u,m,d;return Go(this,function(p){switch(p.label){case 0:return n.switchStackIds.length>10&&console.warn("Removing too many stacks with bulkRemoveNetworkSwitch will result in performance issues. Use an action batch instead. https://developer.cisco.com/meraki/api-v1/action-batches-overview/"),o=function(g){return"networks/".concat(n.networkId,"/switch/stacks/").concat(g)},l=n.switchStackIds.map(o),u=l.map(function(g){return a({url:g,method:"DELETE"})}),[4,Promise.all(u)];case 1:return m=p.sent(),d=m.find(function(g){return!!g.error}),d?[2,{error:d}]:[2,{data:{}}]}})})}}),getNetworkSwitchStackProvisioningStatus:s.query({query:function(n){var t={networkIds:n.networkIds};return{url:"organizations/".concat(n.organizationId,"/switch/stacks/stackWiseVirtual/recent").concat((0,N.DK)({requestParams:t}))}},transformResponse:function(n,t,i){var a=fo.safeParse(n);return a.success||console.warn("Invalid schema received for getNetworkSwitchStackProvisioningStatus",JSON.stringify(i),a.error),n},providesTags:function(n){var t,i=[ai],a=(t=n?.map(function(o){var l;return Mt((l=o?.id)!==null&&l!==void 0?l:"")}))!==null&&t!==void 0?t:[];return i.concat(a)}}),createNetworkSwitchStack:s.mutation({query:function(n){return{url:"networks/".concat(n.networkId,"/switch/stacks"),method:"POST",body:n}},invalidatesTags:function(n,t,i){var a=[Lt],o=[Lt,ai];return i.stackWiseVirtual?o:a},transformResponse:function(n,t,i){var a=Vo.safeParse(n);return a.success||console.warn("Invalid schema received for createNetworkSwitchStack",JSON.stringify(i),a.error),n}})}}}),ph=vt.useGetNetworkSwitchStacksQuery,uh=vt.useBulkRemoveNetworkSwitchStacksMutation,hh=vt.useGetNetworkSwitchStackProvisioningStatusQuery,bh=vt.useCreateNetworkSwitchStackMutation,yt=function(){return yt=Object.assign||function(s){for(var n,t=1,i=arguments.length;t<i;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(s[a]=n[a])}return s},yt.apply(this,arguments)},Eo=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},si=k.v1.injectEndpoints({endpoints:function(s){return{getEventsLog:s.query({query:function(n){var t=n.networkId,i=Eo(n,["networkId"]);return{url:"networks/".concat(t,"/events"),params:i}},transformResponse:function(n,t){var i=B(t);return yt(yt({},n),{cursors:i})}})}}}),fh=si.useGetEventsLogQuery,mh=si.useLazyGetEventsLogQuery,di=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},Ft="sensorAlertProfiles",li="sensorAlertProfile",_o=k.v1.enhanceEndpoints({addTagTypes:[Ft,li]}).injectEndpoints({endpoints:function(s){var n=s.query;return{fetchSensorAlertProfiles:n({query:function(t){var i=t.networkId;return{url:"networks/".concat(i,"/sensor/alerts/profiles")}},providesTags:function(t,i,a){var o=a.networkId;return t?di(di([],t.map(function(l){var u=l.profileId;return{type:li,id:u}}),!0),[{type:Ft,id:o}],!1):[{type:Ft,id:o}]}})}}}),gh=_o.useFetchSensorAlertProfilesQuery,Uo=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Ho=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},ci=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},pi=k.v1.injectEndpoints({endpoints:function(s){var n=s.query;return{fetchAlertCountsBySensor:n({query:function(t){var i=t.networkId,a=ci(t,["networkId"]);return{url:"networks/".concat(i,"/sensor/alerts/counts/bySensor"),params:a}}}),fetchAlertCountsBySensorPaginated:n({queryFn:function(t){return Uo(void 0,void 0,void 0,function(){var i,a,o=t.networkId,l=t.maxRequests,u=ci(t,["networkId","maxRequests"]);return Ho(this,function(m){switch(m.label){case 0:return i=[],a=[],[4,(0,C.paginatedApiRequest)(i.push.bind(i),a.push.bind(a),{method:"GET",url:"/api/v1/networks/".concat(o,"/sensor/alerts/counts/bySensor").concat((0,N.DK)(u))},l)];case 1:return m.sent(),a.length>0?[2,{error:{errors:a.flat()}}]:[2,{data:i.flat()}]}})})}})}}}),Ih=pi.useFetchAlertCountsBySensorQuery,vh=pi.useFetchAlertCountsBySensorPaginatedQuery,Qo=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},yh={FifteenMinutes:900,OneHour:3600,OneDay:86400,OneWeek:604800},Wo=k.v1.injectEndpoints({endpoints:function(s){return{fetchSensorAlertsOverviewByMetric:s.query({query:function(n){var t=n.networkId,i=Qo(n,["networkId"]);return{url:"networks/".concat(t,"/sensor/alerts/overview/byMetric").concat((0,N.DK)(i))}}})}}}),kh=Wo.useFetchSensorAlertsOverviewByMetricQuery,kt=function(){return kt=Object.assign||function(s){for(var n,t=1,i=arguments.length;t<i;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(s[a]=n[a])}return s},kt.apply(this,arguments)},Ko=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Xo=k.v1.injectEndpoints({endpoints:function(s){return{fetchHistoricalBatteryReadings:s.query({query:function(n){var t=n.networkId,i=n.serial,a=Ko(n,["networkId","serial"]);return{url:"networks/".concat(t,"/sensor/stats/historicalBySensor").concat((0,N.DK)(kt(kt({},a),{metric:"battery",serials:[i]})))}}})}}}),wh=Xo.useFetchHistoricalBatteryReadingsQuery,ui=k.v1.injectEndpoints({endpoints:function(s){return{getUplinkStatuses:s.query({query:function(n){var t=n.organizationId,i=n.networkIds;return{params:{networkIds:i},url:"organizations/".concat(t,"/appliance/uplink/statuses")}}}),getUplinkStatusCounts:s.query({query:function(n){return{url:"organizations/".concat(n,"/appliance/uplinks/statuses/overview")}}})}}}),jh=ui.useGetUplinkStatusesQuery,Yh=ui.useGetUplinkStatusCountsQuery,Jo=k.v1.enhanceEndpoints({addTagTypes:["CurrentUser"]}).injectEndpoints({endpoints:function(s){return{getCurrentUserWriteableScopes:s.query({query:function(n){return{url:"organizations/".concat(n,"/currentUser/writeableScopes")}}})}}}),Th=Jo.useGetCurrentUserWriteableScopesQuery,Zo=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},$o=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},er=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},hi=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},wt="Device",bi=k.v1.enhanceEndpoints({addTagTypes:["Device"]}).injectEndpoints({endpoints:function(s){return{getDevices:s.query({query:function(n){var t=n.macs,i=n.models,a=n.networkIds,o=n.organizationId,l=n.productTypes,u=n.serials,m=n.tags,d=n.perPage;return{params:{macs:t,models:i,networkIds:a,productTypes:l,serials:u,tags:m,perPage:d},url:"organizations/".concat(o,"/devices")}},providesTags:[{type:wt,id:"LIST"}]}),getDevicesPaginated:s.query({queryFn:function(n){return Zo(void 0,void 0,void 0,function(){var t,i,a=n.organizationId,o=n.maxRequests,l=er(n,["organizationId","maxRequests"]);return $o(this,function(u){switch(u.label){case 0:return t=[],i=[],[4,(0,C.paginatedApiRequest)(t.push.bind(t),i.push.bind(i),{method:"GET",url:"/api/v1/organizations/".concat(a,"/devices").concat((0,N.DK)(l))},o)];case 1:return u.sent(),i.length>0?[2,{error:{errors:i.flat()}}]:[2,{data:t.flat()}]}})})},providesTags:function(n){return n?hi(hi([],n.map(function(t){var i=t.serial;return{type:wt,id:i}}),!0),[{type:wt,id:"LIST"}],!1):[{type:wt,id:"LIST"}]}})}}}),Ph=bi.useGetDevicesQuery,Oh=bi.useGetDevicesPaginatedQuery,tr=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},fi=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},Me="DebugClientBundle",st=k.v1.enhanceEndpoints({addTagTypes:[Me]}).injectEndpoints({endpoints:function(s){return{createDebugClientBundle:s.mutation({query:function(n){var t=n.serial,i=tr(n,["serial"]);return{url:"devices/".concat(t,"/liveTools/debugging/clients/bundles"),method:"POST",body:i}},invalidatesTags:[{type:Me,id:"LIST"}]}),getDebugClientBundle:s.query({query:function(n){var t=n.serial,i=n.bundleId;return{url:"devices/".concat(t,"/liveTools/debugging/clients/bundles/").concat(i)}},providesTags:function(n,t,i){var a=i.bundleId;return[{type:Me,id:a}]}}),getDebugClientBundles:s.query({query:function(n){var t=n.serial;return{url:"devices/".concat(t,"/liveTools/debugging/clients/bundles")}},providesTags:function(n){return n?fi(fi([],n.map(function(t){var i=t.id;return{type:Me,id:i}}),!0),[{type:Me,id:"LIST"}],!1):[{type:Me,id:"LIST"}]}}),stopDebugClientBundle:s.mutation({query:function(n){var t=n.serial,i=n.bundleId;return{url:"devices/".concat(t,"/liveTools/debugging/clients/bundles/").concat(i,"/stop"),method:"POST"}},invalidatesTags:function(n,t,i){var a=i.bundleId;return[{type:Me,id:a},{type:Me,id:"LIST"}]}}),downloadDebugClientBundle:s.mutation({query:function(n){var t=n.serial,i=n.bundleId;return{url:"devices/".concat(t,"/liveTools/debugging/clients/bundles/").concat(i,"/downloadUrl/generate"),method:"POST"}}}),deleteDebugClientBundle:s.mutation({query:function(n){var t=n.serial,i=n.bundleId;return{url:"devices/".concat(t,"/liveTools/debugging/clients/bundles/").concat(i),method:"DELETE"}},invalidatesTags:function(n,t,i){var a=i.bundleId;return[{type:Me,id:a},{type:Me,id:"LIST"}]}})}}}),Sh=st.useCreateDebugClientBundleMutation,Dh=st.useGetDebugClientBundleQuery,Rh=st.useGetDebugClientBundlesQuery,zh=st.useStopDebugClientBundleMutation,Ah=st.useDownloadDebugClientBundleMutation,xh=st.useDeleteDebugClientBundleMutation,ir=k.v1.injectEndpoints({endpoints:function(s){return{getDeviceStatusOverview:s.query({query:function(n){var t=n.networkIds,i=n.organizationId,a=n.productTypes;return{params:{networkIds:t,productTypes:a},url:"organizations/".concat(i,"/devices/statuses/overview")}}})}}}),Nh=ir.useGetDeviceStatusOverviewQuery,or=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},rr=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},nr=["disconnected","connected","powered","available","powering","standby"],ar=["wireless","appliance","switch","systemsManager","camera","cellularGateway","sensor"],sr=["offline","online","dormant","alerting"],dr=e.Ay.object({slot:e.Ay.number(),serial:e.Ay.string(),model:e.Ay.string(),status:e.Ay.enum(nr),poe:e.Ay.object({unit:e.Ay.string(),maximum:e.Ay.number()})}),lr=e.Ay.object({powerSupplies:e.Ay.array(dr)}),cr=e.Ay.object({name:e.Ay.string(),serial:e.Ay.string(),mac:ve,publicIp:e.Ay.string().ip(),networkId:e.Ay.string(),status:e.Ay.enum(sr),lastReportedAt:Xe,lanIp:e.Ay.string().ip(),gateway:e.Ay.string(),ipType:e.Ay.string(),primaryDns:e.Ay.string(),secondaryDns:e.Ay.string(),productType:e.Ay.enum(ar),components:lr,model:e.Ay.string(),tags:e.Ay.array(e.Ay.string())}),Ch=e.Ay.array(cr),pr=k.v1.injectEndpoints({endpoints:function(s){return{getOrganizationDeviceStatusesFull:s.query({queryFn:function(n){return or(this,arguments,void 0,function(t){var i,a,o,l=t.networkIds,u=t.organizationId,m=t.productTypes;return rr(this,function(d){switch(d.label){case 0:return[4,J({method:"GET",url:"/api/v1/organizations/".concat(u,"/devices/statuses").concat((0,N.DK)({networkIds:l,productTypes:m}))})];case 1:return i=d.sent(),a=i.data,o=i.errors,o.length>0?[2,{error:{errors:o.flat()}}]:[2,{data:a.flat()}]}})})}})}}}),Lh=pr.useGetOrganizationDeviceStatusesFullQuery,ur=k.v1.injectEndpoints({endpoints:function(s){return{getOrganizationDevicesOuis:s.query({query:function(n){var t=n.organizationId;return{url:"organizations/".concat(t,"/devices/ouis")}},keepUnusedDataFor:1/0})}}}),Mh=ur.useGetOrganizationDevicesOuisQuery,hr=k.v1.enhanceEndpoints({addTagTypes:["OrganizationIamAdminAdministrator"]}).injectEndpoints({endpoints:function(s){return{getOrganizationAdministrators:s.query({query:function(n){var t=n.organizationId,i=n.search,a=n.email,o=n.scope,l=n.role,u=n.status,m=n.lastActive;return{url:"organizations/".concat(t,"/iam/admin/administrators"),params:{search:i,email:a,scope:o,role:l,status:u,lastActive:m},providesTags:[{type:"OrganizationIamAdminAdministrator",id:"LIST"}]}}})}}}),Fh=hr.useGetOrganizationAdministratorsQuery,mi=k.v1.enhanceEndpoints({addTagTypes:["OrganizationIamAdminRoleAssignment"]}).injectEndpoints({endpoints:function(s){return{getRoleAssignments:s.query({query:function(n){var t=n.organizationId,i=n.samlGroupNames;return{url:"organizations/".concat(t,"/iam/admin/roles/assignments"),method:"GET",params:{subjectType:"saml-group",samlGroupNames:i}}}}),bulkOperate:s.mutation({query:function(n){var t=n.organizationId,i=n.items;return{url:"organizations/".concat(t,"/iam/admin/roles/assignments/bulkOperate"),method:"POST",body:{items:i},providesTags:[{type:"OrganizationIamAdminRoleAssignment",id:"LIST"}]}}})}}}),Gh=mi.useGetRoleAssignmentsQuery,Bh=mi.useBulkOperateMutation,it="INVENTORY_DEVICES",br=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},fr=k.v1.enhanceEndpoints({addTagTypes:[it]}).injectEndpoints({endpoints:function(s){return{claimInventoryDevices:s.mutation({query:function(n){var t=n.organizationId,i=br(n,["organizationId"]);return{url:"organizations/".concat(t,"/inventory/claim"),method:"POST",body:i}},invalidatesTags:[it]})}}}),qh=fr.useClaimInventoryDevicesMutation,mr=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},gr=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},gi=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},jt=k.v1.enhanceEndpoints({addTagTypes:[it]}).injectEndpoints({endpoints:function(s){return{getInventoryDevices:s.query({query:function(n){var t=n.organizationId,i=gi(n,["organizationId"]);return{url:"organizations/".concat(t,"/inventory/devices"),params:i}},providesTags:[it]}),getAllInventoryDevices:s.query({queryFn:function(n){return mr(this,void 0,void 0,function(){var t,i,a,o=n.organizationId,l=gi(n,["organizationId"]);return gr(this,function(u){switch(u.label){case 0:return[4,J({method:"GET",url:"/api/v1/organizations/".concat(o,"/inventory/devices").concat((0,N.DK)(l))})];case 1:return t=u.sent(),i=t.data,a=t.errors,a.length>0?[2,{error:{errors:a.flat()}}]:[2,{data:i.flat()}]}})})},providesTags:[it]})}}}),Vh=function(){return jt.util.invalidateTags([INVENTORY_DEVICES])},Eh=jt.useGetInventoryDevicesQuery,_h=jt.useLazyGetInventoryDevicesQuery,Uh=jt.useGetAllInventoryDevicesQuery,Ir=k.v1.injectEndpoints({endpoints:function(s){return{getEndOfLifeSummary:s.query({query:function(n){var t=n.organizationId;return{url:"organizations/".concat(t,"/inventory/eoxSummary")}}})}}}),Hh=Ir.useGetEndOfLifeSummaryQuery,vr=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},yr=k.v1.enhanceEndpoints({addTagTypes:[it]}).injectEndpoints({endpoints:function(s){return{unifiedOrderClaim:s.mutation({query:function(n){var t=n.organizationId,i=vr(n,["organizationId"]);return{url:"organizations/".concat(t,"/inventory/orders/claim"),method:"POST",body:i,headers:{"Content-type":"application/json; charset=UTF-8"}}},invalidatesTags:[it]})}}}),Qh=yr.useUnifiedOrderClaimMutation,Ii=k.v1.injectEndpoints({endpoints:function(s){return{unifiedOrderPreview:s.query({query:function(n){var t=n.organizationId,i=n.claimId;return{url:"organizations/".concat(t,"/inventory/orders/preview"),method:"POST",body:{claimId:i},headers:{"Content-type":"application/json; charset=UTF-8"}}}})}}}),Wh=Ii.useUnifiedOrderPreviewQuery,Kh=Ii.useLazyUnifiedOrderPreviewQuery,Yt=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Tt=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},Pt=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},kr=100,wr=function(s){return{operation:s.operation,resource:s.resource,body:s.body}},vi=function(s,n){var t=s.find(function(i){return i.networkId===n.meta.networkId});t&&(t.tags=n.meta.tags)},lt=k.v1.enhanceEndpoints({addTagTypes:["NetworkGroup","Network"]}).injectEndpoints({endpoints:function(s){return{getNetworkSummariesFirstPage:s.query({queryFn:function(n){return Yt(void 0,void 0,void 0,function(){var t,i;return Tt(this,function(a){switch(a.label){case 0:return[4,(0,C.apiRequest)("GET","/api/v1/organizations/".concat(n,"/summary/top/networks/byStatus?startingAfter=0&perPage=").concat(kr))];case 1:return t=a.sent(),i=!!t.nextPageUrl,[2,{data:{data:t.data,hasMore:i}}]}})})},providesTags:function(n){return n?.data?Pt(Pt([{type:"NetworkGroup",id:"LIST"},{type:"Network",id:"LIST"}],n.data.filter(function(t){return t.networkGroupId}).map(function(t){return{type:"NetworkGroup",id:t.networkGroupId}}),!0),n.data.map(function(t){return{type:"Network",id:t.networkId}}),!0):[{type:"NetworkGroup",id:"LIST"},{type:"Network",id:"LIST"}]}}),getNetworkSummaries:s.query({queryFn:function(n){return Yt(this,void 0,void 0,function(){var t,i,a;return Tt(this,function(o){switch(o.label){case 0:return[4,J({method:"GET",url:"/api/v1/organizations/".concat(n,"/summary/top/networks/byStatus?perPage=2500")})];case 1:return t=o.sent(),i=t.data,a=t.errors,a.length>0?[2,{error:{errors:a.flat()}}]:[2,{data:i.flat()}]}})})},providesTags:function(n){return n?Pt(Pt([{type:"NetworkGroup",id:"LIST"},{type:"Network",id:"LIST"}],n.filter(function(t){return t.networkGroupId}).map(function(t){return{type:"NetworkGroup",id:t.networkGroupId}}),!0),n.map(function(t){return{type:"Network",id:t.networkId}}),!0):[{type:"NetworkGroup",id:"LIST"},{type:"Network",id:"LIST"}]}}),updateNetworkTags:s.mutation({queryFn:function(n){return Yt(this,arguments,void 0,function(t){var i,a,o,l,u=t.organizationId,m=t.token,d=t.actions;return Tt(this,function(p){switch(p.label){case 0:return p.trys.push([0,2,,3]),i={auth:{csrfToken:m}},a={synchronous:d.length>=20},[4,(0,C.batchedApiRequest)(u,d.map(wr),i,a)];case 1:return o=p.sent(),[2,{data:o.data}];case 2:return l=p.sent(),[2,{error:l}];case 3:return[2]}})})},onQueryStarted:function(n,t){return Yt(this,arguments,void 0,function(i,a){var o,l=i.actions,u=i.organizationId,m=a.dispatch,d=a.queryFulfilled;return Tt(this,function(p){switch(p.label){case 0:return p.trys.push([0,2,,3]),[4,d];case 1:return p.sent(),[3,3];case 2:return o=p.sent(),[2];case 3:return m(lt.util.updateQueryData("getNetworkSummaries",u,function(g){l.forEach(function(q){return vi(g,q)})})),m(lt.util.updateQueryData("getNetworkSummariesFirstPage",u,function(g){l.forEach(function(q){return vi(g.data,q)})})),[2]}})})}})}}}),Xh=lt.useGetNetworkSummariesFirstPageQuery,Jh=lt.useGetNetworkSummariesQuery,Zh=lt.useUpdateNetworkTagsMutation,yi=k.v1.enhanceEndpoints({addTagTypes:["OrganizationAdmin"]}).injectEndpoints({endpoints:function(s){return{getOrganizationAdmins:s.query({query:function(n){var t=n.organizationId,i=n.networkIds,a=n.includeCameraAndSensorAccesses;return{url:"organizations/".concat(t,"/admins"),params:{networkIds:i,includeCameraAndSensorAccesses:a},providesTags:[{type:"OrganizationAdmin",id:"LIST"}]}}}),deleteOrganizationAdmin:s.mutation({query:function(n){var t=n.organizationId,i=n.adminId;return{url:"organizations/".concat(t,"/admins/").concat(i),method:"DELETE"}}})}}}),$h=yi.useGetOrganizationAdminsQuery,eb=yi.useDeleteOrganizationAdminMutation,ki=k.v1.enhanceEndpoints({addTagTypes:["OrganizationAdmin"]}).injectEndpoints({endpoints:function(s){return{createAdmins:s.mutation({query:function(n){var t=n.admins,i=n.organizationId;return{method:"POST",url:"organizations/".concat(i,"/admins/bulkActions"),body:{admins:t}}},invalidatesTags:[{type:"OrganizationAdmin",id:"LIST"}]}),deleteAdmins:s.mutation({query:function(n){var t=n.organizationId,i=n.admins;return{url:"organizations/".concat(t,"/admins/bulkActions"),method:"DELETE",body:{admins:i}}},invalidatesTags:[{type:"OrganizationAdmin",id:"LIST"}]})}}}),tb=ki.useCreateAdminsMutation,ib=ki.useDeleteAdminsMutation,jr=k.v1.enhanceEndpoints({addTagTypes:["OrganizationConfigTemplate"]}).injectEndpoints({endpoints:function(s){return{getOrganizationConfigTemplates:s.query({query:function(n){return"organizations/".concat(n,"/configTemplates")},providesTags:function(n,t,i){return[{type:"OrganizationConfigTemplate",id:i}]}})}}}),ob=jr.useGetOrganizationConfigTemplatesQuery,wi=k.v1.enhanceEndpoints({addTagTypes:["CiscoAdminActivePermission"]}).injectEndpoints({endpoints:function(s){return{getCiscoAdminAccessList:s.query({query:function(n){var t=n.organizationId;return{url:"organizations/".concat(t,"/admins/temporaryPermissions/active")}},providesTags:function(n,t,i){var a=i.organizationId;return[{type:"CiscoAdminActivePermission",id:a}]}}),revokeCiscoAdminAccess:s.mutation({query:function(n){var t=n.organizationId,i=n.requestId;return{url:"organizations/".concat(t,"/admins/temporaryPermissions/requests/").concat(i,"/revoke"),method:"POST"}},invalidatesTags:function(n,t,i){var a=i.organizationId;return[{type:"CiscoAdminActivePermission",id:a}]}})}}}),rb=wi.useGetCiscoAdminAccessListQuery,nb=wi.useRevokeCiscoAdminAccessMutation,Yr=k.v1.enhanceEndpoints({addTagTypes:["OrganizationCotermLicense"]}).injectEndpoints({endpoints:function(s){return{getOrganizationCotermLicenses:s.query({query:function(n){return"organizations/".concat(n,"/licensing/coterm/licenses")},providesTags:[{type:"OrganizationCotermLicense",id:"LIST"}]})}}}),ab=Yr.useGetOrganizationCotermLicensesQuery,Tr=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},ct=k.v1.enhanceEndpoints({addTagTypes:["CustomRoles"]}).injectEndpoints({endpoints:function(s){return{getOrganizationCustomRoles:s.query({query:function(n){var t=n.organizationId;return"organizations/".concat(t,"/iam/admin/roles")},providesTags:function(n,t,i){var a=i.organizationId;return[{type:"CustomRoles",id:a}]}}),createCustomRole:s.mutation({query:function(n){var t=n.organizationId,i=Tr(n,["organizationId"]);return{url:"organizations/".concat(t,"/iam/admin/roles"),method:"POST",body:i}},invalidatesTags:function(n,t,i){var a=i.organizationId;return[{type:"CustomRoles",id:a}]}}),getCustomRoleById:s.query({query:function(n){var t=n.organizationId,i=n.roleId;return"organizations/".concat(t,"/iam/admin/roles/").concat(i)},providesTags:function(n,t,i){var a=i.roleId;return[{type:"CustomRoles",id:a}]}}),deleteCustomRole:s.mutation({query:function(n){var t=n.organizationId,i=n.roleId;return{url:"organizations/".concat(t,"/iam/admin/roles/").concat(i),method:"DELETE"}},invalidatesTags:function(n,t,i){var a=i.organizationId;return[{type:"CustomRoles",id:a}]}}),updateCustomRole:s.mutation({query:function(n){var t=n.organizationId,i=n.roleId,a=n.systemRoles;return{url:"organizations/".concat(t,"/iam/admin/roles/").concat(i),method:"PUT",body:{systemRoles:a}}},invalidatesTags:function(n,t,i){var a=i.organizationId;return[{type:"CustomRoles",id:a}]}})}}}),sb=ct.useGetOrganizationCustomRolesQuery,db=ct.useCreateCustomRoleMutation,lb=ct.useGetCustomRoleByIdQuery,cb=ct.useDeleteCustomRoleMutation,pb=ct.useUpdateCustomRoleMutation,Pr=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Or=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},Sr=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},ji=k.v1.enhanceEndpoints({addTagTypes:["OrganizationNetwork"]}).injectEndpoints({endpoints:function(s){return{getOrganizationNetworks:s.query({query:function(n){return"organizations/".concat(n,"/networks")},providesTags:function(n,t,i){return[{type:"OrganizationNetwork",id:i}]}}),getOrganizationNetworksPaginated:s.query({queryFn:function(n){return Pr(void 0,void 0,void 0,function(){var t,i,a=n.organizationId,o=n.maxRequests,l=o===void 0?100:o,u=Sr(n,["organizationId","maxRequests"]);return Or(this,function(m){switch(m.label){case 0:return t=[],i=[],[4,(0,C.paginatedApiRequest)(t.push.bind(t),i.push.bind(i),{method:"GET",url:"/api/v1/organizations/".concat(a,"/networks").concat((0,N.DK)(u))},l)];case 1:return m.sent(),i.length>0?[2,{error:{errors:i.flat()}}]:[2,{data:t.flat()}]}})})},providesTags:function(n,t,i){return[{type:"OrganizationNetwork",args:i}]}})}}}),ub=ji.useGetOrganizationNetworksQuery,hb=ji.useGetOrganizationNetworksPaginatedQuery,Yi=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Ot=k.v1.enhanceEndpoints({addTagTypes:["SamlRoles"]}).injectEndpoints({endpoints:function(s){return{getOrganizationSamlRoles:s.query({query:function(n){var t=n.organizationId;return"organizations/".concat(t,"/samlRoles")},providesTags:function(n,t,i){var a=i.organizationId;return[{type:"SamlRoles",id:a}]}}),createOrganizationSamlRole:s.mutation({query:function(n){var t=n.organizationId,i=Yi(n,["organizationId"]);return{url:"organizations/".concat(t,"/samlRoles/"),method:"POST",body:i}},invalidatesTags:function(n,t,i){var a=i.organizationId;return[{type:"SamlRoles",id:a}]}}),deleteOrganizationSamlRoles:s.mutation({query:function(n){var t=n.organizationId,i=n.samlRole;return{url:"organizations/".concat(t,"/samlRoles/").concat(i),method:"DELETE"}},invalidatesTags:function(n,t,i){var a=i.organizationId;return[{type:"SamlRoles",id:a}]}}),updateOrganizationSamlRole:s.mutation({query:function(n){var t=n.organizationId,i=n.samlRoleId,a=Yi(n,["organizationId","samlRoleId"]);return{url:"organizations/".concat(t,"/samlRoles/").concat(i),method:"PUT",body:a}},invalidatesTags:function(n,t,i){var a=i.organizationId;return[{type:"SamlRoles",id:a}]}})}}}),bb=Ot.useGetOrganizationSamlRolesQuery,fb=Ot.useCreateOrganizationSamlRoleMutation,mb=Ot.useDeleteOrganizationSamlRolesMutation,gb=Ot.useUpdateOrganizationSamlRoleMutation,Dr=k.v1.enhanceEndpoints({addTagTypes:["SamlSettings"]}).injectEndpoints({endpoints:function(s){return{getOrganizationSamlSettings:s.query({query:function(n){var t=n.organizationId;return"organizations/".concat(t,"/saml")},providesTags:function(n,t,i){var a=i.organizationId;return[{type:"SamlSettings",id:a}]}})}}}),Ib=Dr.useGetOrganizationSamlSettingsQuery,Ti=k.v1.enhanceEndpoints({addTagTypes:["Organization"]}).injectEndpoints({endpoints:function(s){return{getOrganization:s.query({query:function(n){return"organizations/".concat(n)},providesTags:function(n,t,i){return[{type:"Organization",id:i}]}}),getOrganizations:s.query({query:function(){return"organizations"},providesTags:[{type:"Organization",id:"LIST"}]})}}}),vb=Ti.useGetOrganizationQuery,yb=Ti.useGetOrganizationsQuery,Gt="PacketCaptureAnalysisResults",Pi=k.v1.enhanceEndpoints({addTagTypes:[Gt]}).injectEndpoints({endpoints:function(s){return{createGoldenSnitchTask:s.mutation({query:function(n){var t=n.organizationId,i=n.packetId,a=n.body;return{url:"organizations/".concat(t,"/devices/packetCaptures/").concat(i,"/tasks"),method:"POST",body:a}},invalidatesTags:[Gt]}),getGoldenSnitchTask:s.query({query:function(n){var t=n.organizationId,i=n.packetId,a=n.taskId,o=n.networkId;return{url:"organizations/".concat(t,"/devices/packetCaptures/").concat(i,"/tasks/").concat(a,"?networkId=").concat(o)}},providesTags:[Gt]})}},overrideExisting:!1}),kb=Pi.useCreateGoldenSnitchTaskMutation,wb=Pi.useGetGoldenSnitchTaskQuery,Rr=k.v1.injectEndpoints({endpoints:function(s){return{getSwitchPortTags:s.query({query:function(n){var t=n.organizationId,i=n.networkIds;return{url:i?"organizations/".concat(t,"/switch/port/tags?").concat(i.map(function(a){return"networkIds[]=".concat(a)}).join("&")):"organizations/".concat(t,"/switch/port/tags")}}})}}}),jb=Rr.useGetSwitchPortTagsQuery,zr=k.v1.enhanceEndpoints({addTagTypes:["OrganizationWirelessSsids"]}).injectEndpoints({endpoints:function(s){return{getOrganizationWirelessSsidsByNetwork:s.query({query:function(n){var t=n.organizationId,i=n.networkIds,a=n.includeDisabledSsids,o=a===void 0?!1:a;return{url:i?"organizations/".concat(t,"/wireless/ssids/byNetwork?includeDisabledSsids=").concat(o,"&").concat(i.map(function(l){return"networkIds[]=".concat(l)}).join("&")):"organizations/".concat(t,"/wireless/ssids/byNetwork?includeDisabledSsids=").concat(o),providesTags:[{type:"OrganizationWirelessSsids",id:"LIST"}]}}})}}}),Yb=zr.useGetOrganizationWirelessSsidsByNetworkQuery;function Ar(s){var n={};if(!s)return n;var t=s.split(",");return t.forEach(function(i){var a=i.trim(),o=a.match(/<([^>]+)>;\s*rel=["']?([^"'\s;]+)["']?/);if(o){var l=o[1],u=o[2];n[u]=l}}),n}var pt=k.v1.injectEndpoints({endpoints:function(s){return{getZtpDevices:s.query({query:function(n){var t=n.organizationId,i=n.deploymentType,a=n.search,o=n.sortBy,l=n.sortOrder,u=n.perPage,m=n.startingAfter,d=n.endingBefore,p=new URLSearchParams;a&&a.trim()&&p.set("search",a.trim()),i&&p.set("deploymentType",i),o&&p.set("sortBy",o),l&&p.set("sortOrder",l),u&&p.set("perPage",u),m&&p.set("startingAfter",m),d&&p.set("endingBefore",d);var g=p.toString(),q="organizations/".concat(t,"/wireless/devices/provisioning/deployments").concat(g?"?".concat(g):"");return{url:q}},transformResponse:function(n,t){var i,a,o,l,u,m=(i=t?.linkHeader)!==null&&i!==void 0?i:"",d=Ar(m),p=n.items.map(function(g){var q,Z,U,pe,fe,rt,nt,at,oe,ut,Ht,Qt,Wt,Kt,Xt,re=g.devices.old;return{newApName:(pe=(Z=(q=g.devices.new.name)===null||q===void 0?void 0:q.trim())!==null&&Z!==void 0?Z:(U=re?.name)===null||U===void 0?void 0:U.trim())!==null&&pe!==void 0?pe:"",newApDisplayName:"".concat(g.devices.new.model," (").concat(g.devices.new.serial,")"),oldApName:re?.name,oldApDisplayName:"".concat(re?.model," (").concat(re?.serial,")"),deviceModel:g.devices.new.model,networkId:(fe=g.network.id)!==null&&fe!==void 0?fe:null,rfProfileId:(oe=(nt=(rt=g.devices.new.rfProfile)===null||rt===void 0?void 0:rt.id)!==null&&nt!==void 0?nt:(at=re?.rfProfile)===null||at===void 0?void 0:at.id)!==null&&oe!==void 0?oe:"",networkName:(ut=g.network.name)!==null&&ut!==void 0?ut:"",status:g.status,type:g.type,newSerial:g.devices.new.serial,ztpRequestId:String(g.deploymentId),newMac:String(g.devices.new.mac),oldMac:String(re?.mac),tags:(Qt=(Ht=g.devices.new.tags)!==null&&Ht!==void 0?Ht:re?.tags)!==null&&Qt!==void 0?Qt:[],rfProfileName:(Kt=(Wt=g.devices.new.rfProfile)===null||Wt===void 0?void 0:Wt.name)!==null&&Kt!==void 0?Kt:(Xt=re?.rfProfile)===null||Xt===void 0?void 0:Xt.name,afterAction:re?.afterAction,createdAt:new Date(g.createdAt).toLocaleString("en-US",{year:"numeric",month:"long",day:"numeric",hour:"2-digit",minute:"2-digit",hour12:!1}),updatedAt:new Date(g.lastUpdatedAt).toLocaleString("en-US",{year:"numeric",month:"long",day:"numeric",hour:"2-digit",minute:"2-digit",hour12:!1})}});return{devices:p,totalCount:(u=(l=(o=(a=n.meta)===null||a===void 0?void 0:a.counts)===null||o===void 0?void 0:o.items)===null||l===void 0?void 0:l.total)!==null&&u!==void 0?u:p.length,hasNext:!!d.next,hasPrev:!!d.prev,nextCursor:d.next,prevCursor:d.prev,firstCursor:d.first,lastCursor:d.last}}}),getZtpDeploymentsBySerial:s.query({query:function(n){var t=n.organizationId,i=n.serials;return{url:"organizations/".concat(t,"/wireless/devices/provisioning/deployments/byNewDevice"),params:{serials:i}}},transformResponse:function(n){var t=n.items.map(function(i){var a,o,l,u,m,d,p,g,q,Z,U,pe,fe,rt,nt,at,oe=i.devices.old,ut={newApName:(u=(o=(a=i.devices.new.name)===null||a===void 0?void 0:a.trim())!==null&&o!==void 0?o:(l=oe?.name)===null||l===void 0?void 0:l.trim())!==null&&u!==void 0?u:"",newApDisplayName:"".concat(i.devices.new.model," (").concat(i.devices.new.serial,")"),oldApName:(m=oe?.name)!==null&&m!==void 0?m:"",oldApDisplayName:oe?"".concat(oe.model," (").concat(oe.serial,")"):"",deviceModel:i.devices.new.model,networkId:(d=i.network.id)!==null&&d!==void 0?d:null,rfProfileId:(Z=(g=(p=i.devices.new.rfProfile)===null||p===void 0?void 0:p.id)!==null&&g!==void 0?g:(q=oe?.rfProfile)===null||q===void 0?void 0:q.id)!==null&&Z!==void 0?Z:"",networkName:(U=i.network.name)!==null&&U!==void 0?U:"",status:i.status,type:i.type,newSerial:i.devices.new.serial,ztpRequestId:String(i.deploymentId),newMac:String(i.devices.new.mac),oldMac:String(oe?.mac),tags:i.devices.new.tags&&i.devices.new.tags.length>0?i.devices.new.tags:(pe=oe?.tags)!==null&&pe!==void 0?pe:[],rfProfileName:(rt=(fe=i.devices.new.rfProfile)===null||fe===void 0?void 0:fe.name)!==null&&rt!==void 0?rt:(nt=oe?.rfProfile)===null||nt===void 0?void 0:nt.name,afterAction:(at=oe?.afterAction)!==null&&at!==void 0?at:"move_to_inventory"};return{deployment:ut}});return{items:t}}}),updateZtpDevice:s.mutation({query:function(n){var t=n.organizationId,i=n.items;return{url:"organizations/".concat(t,"/wireless/devices/provisioning/deployments"),method:"PUT",body:{items:i}}}})}},overrideExisting:!1}),Tb=pt.useGetZtpDevicesQuery,Pb=pt.useLazyGetZtpDevicesQuery,Ob=pt.useLazyGetZtpDeploymentsBySerialQuery,Sb=pt.useGetZtpDeploymentsBySerialQuery,Db=pt.useUpdateZtpDeviceMutation,Oi=k.v1.injectEndpoints({endpoints:function(s){return{getTagRecommendations:s.query({query:function(n){var t=n.organizationId,i=n.networkIds;return{url:"organizations/".concat(t,"/wireless/devices/provisioning/recommendations/tags"),params:{networkIds:i}}},transformResponse:function(n){return n.items}})}},overrideExisting:!1}),Rb=Oi.useGetTagRecommendationsQuery,zb=Oi.useLazyGetTagRecommendationsQuery,xr=e.z.object({network:e.z.object({id:e.z.string(),name:e.z.string()}),counts:e.z.object({total:e.z.number(),byFailureType:e.z.array(e.z.object({type:e.z.string(),count:e.z.number()}))})}),Si=xr.array(),Fe=function(){return Fe=Object.assign||function(s){for(var n,t=1,i=arguments.length;t<i;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(s[a]=n[a])}return s},Fe.apply(this,arguments)},Nr=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Cr=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},Di=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Ri=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},zi=k.v1.injectEndpoints({endpoints:function(s){return{getImpactedWirelessDevicesByNetwork:s.query({query:function(n){var t=n.organizationId,i=n.startingAfter,a=n.endingBefore,o=Di(n,["organizationId","startingAfter","endingBefore"]);return{url:"organizations/".concat(t,"/assurance/impactedDevice/wireless/byNetwork"),method:"GET",params:Fe(Fe(Fe({},o),i&&{startingAfter:i}),a&&{endingBefore:a})}},transformResponse:function(n,t){var i=(0,Ae._j)(Si,"/organizations/{organizationId}/assurance/impactedDevice/wireless/byNetwork");i(n,t);var a=B(t);return Fe(Fe({},n),{cursors:a})}}),getImpactedWirelessDevicesByNetworkPaginated:s.query({queryFn:function(n,t,i,a){return Nr(this,void 0,void 0,function(){var o,l,u,m,d,p,g,q=n.organizationId,Z=Di(n,["organizationId"]);return Cr(this,function(U){switch(U.label){case 0:o=[],U.label=1;case 1:return[4,a({url:"organizations/".concat(q,"/assurance/impactedDevice/wireless/byNetwork"),method:"GET",params:Fe(Fe(Fe({},Z),{perPage:1e3}),l&&{startingAfter:l})})];case 2:if(u=U.sent(),u.error)return[2,{error:u.error}];m=u.data,d=(0,Ae._j)(Si,"/organizations/{organizationId}/assurance/impactedDevice/wireless/byNetwork"),d(m,u.meta),o=Ri(Ri([],o,!0),m,!0),p=B(u.meta),l=(g=p?.next)===null||g===void 0?void 0:g.startingAfter,U.label=3;case 3:if(l)return[3,1];U.label=4;case 4:return[2,{data:o}]}})})}})}}}),Ab=zi.useGetImpactedWirelessDevicesByNetworkQuery,xb=zi.useGetImpactedWirelessDevicesByNetworkPaginatedQuery,Nb=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 10. Default is 10."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe(`Optional parameter to filter switch module statuses by network ID. /
        This filter uses multiple exact matches.`),serials:e.YO(e.Yj().optional()).optional().optional().describe(`Optional parameter to filter switch module statuses by the serial number. /
        This filter uses multiple exact matches.`)})}),Lr=e.Ik({items:e.YO(e.Ik({serial:e.Yj().optional().describe("Serial number of the modular switch chassis"),name:e.Yj().optional().describe("Name of the modular switch chassis"),model:e.Yj().optional().describe("Model of the modular switch chassis"),supervisors:e.YO(e.Ik({slot:e.ai().int().optional().describe("Slot number of the supervisor"),serial:e.Yj().optional().describe("Serial number of the supervisor"),model:e.Yj().optional().describe("Model of the supervisor"),role:e.k5(["active","standby"]).optional().describe("Role of the supervisor")}).optional()).optional().describe("Supervisors in the modular switch chassis"),lineCards:e.YO(e.Ik({slot:e.ai().int().optional().describe("Slot number of the line card"),serial:e.Yj().optional().describe("Serial number of the line card"),model:e.Yj().optional().describe("Model of the line card")}).optional()).optional().describe("Line cards in the modular switch chassis")}).optional()).optional().describe("Modular Switch Chassis"),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("Total number of items"),remaining:e.ai().int().optional().describe("Remaining number of items")}).optional().describe("Counts related to items")}).optional().describe("Counts of items in the response")}).optional().describe("Metadata about the response")}).optional(),Mr=k.v1.injectEndpoints({endpoints:function(s){return{fetchOrganizationSwitchModularDevicesStatuses:s.query({query:function(n){var t=n.path.organizationId,i=n.query;return{method:"GET",url:"organizations/".concat(t,"/switch/modular/devices/statuses"),query:i}},transformResponse:(0,Ae._j)(Lr,"organizations/:organizationId/switch/modular/devices/statuses")})}}}),Cb=Mr.useFetchOrganizationSwitchModularDevicesStatusesQuery,Lb=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 50. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),extendedParams:e.zM().optional().optional().describe("Optional flag to return all of the switchport data vs smaller dataset"),configurationUpdatedAfter:e.Yj().optional().optional().describe("Optional parameter to filter items to switches where the configuration has been updated after the given timestamp."),mac:e.Yj().optional().optional().describe("Optional parameter to filter items to switches with MAC addresses that contain the search term or are an exact match."),macs:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter items to switches that have one of the provided MAC addresses."),name:e.Yj().optional().optional().describe("Optional parameter to filter items to switches with names that contain the search term or are an exact match."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter items to switches in one of the provided networks."),portProfileIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter items to switches that contain switchports belonging to one of the specified port profiles."),serial:e.Yj().optional().optional().describe("Optional parameter to filter items to switches with serial number that contains the search term or are an exact match."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter items to switches that have one of the provided serials.")})}),Mb=e.Ik({name:e.Yj().optional().describe("The name of the switch."),serial:e.Yj().optional().describe("The serial number of the switch."),mac:e.Yj().optional().describe("The MAC address of the switch."),network:e.Ik({name:e.Yj().optional().describe("The name of the network."),id:e.Yj().optional().describe("The ID of the network.")}).optional().describe("Identifying information of the switch's network."),model:e.Yj().optional().describe("The model of the switch."),ports:e.YO(e.Ik({portId:e.Yj().optional().describe("The identifier of the switch port."),name:e.Yj().optional().describe("The name of the switch port."),tags:e.YO(e.Yj().optional()).optional().describe("The list of tags of the switch port."),enabled:e.zM().optional().describe("The status of the switch port."),poeEnabled:e.zM().optional().describe("The PoE status of the switch port."),type:e.k5(["access","routed","stack","trunk"]).optional().describe("The type of the switch port ('trunk', 'access', 'stack' or 'routed')."),vlan:e.ai().int().optional().describe("The VLAN of the switch port. For a trunk port, this is the native VLAN. A null value will clear the value set for trunk ports."),voiceVlan:e.ai().int().optional().describe("The voice VLAN of the switch port. Only applicable to access ports."),allowedVlans:e.Yj().optional().describe("The VLANs allowed on the switch port. Only applicable to trunk ports."),rstpEnabled:e.zM().optional().describe("The rapid spanning tree protocol status."),stpGuard:e.k5(["bpdu guard","disabled","loop guard","root guard"]).optional().describe("The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard')."),linkNegotiation:e.Yj().optional().describe("The link speed for the switch port."),accessPolicyType:e.k5(["Custom access policy","MAC allow list","Open","Sticky MAC allow list"]).optional().describe("The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'."),stickyMacAllowList:e.YO(e.Yj().optional()).optional().describe("The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'."),stickyMacAllowListLimit:e.ai().int().optional().describe("The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.")}).optional()).optional().describe("Ports belonging to the switch")}).optional(),Fr=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Gr=k.v1.injectEndpoints({endpoints:function(s){return{fetchOrganizationSwitchportsBySwitch:s.query({query:function(n){var t=n.organizationId,i=Fr(n,["organizationId"]);return{method:"GET",url:"organizations/".concat(t,"/switch/ports/bySwitch"),params:i}}})}}}),Fb=Gr.useFetchOrganizationSwitchportsBySwitchQuery,Gb=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 30 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 30 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 30 days. The default is 1 day. If interval is provided, the timespan will be autocalculated."),interval:e.ai().int().optional().optional().describe("The time interval in seconds for returned data. The valid intervals are: 300, 1200, 14400, 86400. The default is 1200. Interval is calculated if time params are provided."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Networks for which information should be gathered."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter usage by switch."),portIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter usage by port ID.")})}),Bb=e.Ik({items:e.YO(e.Ik({serial:e.Yj().describe("Unique serial number for switch"),ports:e.YO(e.Ik({portId:e.Yj().describe("Unique identifier for the port"),indices:e.Ik({switch:e.ai().int().describe("The switch number for the port"),slot:e.ai().int().describe("The slot number for the port"),port:e.ai().int().describe("The port number for the port")}).describe(""),readings:e.YO(e.Ik({startTs:Xe.describe("Timestamp for the beginning of the bandwidth usage snapshot, exclusive."),endTs:Xe.describe("Timestamp for the end of the bandwidth usage snapshot, inclusive."),sfpProductId:e.Yj().describe("The product ID for the Small Form Factor Pluggable (SFP) currently inserted into the given port"),thresholdSetId:e.Yj().describe("Unique identifier used to associate readings from the Small Form Factor Pluggable (SFP) module to the appropriate set of thresholds"),byMetric:e.Ik({power:e.Ik({transmit:e.Ik({minimum:e.ai().describe("The minimum value for power transmitted by the port over the interval, in dBm"),maximum:e.ai().describe("The maximum value for power transmitted by the port over the interval, in dBm"),median:e.ai().describe("The median value for power transmitted by the port over the interval, in dBm")}).describe("Information about the power transmitted by the port"),receive:e.Ik({minimum:e.ai().describe("The minimum value for power received by the port over the interval, in dBm"),maximum:e.ai().describe("The maximum value for power received by the port over the interval, in dBm"),median:e.ai().describe("The median value for power received by the port over the interval, in dBm")}).describe("Information about the power received by the port")}).describe("Information about the power transmitted and received by the port"),temperature:e.Ik({fahrenheit:e.Ik({minimum:e.ai().describe("The minimum temperature of the port over the interval, in fahrenheit"),maximum:e.ai().describe("The maximum temperature of the port over the interval, in fahrenheit"),median:e.ai().describe("The median temperature of the port over the interval, in fahrenheit")}).describe("Information about the temperature of the port in fahrenheit"),celsius:e.Ik({minimum:e.ai().describe("The minimum temperature of the port over the interval, in celsius"),maximum:e.ai().describe("The maximum temperature of the port over the interval, in celsius"),median:e.ai().describe("The median temperature of the port over the interval, in celsius")}).describe("Information about the temperature of the port in celsius")}).describe("Information about the temperature of the port"),supplyVoltage:e.Ik({level:e.Ik({minimum:e.ai().describe("The minimum supply voltage for the port over the interval, in volts"),maximum:e.ai().describe("The maximum supply voltage for the port over the interval, in volts"),median:e.ai().describe("The median supply voltage for the port over the interval, in volts")}).describe("Information about the supply voltage level of the port, in volts")}).describe("Information about the supply voltage of the port"),laserBiasCurrent:e.Ik({draw:e.Ik({minimum:e.ai().describe("The minimum laser bias current for the port over the interval, in mA"),maximum:e.ai().describe("The maximum laser bias current for the port over the interval, in mA"),median:e.ai().describe("The median laser bias current for the port over the interval, in mA")}).describe("Information about the laser bias current draw of the port, in mA")}).describe("Information about the laser bias current of the port")}).describe("All reading data, grouped by the reading metric")})).describe("The digital optical monitoring readings for the individual port, with the most recent snapshot first")})).describe("The ports associated with the given switch"),network:e.Ik({id:e.Yj().describe("The network ID"),name:e.Yj().describe("The name of the network")}).describe("Information regarding the network the switch belongs to")})).describe("The top-level propery containing all digital optical monitorting data."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().describe("The total number of serials."),remaining:e.ai().int().describe("The number of serials remaining based on current pagination location within the dataset.")}).describe("The count metadata.")}).describe("Count metadata related to this result set."),units:e.Ik({power:e.Ik({name:e.Yj().describe("The name of the unit for transmit and receive power values"),symbol:e.k5(["V","mA","dBm"]).describe("The symbol of the unit for transmit and receive power values")}).describe("The units for the transmit and receive power values"),supplyVoltage:e.Ik({name:e.Yj().describe("The name of the unit for supply voltage values"),symbol:e.k5(["V","mA","dBm"]).describe("The symbol of the unit for supply voltage values")}).describe("The units for the supply voltage values"),laserBiasCurrent:e.Ik({name:e.Yj().describe("The name of the unit for laser bias current values"),symbol:e.k5(["V","mA","dBm"]).describe("The symbol of the unit for laser bias current values")}).describe("The units for the laser bias current values")}).optional().describe("Information about which units each reading is provided in"),thresholds:e.YO(e.Ik({thresholdSetId:e.Yj().describe("Unique identifier used to associate readings from the Small Form Factor Pluggable (SFP) module to the appropriate set of thresholds"),power:e.Ik({transmit:e.Ik({error:e.Ik({upper:e.ai().describe("The value in dBm at or above which the transmitted power is considered to be in an error state"),lower:e.ai().describe("The value in dBm at or below which the transmitted power is considered to be in an error state")}).describe("Error thresholds for the power transmitted by the port"),warning:e.Ik({upper:e.ai().optional().describe("The value in dBm at or above which the transmitted power is considered to be in a warning state"),lower:e.ai().optional().describe("The value in dBm at or below which the transmitted power is considered to be in a warning state")}).describe("Warning thresholds for the power transmitted by the port")}).describe("Thresholds for the power transmitted by the port"),receive:e.Ik({error:e.Ik({upper:e.ai().describe("The value in dBm at or above which the received power is considered to be in an error state"),lower:e.ai().describe("The value in dBm at or below which the received power is considered to be in an error state")}).describe("Error thresholds for the power received by the port"),warning:e.Ik({upper:e.ai().optional().describe("The value in dBm at or above which the received power is considered to be in a warning state"),lower:e.ai().optional().describe("The value in dBm at or below which the received power is considered to be in a warning state")}).describe("Warning thresholds for the power received by the port")}).describe("Thresholds for the power received by the port")}).describe("Minimum/maximum error and warning thresholds for power readings"),temperature:e.Ik({fahrenheit:e.Ik({error:e.Ik({upper:e.ai().describe("The value in fahrenheit at or above which the temperature is considered to be in an error state"),lower:e.ai().describe("The value in fahrenheit at or below which the temperature is considered to be in an error state")}).describe("Error thresholds for the temperature in fahrenheit of the port"),warning:e.Ik({upper:e.ai().optional().describe("The value in fahrenheit at or above which the temperature is considered to be in a warning state"),lower:e.ai().optional().describe("The value in fahrenheit at or below which the temperature is considered to be in a warning state")}).describe("Warning thresholds for the temperature in fahrenheit of the port")}).describe("Thresholds for the temperature in fahrenheit of the port"),celsius:e.Ik({error:e.Ik({upper:e.ai().describe("The value in celsius at or above which the temperature is considered to be in an error state"),lower:e.ai().describe("The value in celsius at or below which the temperature is considered to be in an error state")}).describe("Error thresholds for the temperature in celsius of the port"),warning:e.Ik({upper:e.ai().optional().describe("The value in celsius at or above which the temperature is considered to be in a warning state"),lower:e.ai().optional().describe("The value in celsius at or below which the temperature is considered to be in a warning state")}).describe("Warning thresholds for the temperature in celsius of the port")}).describe("Thresholds for the temperature in celsius of the port")}).describe("Minimum/maximum error and warning thresholds for temperature readings"),supplyVoltage:e.Ik({level:e.Ik({error:e.Ik({upper:e.ai().describe("The value in volts at or above which the supply voltage is considered to be in an error state"),lower:e.ai().describe("The value in volts at or below which the supply voltage is considered to be in an error state")}).describe("Error thresholds for supply voltage level of the port"),warning:e.Ik({upper:e.ai().optional().describe("The value in volts at or above which the supply voltage is considered to be in a warning state"),lower:e.ai().optional().describe("The value in volts at or below which the supply voltage is considered to be in a warning state")}).describe("Warning thresholds for supply voltage level of the port")}).describe("Thresholds for supply voltage level of the port")}).describe("Minimum/maximum error and warning thresholds for supply voltage readings"),laserBiasCurrent:e.Ik({draw:e.Ik({error:e.Ik({upper:e.ai().describe("The value in mA at or above which the laser bias current is considered to be in an error state"),lower:e.ai().describe("The value in mA at or below which the laser bias current is considered to be in an error state")}).describe("Error thresholds for laser bias current draw of the port"),warning:e.Ik({upper:e.ai().optional().describe("The value in mA at or above which the laser bias current is considered to be in a warning state"),lower:e.ai().optional().describe("The value in mA at or below which the laser bias current is considered to be in a warning state")}).describe("Warning thresholds for laser bias current draw of the port")}).describe("Thresholds for laser bias current draw of the port")}).describe("Minimum/maximum error and warning thresholds for laser bias current readings")})).optional().describe("Thresholds to be applied to each metric in order to derive error/warning states.")}).describe("Other metadata related to this result set.")}),Br=k.v1.injectEndpoints({endpoints:function(s){return{fetchOrganizationSwitchportsTransceiversReadingsHistoryBySwitch:s.query({query:function(n){var t=n.path.organizationId,i=n.query;return{url:"organizations/".concat(t,"/switch/ports/transceivers/readings/history/bySwitch"),params:i}}})}}}),qb=Br.useFetchOrganizationSwitchportsTransceiversReadingsHistoryBySwitchQuery,qr=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Vr=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},Er=mo.unwrap().shape.items.unwrap(),Ai=k.v1.enhanceEndpoints({addTagTypes:[se.Ye]}).injectEndpoints({endpoints:function(s){var n=s.mutation,t=s.query;return{getSwitchRoutingInterfacesFull:t({queryFn:function(i){return qr(this,void 0,void 0,function(){var a,o,l,u,m,d,p,g;return Vr(this,function(q){switch(q.label){case 0:return a=i.path,o=i.query,l=o===void 0?{}:o,[4,J({method:"GET",url:"/api/v1/organizations/".concat(a.organizationId,"/switch/routing/interfaces").concat((0,N.DK)(l))})];case 1:return u=q.sent(),m=u.data,d=u.errors,d.length>0?[2,{error:{errors:d.flat()}}]:(p=m.flatMap(function(Z){var U;return(U=Z?.items)!==null&&U!==void 0?U:[]}).flat(),g=Er.safeParse(p),g.success||console.warn("Invalid schema received for getSwitchRoutingInterfacesFull",JSON.stringify(i),g.error),[2,{data:p}])}})})},providesTags:[se.Ye]}),bulkOrganizationSwitchRoutingInterfacesDelete:n({query:function(i){var a=i.path.organizationId,o=i.body;return{method:"POST",url:"organizations/".concat(a,"/switch/routing/interfaces/bulkDelete"),body:o}},transformResponse:(0,Ae._j)(go,"/organizations/:organizationId/switch/routing/interfaces/bulkDelete"),invalidatesTags:[se.Ye]})}}}),Vb=Ai.useGetSwitchRoutingInterfacesFullQuery,Eb=Ai.useBulkOrganizationSwitchRoutingInterfacesDeleteMutation,_b=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter the result set by the included set of network IDs")}).optional()}),_r=e.Ik({items:e.YO(e.Ik({v2:e.Ik({enabled:e.zM().optional().describe("Boolean value to enable or disable OSPF routing. OSPF routing is disabled by default."),helloTimer:e.ai().int().optional().describe("Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds."),deadTimer:e.ai().int().optional().describe("Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535"),areas:e.YO(e.Ik({id:e.Yj().optional().describe("OSPF area ID"),name:e.Yj().optional().describe("Name of the OSPF area"),type:e.k5(["normal","nssa","stub"]).optional().describe('Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]')}).optional()).optional().describe("OSPF areas"),authentication:e.Ik({enabled:e.zM().optional().describe("Boolean value to enable or disable MD5 authentication. MD5 authentication is disabled by default."),type:e.Yj().optional().describe("Authentication type. Only MD5 authentication is supported."),key:e.Ik({id:e.Yj().optional().describe("MD5 authentication key index. Key index must be between 1 to 255"),passphrase:e.Yj().optional().describe("MD5 authentication passphrase")}).optional().describe("MD5 authentication credentials.")}).optional().describe("OSPF authentication configuration")}).optional().describe("OSPF(v2) configuration"),v3:e.Ik({enabled:e.zM().optional().describe("Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default."),helloTimer:e.ai().int().optional().describe("Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds."),deadTimer:e.ai().int().optional().describe("Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535"),areas:e.YO(e.Ik({id:e.Yj().optional().describe("OSPF area ID"),name:e.Yj().optional().describe("Name of the OSPF area"),type:e.k5(["normal","nssa","stub"]).optional().describe('Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]')}).optional()).optional().describe("OSPF v3 areas")}).optional().describe("OSPF v3 configuration"),network:e.Ik({id:e.Yj().optional().describe("Network ID")}).optional().describe("Network information"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this OSPF routing configuration belongs to.")}).optional().describe("VRF settings")}).optional()).optional().describe("The top-level property containing the OSPF routing configurations."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items in the dataset")}).optional().describe("Counts relating to the items.")}).optional().describe("Counts relating to the dataset.")}).optional().describe("Metadata relating to the dataset.")}).optional(),Ub=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter the result set by the included set of network IDs"),perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 1000. Default is 20."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")})}),Ur=e.Ik({items:e.YO(e.Ik({staticRouteId:e.Yj().describe("The identifier of a layer 3 static route"),name:e.Yj().optional().optional().describe("The name or description of the layer 3 static route"),subnet:e.Yj().describe("The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("The IP address of the router to which traffic for this destination network should be sent"),managementNextHop:e.Yj().optional().optional().describe("Optional fallback IP address for management traffic"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().optional().describe("VRF settings"),advertiseViaOspf:e.zM().optional().optional().describe("Option to advertise static routes via OSPF"),preferOverOspfRoutes:e.zM().optional().optional().describe("Option to prefer static routes over OSPF routes"),networkId:e.Yj().describe("Network ID"),serial:e.Yj().optional().optional().describe("Device serial"),switchStackId:e.Yj().optional().optional().describe("Switch stack ID")})).optional().describe("The top-level property containing the static routes data."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items (static routes) in the dataset"),remaining:e.ai().int().optional().describe("The number of items (static routes) in the dataset available on subsequent pages.")}).optional().describe("Counts relating to the items.")}).optional().describe("Counts relating to the dataset.")}).optional().describe("Metadata relating to the dataset.")}).optional(),Hb=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({staticRouteIds:e.YO(e.Yj().optional()).describe("Ids of the static routes to be deleted")})}),Hr=e.Ik({items:e.YO(e.Ik({staticRouteId:e.Yj().describe("The identifier of a layer 3 static route"),name:e.Yj().optional().optional().describe("The name or description of the layer 3 static route"),subnet:e.Yj().describe("The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("The IP address of the router to which traffic for this destination network should be sent"),managementNextHop:e.Yj().optional().optional().describe("Optional fallback IP address for management traffic"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().optional().describe("VRF settings"),advertiseViaOspf:e.zM().optional().optional().describe("Option to advertise static routes via OSPF"),preferOverOspfRoutes:e.zM().optional().optional().describe("Option to prefer static routes over OSPF routes"),networkId:e.Yj().describe("Network ID"),serial:e.Yj().optional().optional().describe("Device serial"),switchStackId:e.Yj().optional().optional().describe("Switch stack ID"),deleted:e.zM().optional().optional().describe("The delete status of the static route")})).optional().describe("The top-level property containing the static routes data."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items (static routes) in the dataset"),remaining:e.ai().int().optional().describe("The number of items (static routes) in the dataset available on subsequent pages.")}).optional().describe("Counts relating to the items.")}).optional().describe("Counts relating to the dataset.")}).optional().describe("Metadata relating to the dataset."),errors:e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The static route ID that caused the error."),message:e.Yj().optional().describe("The error message.")}).optional()).optional().describe("Errors encountered while processing the request.")}).optional(),Qb=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),body:e.Ik({staticRouteIds:e.YO(e.Yj().optional()).describe("List of L3 static route IDs to update"),changes:e.Ik({nextHopIp:e.Yj().optional().describe("The IP address of the router to which traffic for this destination network should be sent"),advertiseViaOspf:e.zM().optional().describe("Option to advertise static routes via OSPF."),preferOverOspfRoutes:e.zM().optional().describe("Option to prefer static routes over OSPF routes.")}).describe("Hash of changes to be applied to each static route")})}),Qr=e.Ik({items:e.YO(e.Ik({staticRouteId:e.Yj().describe("The identifier of a layer 3 static route"),name:e.Yj().optional().optional().describe("The name or description of the layer 3 static route"),subnet:e.Yj().describe("The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("The IP address of the router to which traffic for this destination network should be sent"),managementNextHop:e.Yj().optional().optional().describe("Optional fallback IP address for management traffic"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().optional().describe("VRF settings"),advertiseViaOspf:e.zM().optional().optional().describe("Option to advertise static routes via OSPF"),preferOverOspfRoutes:e.zM().optional().optional().describe("Option to prefer static routes over OSPF routes"),networkId:e.Yj().describe("Network ID"),serial:e.Yj().optional().optional().describe("Device serial"),switchStackId:e.Yj().optional().optional().describe("Switch stack ID"),updated:e.zM().optional().optional().describe("The update status of the static route")})).optional().describe("The top-level property containing the static routes data."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of items (static routes) in the dataset"),remaining:e.ai().int().optional().describe("The number of items (static routes) in the dataset available on subsequent pages.")}).optional().describe("Counts relating to the items.")}).optional().describe("Counts relating to the dataset.")}).optional().describe("Metadata relating to the dataset."),errors:e.YO(e.Ik({interfaceId:e.Yj().optional().describe("The static route ID that caused the error."),message:e.Yj().optional().describe("The error message.")}).optional()).optional().describe("Errors encountered while processing the request.")}).optional(),Wr=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Kr=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},Xr=Ur.unwrap().shape.items.unwrap(),Bt=k.v1.enhanceEndpoints({addTagTypes:[se.jr]}).injectEndpoints({endpoints:function(s){var n=s.query,t=s.mutation;return{getSwitchRoutingStaticRoutesFull:n({queryFn:function(i){return Wr(this,void 0,void 0,function(){var a,o,l,u,m,d;return Kr(this,function(p){switch(p.label){case 0:return a=i.path,o=i.query,[4,J({method:"GET",url:"/api/v1/organizations/".concat(a.organizationId,"/switch/routing/staticRoutes").concat((0,N.DK)(o))})];case 1:return l=p.sent(),u=l.data,m=l.errors,m.length>0?[2,{error:{errors:m.flat()}}]:(d=u.flatMap(function(g){var q;return(q=g?.items)!==null&&q!==void 0?q:[]}),(0,Ae._j)(e.Ay.array(Xr),"/api/v1/organizations/:organizationId/switch/routing/staticRoutes")(d,{ok:!0}),[2,{data:d.flat()}])}})})},providesTags:[se.jr]}),bulkOrganizationSwitchRoutingStaticRoutesDelete:t({query:function(i){var a=i.path.organizationId,o=i.body;return{method:"POST",url:"organizations/".concat(a,"/switch/routing/staticRoutes/bulkDelete"),body:o}},transformResponse:(0,Ae._j)(Hr,"/organizations/:organizationId/switch/routing/staticRoutes/bulkDelete"),invalidatesTags:[se.jr]}),bulkOrganizationSwitchRoutingStaticRoutesUpdate:t({query:function(i){var a=i.path.organizationId,o=i.body;return{method:"POST",url:"organizations/".concat(a,"/switch/routing/staticRoutes/bulkUpdate"),body:o}},transformResponse:(0,Ae._j)(Qr,"/organizations/:organizationId/switch/routing/staticRoutes/bulkUpdate"),invalidatesTags:[se.jr]})}}}),Wb=Bt.useGetSwitchRoutingStaticRoutesFullQuery,Kb=Bt.useBulkOrganizationSwitchRoutingStaticRoutesDeleteMutation,Xb=Bt.useBulkOrganizationSwitchRoutingStaticRoutesUpdateMutation,Jr=k.v1.injectEndpoints({endpoints:function(s){var n=s.query;return{getOrganizationSwitchRoutingOspf:n({query:function(t){var i=t.path.organizationId,a=t.query;return{url:"organizations/".concat(i,"/switch/routing/ospf").concat(a?(0,N.DK)(a):""),method:"GET"}},transformResponse:function(t,i,a){var o=_r.safeParse(t);return o.success||console.warn("Invalid schema received for getSwitchRoutingOspf",JSON.stringify(a),o.error),t}})}}}),Jb=Jr.useGetOrganizationSwitchRoutingOspfQuery,Zb=e.Ay.object({path:e.Ay.object({organizationId:e.Ay.string().nonempty("Organization ID is required")}),query:e.Ay.object({networkIds:e.Ay.array(e.Ay.string()).optional()})}),Zr=e.Ay.object({devices:e.Ay.array(e.Ay.object({serial:e.Ay.string().nonempty("Serial is required"),mac:ve,name:e.Ay.string().optional()})).describe("List of paired switches"),network:e.Ay.object({id:e.Ay.string().nonempty("Network ID is required")}).describe("Network information")}),$r=e.Ay.object({items:e.Ay.array(Zr)}),xi="getOrgSwitchStacksUnprovisionedTag",Ni=function(s){return{type:xi,id:s}},en=Ni("ALL"),tn=k.v1.enhanceEndpoints({addTagTypes:[xi]}).injectEndpoints({endpoints:function(s){return{getOrgSwitchStacksUnprovisioned:s.query({query:function(n){var t=n.path,i=n.query;return{url:"organizations/".concat(t.organizationId,"/switch/stacks/unprovisioned"),params:i}},transformResponse:function(n,t,i){var a=$r.safeParse(n);return a.success||console.warn("Invalid schema received for getOrgSwitchStacksUnprovisioned",JSON.stringify(i),a.error),n},providesTags:function(n){var t,i=[en],a=(t=n?.items.flatMap(function(o){return o.devices.map(function(l){return Ni(l.mac)})}))!==null&&t!==void 0?t:[];return i.concat(a)}})}}}),$b=tn.useGetOrgSwitchStacksUnprovisionedQuery,St="sensorCredits",on=k.v1.enhanceEndpoints({addTagTypes:[St]}).injectEndpoints({endpoints:function(s){return{fetchSensorCredits:s.query({query:function(n){var t=n.organizationId;return{url:"organizations/".concat(t,"/sensor/credits")}},providesTags:function(n,t,i){var a=i.organizationId;return[{type:St,id:a}]}})}}}),ef=on.useFetchSensorCreditsQuery,rn=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},nn=k.v1.injectEndpoints({endpoints:function(s){return{fetchSensorNetworkSettingsByNetwork:s.query({query:function(n){var t=n.organizationId,i=rn(n,["organizationId"]);return{url:"organizations/".concat(t,"/sensor/settings/byNetwork").concat((0,N.DK)(i))}}})}}}),tf=nn.useFetchSensorNetworkSettingsByNetworkQuery,of=null,qt="sensorOrders",Ci=k.v1.enhanceEndpoints({addTagTypes:[qt,St]}).injectEndpoints({endpoints:function(s){return{fetchSensorOrders:s.query({query:function(n){var t=n.organizationId;return{url:"organizations/".concat(t,"/sensor/orders")}},providesTags:function(n,t,i){var a=i.organizationId;return[{type:qt,id:a}]}}),createSensorOrder:s.mutation({query:function(n){var t=n.organizationId,i=n.order;return{url:"organizations/".concat(t,"/sensor/orders"),method:"POST",body:i}},invalidatesTags:function(n,t,i){var a=i.organizationId;return[{type:qt,id:a},{type:St,id:a}]}})}}}),rf=Ci.useFetchSensorOrdersQuery,nf=Ci.useCreateSensorOrderMutation,an=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},af={FifteenMinutes:900,OneHour:3600,OneDay:86400,OneWeek:604800},sn=k.v1.injectEndpoints({endpoints:function(s){return{fetchSensorReadingsOverviewByInterval:s.query({query:function(n){var t=n.organizationId,i=an(n,["organizationId"]);return{url:"organizations/".concat(t,"/sensor/readings/overview/byInterval").concat((0,N.DK)(i))}}})}}}),sf=sn.useFetchSensorReadingsOverviewByIntervalQuery,dn=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},ln=k.v1.injectEndpoints({endpoints:function(s){return{fetchSensorReadingsOverviewBySensor:s.query({query:function(n){var t=n.organizationId,i=dn(n,["organizationId"]);return{url:"organizations/".concat(t,"/sensor/readings/overview/bySensor").concat((0,N.DK)(i))}}})}}}),df=ln.useFetchSensorReadingsOverviewBySensorQuery,cn=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},pn=k.v1.injectEndpoints({endpoints:function(s){return{fetchSensorReadingsOverviewByTag:s.query({query:function(n){var t=n.organizationId,i=cn(n,["organizationId"]);return{url:"organizations/".concat(t,"/sensor/readings/overview/byTag").concat((0,N.DK)(i))}}})}}}),lf=pn.useFetchSensorReadingsOverviewByTagQuery,un=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},hn=k.v1.injectEndpoints({endpoints:function(s){return{fetchSensorReadingsHistoryByInterval:s.query({query:function(n){var t=n.organizationId,i=un(n,["organizationId"]);return{url:"organizations/".concat(t,"/sensor/readings/history/byInterval"),params:i}}})}}}),cf=hn.useFetchSensorReadingsHistoryByIntervalQuery,Vt=function(){return Vt=Object.assign||function(s){for(var n,t=1,i=arguments.length;t<i;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(s[a]=n[a])}return s},Vt.apply(this,arguments)},bn=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},fn=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},Li=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Dt=k.v1.injectEndpoints({endpoints:function(s){return{fetchSensorAlerts:s.query({query:function(n){var t=n.organizationId,i=Li(n,["organizationId"]);return{url:"organizations/".concat(t,"/sensor/alerts"),params:Vt({},i)}}}),fetchSensorAlertsPaginated:s.query({queryFn:function(n){return bn(void 0,void 0,void 0,function(){var t,i,a=n.organizationId,o=n.maxRequests,l=Li(n,["organizationId","maxRequests"]);return fn(this,function(u){switch(u.label){case 0:return t=[],i=[],[4,(0,C.paginatedApiRequest)(t.push.bind(t),i.push.bind(i),{method:"GET",url:"/api/v1/organizations/".concat(a,"/sensor/alerts").concat((0,N.DK)(l))},o)];case 1:return u.sent(),i.length>0?[2,{error:{errors:i.flat()}}]:[2,{data:t.flat()}]}})})}})}}}),pf=Dt.useFetchSensorAlertsQuery,uf=Dt.useLazyFetchSensorAlertsQuery,hf=Dt.useFetchSensorAlertsPaginatedQuery,bf=Dt.useLazyFetchSensorAlertsPaginatedQuery,mn=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Mi=k.v1.injectEndpoints({endpoints:function(s){var n=s.query,t=s.mutation;return{fetchSensorAlertsExport:n({query:function(i){var a=i.organizationId,o=i.exportId;return{url:"organizations/".concat(a,"/sensor/alerts/exports/").concat(o)}}}),createSensorAlertsExport:t({query:function(i){var a=i.organizationId,o=mn(i,["organizationId"]);return{url:"organizations/".concat(a,"/sensor/alerts/exports"),method:"POST",body:o}}})}}}),ff=Mi.useFetchSensorAlertsExportQuery,mf=Mi.useCreateSensorAlertsExportMutation,gn=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Fi=k.v1.injectEndpoints({endpoints:function(s){var n=s.query,t=s.mutation;return{fetchSensorReadingsExport:n({query:function(i){var a=i.organizationId,o=i.exportId;return{url:"organizations/".concat(a,"/sensor/readings/exports/").concat(o)}}}),createSensorReadingsExport:t({query:function(i){var a=i.organizationId,o=gn(i,["organizationId"]);return{url:"organizations/".concat(a,"/sensor/readings/exports"),method:"POST",body:o}}})}}}),gf=Fi.useFetchSensorReadingsExportQuery,If=Fi.useCreateSensorReadingsExportMutation,In=k.v1.injectEndpoints({endpoints:function(s){var n=s.query;return{getOrganizationRoutingVrfs:n({query:function(t){var i=t.path.organizationId,a=t.query;return{url:"organizations/".concat(i,"/routing/vrfs"),method:"GET",query:a}},transformResponse:function(t,i,a){var o=bo.safeParse(t);return o.success||console.warn("Invalid schema received for getOrganizationRoutingVrfsResponseSchema",JSON.stringify(a),o.error),t}})}}}),vf=In.useGetOrganizationRoutingVrfsQuery,yf=e.Ik({path:e.Ik({organizationId:e.Yj().describe("Organization ID")}),query:e.Ik({perPage:e.ai().int().optional().optional().describe("The number of entries per page returned. Acceptable range is 3 - 100. Default is 50."),startingAfter:e.Yj().optional().optional().describe("A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),endingBefore:e.Yj().optional().optional().describe("A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it."),t0:e.Yj().optional().optional().describe("The beginning of the timespan for the data. The maximum lookback period is 31 days from today."),t1:e.Yj().optional().optional().describe("The end of the timespan for the data. t1 can be a maximum of 31 days after t0."),timespan:e.ai().optional().optional().describe("The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. If interval is provided, the timespan will be autocalculated."),interval:e.ai().int().optional().optional().describe("The time interval in seconds for returned data. The valid intervals are: 300, 3600, 86400. The default is 3600. Interval is calculated if time params are provided."),networkIds:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter connectivity history by network ID. This filter uses multiple exact matches."),serials:e.YO(e.Yj().optional()).optional().optional().describe("Optional parameter to filter usage by device.")})}),kf=e.Ik({items:e.YO(e.Ik({serial:e.Yj().optional().describe("Unique serial number for device"),history:e.YO(e.Ik({startTs:e.Yj().optional().describe("Timestamp for the beginning of the bandwidth usage snapshot, exclusive."),endTs:e.Yj().optional().describe("Timestamp for the end of the bandwidth usage snapshot, inclusive."),total:e.ai().optional().describe("Total bandwidth usage, in kbps."),upstream:e.ai().optional().describe("Uploaded data, in kbps."),downstream:e.ai().optional().describe("Downloaded data, in kbps.")}).optional()).optional().describe("The usage history for device, with the most recent snapshot first"),network:e.Ik({id:e.Yj().optional().describe("The network ID"),name:e.Yj().optional().describe("The name of the network")}).optional().describe("Information regarding the network the device belongs to")}).optional()).optional().describe("The top-level propery containing all status data."),meta:e.Ik({counts:e.Ik({items:e.Ik({total:e.ai().int().optional().describe("The total number of serials."),remaining:e.ai().int().optional().describe("The number of serials remaining based on current pagination location within the dataset.")}).optional().describe("The count metadata.")}).optional().describe("Count metadata related to this result set.")}).optional().describe("Other metadata related to this result set.")}).optional(),vn=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},yn=k.v1.enhanceEndpoints({addTagTypes:["feedbackMessage"]}).injectEndpoints({endpoints:function(s){return{createFeedbackMessage:s.mutation({query:function(n){var t=n.organizationId,i=vn(n,["organizationId"]);return{url:"organizations/".concat(t,"/support/feedback/messages"),method:"POST",body:i}},invalidatesTags:["feedbackMessage"]})}}}),wf=yn.useCreateFeedbackMessageMutation,kn=k.v1.injectEndpoints({endpoints:function(s){return{getEarlyAccessFeatureOptIns:s.query({query:function(n){var t=n.organizationId;return{url:"organizations/".concat(t,"/earlyAccess/features/optIns")}}})}}}),jf=kn.useGetEarlyAccessFeatureOptInsQuery,wn=k.v1.enhanceEndpoints({addTagTypes:["EnergyHistory"]}).injectEndpoints({endpoints:function(s){return{fetchEnergyHistoryByInterval:s.query({query:function(n){var t=n.organizationId,i=n.networkIds,a=i===void 0?[]:i;return{url:"organizations/".concat(t,"/summary/sustainability/energy/history/byInterval"),params:{networkIds:a},method:"GET"}},providesTags:["EnergyHistory"]})}}}),Yf=wn.useFetchEnergyHistoryByIntervalQuery,Rt=function(){return Rt=Object.assign||function(s){for(var n,t=1,i=arguments.length;t<i;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(s[a]=n[a])}return s},Rt.apply(this,arguments)},jn=function(s,n){var t={};for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&n.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,i=Object.getOwnPropertySymbols(s);a<i.length;a++)n.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(s,i[a])&&(t[i[a]]=s[i[a]]);return t},Yn=k.v1.injectEndpoints({endpoints:function(s){return{fetchHistoricalRssiByGateway:s.query({query:function(n){var t=n.serial,i=jn(n,["serial"]);return{url:"devices/".concat(t,"/sensor/health/historicalByGateway").concat((0,N.DK)(Rt(Rt({},i),{metric:"rssi"})))}}})}}}),Tf=Yn.useFetchHistoricalRssiByGatewayQuery,Tn=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Pn=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},Et=k.v1.injectEndpoints({endpoints:function(s){return{fetchSensorDeviceRelationships:s.query({query:function(n){var t=n.serial;return{url:"devices/".concat(t,"/sensor/relationships")}}}),updateSensorDeviceRelationships:s.mutation({query:function(n){var t=n.serial,i=n.relationships;return{url:"devices/".concat(t,"/sensor/relationships"),method:"PUT",body:i}},onQueryStarted:function(n,t){return Tn(this,arguments,void 0,function(i,a){var o,l,u=i.serial,m=a.dispatch,d=a.queryFulfilled;return Pn(this,function(p){switch(p.label){case 0:return p.trys.push([0,2,,3]),[4,d];case 1:return o=p.sent().data,m(Et.util.updateQueryData("fetchSensorDeviceRelationships",{serial:u},function(g){Object.assign(g,o)})),[3,3];case 2:return l=p.sent(),console.error(typeof l=="object"?JSON.stringify(l):l),[3,3];case 3:return[2]}})})}})}}}),Pf=Et.useFetchSensorDeviceRelationshipsQuery,Of=Et.useUpdateSensorDeviceRelationshipsMutation,On=["trunk","access","stack","routed","svl","dad"],Sn=["root guard","bpdu guard","loop guard","disabled"],Dn=["Destination port","Source port","Not mirroring traffic"],Rn={"Auto negotiate":"auto","10 Gigabit full duplex (forced)":"10Gfdx","5 Gigabit full duplex (forced)":"5Gfdx","2.5 Gigabit full duplex (forced)":"2.5Gfdx","1 Gigabit full duplex (auto)":"1G-auto","1 Gigabit full duplex (forced)":"1Gfdx","100 Megabit (auto)":"100M-auto","100 Megabit half duplex (forced)":"100Mhdx","100 Megabit full duplex (forced)":"100Mfdx","10 Megabit (auto)":"10M-auto","10 Megabit half duplex (forced)":"10Mhdx","10 Megabit full duplex (forced)":"10Mfdx","25 Gigabit half duplex (forced)":"25Ghdx","25 Gigabit full duplex (forced)":"25Gfdx","25 Gigabit (auto)":"25G-auto","40 Gigabit half duplex (forced)":"40Ghdx","40 Gigabit full duplex (forced)":"40Gfdx","40 Gigabit (auto)":"40G-auto","100 Gigabit half duplex (forced)":"100Ghdx","100 Gigabit full duplex (forced)":"100Gfdx","100 Gigabit (auto)":"100G-auto","No-negotiate full duplex (forced)":"nonegotiate-fdx","No-negotiate half duplex (forced)":"nonegotiate-hdx"},Gi=Object.keys(Rn),zn=["Alert only","Enforce"],An=["Open","Custom access policy","MAC allow list","Sticky MAC allow list"],xn=e.Ay.object({portId:e.Ay.string(),name:e.Ay.string().nullable(),tags:e.Ay.array(e.Ay.string()),enabled:e.Ay.boolean(),poeEnabled:e.Ay.boolean(),type:e.Ay.enum(On),vlan:e.Ay.number().nullable(),voiceVlan:e.Ay.number().nullable(),allowedVlans:e.Ay.string().nullable(),activeVlans:e.Ay.string().nullable().optional(),isolationEnabled:e.Ay.boolean(),rstpEnabled:e.Ay.boolean(),stpGuard:e.Ay.enum(Sn),linkNegotiation:e.Ay.enum(Gi),linkNegotiationCapabilities:e.Ay.array(e.Ay.enum(Gi)),portScheduleId:e.Ay.string().nullable(),schedule:e.Ay.object({id:e.Ay.string(),name:e.Ay.string()}).nullable(),udld:e.Ay.enum(zn),adaptivePolicyGroupId:e.Ay.string().nullable().optional(),adaptivePolicyVoiceGroupId:e.Ay.string().nullable().optional(),adaptivePolicyGroup:e.Ay.object({id:e.Ay.string(),name:e.Ay.string()}).nullable().optional(),adaptivePolicyVoiceGroup:e.Ay.object({id:e.Ay.string(),name:e.Ay.string()}).nullable().optional(),peerSgtCapable:e.Ay.boolean().nullable().optional(),accessPolicyType:e.Ay.enum(An),macAllowList:e.Ay.array(e.Ay.string()).optional(),stickyMacAllowList:e.Ay.array(e.Ay.string()).optional(),stickyMacAllowListLimit:e.Ay.number().optional(),macWhitelistLimit:e.Ay.number().optional(),stormControlEnabled:e.Ay.boolean().optional(),accessPolicyNumber:e.Ay.number().optional(),daiTrusted:e.Ay.boolean(),profile:e.Ay.object({enabled:e.Ay.boolean(),id:e.Ay.string(),iname:e.Ay.string().nullish()}).optional(),module:e.Ay.object({model:e.Ay.string().nullable(),active:e.Ay.boolean().nullable()}).optional(),mirror:e.Ay.object({mode:e.Ay.enum(Dn)}).optional(),dot3az:e.Ay.object({enabled:e.Ay.boolean()}).optional(),stpPortFastTrunk:e.Ay.boolean().nullable().optional()}),Nn=e.Ay.array(xn),Bi=function(s){return{type:"getDeviceSwitchPorts",id:s}},qi=Bi("ALL"),Cn=k.v1.enhanceEndpoints({addTagTypes:[qi.type]}).injectEndpoints({endpoints:function(s){return{getDeviceSwitchPorts:s.query({query:function(n){var t=n.serial;return{url:"devices/".concat(t,"/switch/ports")}},transformResponse:function(n,t,i){var a=Nn.safeParse(n);return a.success||console.warn("Invalid schema received for getDeviceSwitchPorts",JSON.stringify(i),a.error),n},providesTags:function(n){var t,i=[qi],a=(t=n?.map(function(o){return Bi(o.portId)}))!==null&&t!==void 0?t:[];return i.concat(a)}})}}}),Sf=Cn.useGetDeviceSwitchPortsQuery,Vi=k.v1.enhanceEndpoints({addTagTypes:[se.Ye]}).injectEndpoints({endpoints:function(s){var n=s.mutation,t=s.query;return{getDeviceInterfaces:t({query:function(i){var a=i.path.serial;return"devices/".concat(a,"/switch/routing/interfaces")},transformResponse:(0,Ae._j)(vo,"devices/:serial/switch/routing/interfaces"),providesTags:[se.Ye]}),createDeviceInterface:n({query:function(i){var a=i.path.serial,o=i.body;return{url:"devices/".concat(a,"/switch/routing/interfaces"),method:"POST",body:o}},transformResponse:function(i,a,o){var l=yo.safeParse(i);return l.success||console.warn("Invalid schema received for createDeviceInterface",JSON.stringify(o),l.error),i},invalidatesTags:[se.Ye]})}}}),Df=Vi.useGetDeviceInterfacesQuery,Rf=Vi.useCreateDeviceInterfaceMutation,zf=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial"),interfaceId:e.Yj().describe("Interface ID")})}),Ln=e.Ik({dhcpMode:e.k5(["dhcpDisabled","dhcpServer","dhcpRelay"]).optional().describe("The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')"),dhcpRelayServerIps:e.YO(e.Yj()).optional().describe("The DHCP relay IPs when DHCP mode is 'dhcpRelay'"),dhcpLeaseTime:e.Yj().optional().describe("The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')"),dhcpDefaultRouterOption:e.k5(["switch","custom"]).optional().describe("Whether to use this switch or custom IP addresses as the default gateway for DHCP clients."),dhcpDefaultRouterIps:e.Yj().optional().describe('IP address(es) of routers to use as default gateways when `dhcpDefaultRouterOption` is set to "custom".'),dhcpDomainName:e.Yj().optional().describe(`The "domain" portion of a node's Fully Qualified Domain Name (FQDN).`),dnsNameserversOption:e.Yj().optional().describe("The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')"),dnsCustomNameservers:e.YO(e.Yj().optional()).optional().describe("The DHCP name server IPs when DHCP name server option is 'custom'"),bootOptionsEnabled:e.zM().optional().describe("Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface"),bootNextServer:e.Yj().optional().describe("The PXE boot server IP for the DHCP server running on the switch stack interface"),bootFileName:e.Yj().optional().describe("The PXE boot server file name for the DHCP server running on the switch stack interface"),dhcpOptions:e.YO(e.Ik({code:e.Yj().describe("The code for DHCP option which should be from 2 to 254"),type:e.k5(["text","ip","integer","hex"]).describe("The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')"),value:e.Yj().describe("The value of the DHCP option")})).optional().describe("Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface"),reservedIpRanges:e.YO(e.Ik({start:e.Yj().describe("The starting IP address of the reserved IP range"),end:e.Yj().describe("The ending IP address of the reserved IP range"),comment:e.Yj().optional().describe("The comment for the reserved IP range")})).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface"),fixedIpAssignments:e.YO(e.Ik({name:e.Yj().describe("The name of the client which has fixed IP address"),mac:e.Yj().describe("The MAC address of the client which has fixed IP address"),ip:e.Yj().describe("The IP address of the client which has fixed IP address assigned to it")})).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface")}).optional(),Af=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial"),interfaceId:e.Yj().describe("Interface ID")}),body:e.Ik({dhcpMode:e.k5(["dhcpDisabled","dhcpRelay","dhcpServer"]).optional().describe(`The DHCP mode options for the switch interface
       ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')`),dhcpRelayServerIps:e.YO(e.Yj().optional()).optional().describe("The DHCP relay server IPs to which DHCP packets would get relayed for the switch interface"),dhcpLeaseTime:e.k5(["1 day","1 hour","1 week","12 hours","30 minutes","4 hours"]).optional().describe(`The DHCP lease time config for the dhcp server running on switch interface
        ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')`),dnsNameserversOption:e.k5(["custom","googlePublicDns","openDns"]).optional().describe(`The DHCP name server option for the dhcp server running on the switch interface
        ('googlePublicDns', 'openDns' or 'custom')`),dnsCustomNameservers:e.YO(e.Yj().optional()).optional().describe(`The DHCP name server IPs when DHCP name server option is
        'custom'`),bootOptionsEnabled:e.zM().optional().describe(`Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch
        interface`),bootNextServer:e.Yj().optional().describe("The PXE boot server IP for the DHCP server running on the switch interface"),bootFileName:e.Yj().optional().describe("The PXE boot server filename for the DHCP server running on the switch interface"),dhcpOptions:e.YO(e.Ik({code:e.Yj().describe("The code for DHCP option which should be from 2 to 254"),type:e.k5(["hex","integer","ip","text"]).describe(`The type of the DHCP option which should be one of
          ('text', 'ip', 'integer' or 'hex')`),value:e.Yj().describe("The value of the DHCP option")})).optional().describe("Array of DHCP options consisting of code, type and value for the DHCP server running on the switch interface"),reservedIpRanges:e.YO(e.Ik({start:e.Yj().describe("The starting IP address of the reserved IP range"),end:e.Yj().describe("The ending IP address of the reserved IP range"),comment:e.Yj().optional().describe("The comment for the reserved IP range")})).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch interface"),fixedIpAssignments:e.YO(e.Ik({name:e.Yj().describe("The name of the client which has fixed IP address"),mac:e.Yj().describe("The MAC address of the client which has fixed IP address"),ip:e.Yj().describe("The IP address of the client which has fixed IP address assigned to it")})).optional().describe("Array of DHCP fixed IP assignments for the DHCP server running on the switch interface")}).optional()}),Mn=e.Ik({dhcpMode:e.Yj().optional().describe("The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')"),dhcpRelayServerIps:e.YO(e.Yj().optional()).optional().describe("The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface"),dhcpLeaseTime:e.Yj().optional().describe("The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')"),dhcpDefaultRouterOption:e.k5(["switch","custom"]).optional().describe("Whether to use this switch or custom IP addresses as the default gateway for DHCP clients."),dhcpDefaultRouterIps:e.Yj().optional().describe('IP address(es) of routers to use as default gateways when `dhcpDefaultRouterOption` is set to "custom".'),dhcpDomainName:e.Yj().optional().describe(`The "domain" portion of a node's Fully Qualified Domain Name (FQDN).`),dnsNameserversOption:e.Yj().optional().describe("The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')"),dnsCustomNameservers:e.YO(e.Yj().optional()).optional().describe("The DHCP name server IPs when DHCP name server option is 'custom'"),bootOptionsEnabled:e.zM().optional().describe("Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface"),bootNextServer:e.Yj().optional().describe("The PXE boot server IP for the DHCP server running on the switch stack interface"),bootFileName:e.Yj().optional().describe("The PXE boot server file name for the DHCP server running on the switch stack interface"),dhcpOptions:e.YO(e.Ik({code:e.Yj().optional().describe("The code for DHCP option which should be from 2 to 254"),type:e.Yj().optional().describe("The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')"),value:e.Yj().optional().describe("The value of the DHCP option")}).optional()).optional().describe("Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface"),reservedIpRanges:e.YO(e.Ik({start:e.Yj().optional().describe("The starting IP address of the reserved IP range"),end:e.Yj().optional().describe("The ending IP address of the reserved IP range"),comment:e.Yj().optional().describe("The comment for the reserved IP range")}).optional()).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface"),fixedIpAssignments:e.YO(e.Ik({name:e.Yj().optional().describe("The name of the client which has fixed IP address"),mac:e.Yj().optional().describe("The MAC address of the client which has fixed IP address"),ip:e.Yj().optional().describe("The IP address of the client which has fixed IP address assigned to it")}).optional()).optional().describe("Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface")}).optional(),_t="DeviceInterfaceDhcpTag",Ei=k.v1.enhanceEndpoints({addTagTypes:[_t,se.Ye]}).injectEndpoints({endpoints:function(s){var n=s.mutation,t=s.query;return{fetchDeviceInterfaceDhcp:t({query:function(i){var a=i.path,o=a.serial,l=a.interfaceId;return{url:"devices/".concat(o,"/switch/routing/interfaces/").concat(l,"/dhcp"),method:"GET"}},transformResponse:function(i,a,o){var l=Ln.safeParse(i);return l.success||console.warn("Invalid schema received for fetchDeviceInterfaceDhcp",JSON.stringify(o),l.error),i},providesTags:[_t]}),updateDeviceInterfaceDhcp:n({query:function(i){var a=i.path,o=a.serial,l=a.interfaceId,u=i.body;return{url:"devices/".concat(o,"/switch/routing/interfaces/").concat(l,"/dhcp"),method:"PUT",body:u}},transformResponse:function(i,a,o){var l=Mn.safeParse(i);return l.success||console.warn("Invalid schema received for updateDeviceInterfaceDhcp",JSON.stringify(o),l.error),i},invalidatesTags:[_t,se.Ye]})}}}),xf=Ei.useFetchDeviceInterfaceDhcpQuery,Nf=Ei.useUpdateDeviceInterfaceDhcpMutation,Cf=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial")}),body:e.Ik({name:e.Yj().optional().describe("Name or description for layer 3 static route"),subnet:e.Yj().describe("The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("IP address of the next hop device to which the device sends its traffic for the subnet"),advertiseViaOspfEnabled:e.zM().optional().describe("Option to advertise static route via OSPF"),preferOverOspfRoutesEnabled:e.zM().optional().describe("Option to prefer static route over OSPF routes"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().describe("The VRF settings of the interface.")})}),Fn=e.Ik({staticRouteId:e.Yj().describe("The identifier of a layer 3 static route"),name:e.Yj().optional().describe("The name or description of the layer 3 static route"),subnet:e.Yj().describe("The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("The IP address of the router to which traffic for this destination network should be sent"),managementNextHop:e.Yj().optional().describe("Optional fallback IP address for management traffic"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().describe("VRF settings"),advertiseViaOspfEnabled:e.zM().optional().describe("Option to advertise static routes via OSPF"),preferOverOspfRoutesEnabled:e.zM().optional().describe("Option to prefer static routes over OSPF routes")}),Lf=e.Ik({path:e.Ik({serial:e.Yj().describe("Serial"),staticRouteId:e.Yj().describe("Static route ID")}),body:e.Ik({name:e.Yj().optional().describe("Name or description for layer 3 static route"),subnet:e.Yj().optional().describe("The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().optional().describe("IP address of the next hop device to which the device sends its traffic for the subnet"),managementNextHop:e.Yj().optional().describe("Optional fallback IP address for management traffic"),advertiseViaOspfEnabled:e.zM().optional().describe("Option to advertise static route via OSPF"),preferOverOspfRoutesEnabled:e.zM().optional().describe("Option to prefer static route over OSPF routes"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().describe("The VRF settings of the interface.")}).optional()}),Gn=e.Ik({staticRouteId:e.Yj().describe("The identifier of a layer 3 static route"),name:e.Yj().optional().optional().describe("The name or description of the layer 3 static route"),subnet:e.Yj().describe("The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)"),nextHopIp:e.Yj().describe("The IP address of the router to which traffic for this destination network should be sent"),managementNextHop:e.Yj().optional().optional().describe("Optional fallback IP address for management traffic"),vrf:e.Ik({name:e.Yj().optional().describe("The name of the VRF this static route belongs to"),leakRouteToDefaultVrf:e.zM().optional().describe("Whether or not next-hop IP is reachable via default VRF")}).optional().optional().describe("VRF settings"),advertiseViaOspfEnabled:e.zM().optional().optional().describe("Option to advertise static routes via OSPF"),preferOverOspfRoutesEnabled:e.zM().optional().optional().describe("Option to prefer static routes over OSPF routes")}),_i=k.v1.enhanceEndpoints({addTagTypes:[se.jr]}).injectEndpoints({endpoints:function(s){var n=s.mutation;return{createDeviceSwitchRoutingStaticRoute:n({query:function(t){var i=t.path.serial,a=t.body;return{url:"devices/".concat(i,"/switch/routing/staticRoutes"),method:"POST",body:a}},transformResponse:function(t,i,a){var o=Fn.safeParse(t);return o.success||console.warn("Invalid schema received for createDeviceSwitchRoutingStaticRoute",JSON.stringify(a),o.error),t},invalidatesTags:[se.jr]}),updateDeviceSwitchRoutingStaticRoute:n({query:function(t){var i=t.path,a=i.serial,o=i.staticRouteId,l=t.body;return{url:"devices/".concat(a,"/switch/routing/staticRoutes/").concat(o),method:"PUT",body:l}},transformResponse:function(t,i,a){var o=Gn.safeParse(t);return o.success||console.warn("Invalid schema received for updateDeviceSwitchRoutingStaticRoute",JSON.stringify(a),o.error),t},invalidatesTags:[se.jr]})}}}),Mf=_i.useCreateDeviceSwitchRoutingStaticRouteMutation,Ff=_i.useUpdateDeviceSwitchRoutingStaticRouteMutation,Bn=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},qn=k.v1.enhanceEndpoints({addTagTypes:["NetworkGroup"]}).injectEndpoints({endpoints:function(s){return{getNetworkGroupsOverviews:s.query({query:function(n){return{url:"organizations/".concat(n,"/networks/groups/overview/byGroup?sortBy=status")}},providesTags:function(n){return n?.items?Bn([{type:"NetworkGroup",id:"LIST"}],n.items.map(function(t){return{type:"NetworkGroup",id:t.groupId}}),!0):[{type:"NetworkGroup",id:"LIST"}]}})}}}),Gf=qn.useGetNetworkGroupsOverviewsQuery,Ui=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},Hi=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},Qi=function(s,n,t){if(t||arguments.length===2)for(var i=0,a=n.length,o;i<a;i++)(o||!(i in n))&&(o||(o=Array.prototype.slice.call(n,0,i)),o[i]=n[i]);return s.concat(o||Array.prototype.slice.call(n))},ot=k.v1.enhanceEndpoints({addTagTypes:["NetworkGroup"]}).injectEndpoints({endpoints:function(s){return{createNetworkGroup:s.mutation({query:function(n){var t=n.organizationId,i=n.name;return{url:"organizations/".concat(t,"/networks/groups"),method:"POST",body:{name:i}}},invalidatesTags:function(n,t){return t?[]:[{type:"NetworkGroup",id:"LIST"}]}}),updateNetworkGroup:s.mutation({query:function(n){var t=n.organizationId,i=n.groupId,a=n.name;return{url:"organizations/".concat(t,"/networks/groups/").concat(i),method:"PUT",body:{name:a}}},invalidatesTags:function(n,t,i){var a=i.groupId;return t?[]:[{type:"NetworkGroup",id:a}]}}),deleteNetworkGroup:s.mutation({query:function(n){var t=n.organizationId,i=n.groupId;return{url:"organizations/".concat(t,"/networks/groups/").concat(i),method:"DELETE"}},invalidatesTags:function(n,t){return t?[]:[{type:"NetworkGroup",id:"LIST"}]}}),deleteNetworkGroups:s.mutation({queryFn:function(n){return Ui(this,arguments,void 0,function(t){var i,a,o,l,u,m=t.organizationId,d=t.token,p=t.groupIds,g=t.synchronous,q=g===void 0?!1:g,Z=t.maxPollingTime,U=Z===void 0?60*1e3:Z;return Hi(this,function(pe){switch(pe.label){case 0:return pe.trys.push([0,2,,3]),i={auth:{csrfToken:d}},a={synchronous:q,maxPollingTime:U},o=p.map(function(fe){return{operation:"destroy",resource:"/organizations/".concat(m,"/networks/groups/").concat(fe),body:{}}}),[4,(0,C.batchedApiRequest)(m,o,i,a)];case 1:return l=pe.sent(),[2,{data:l.data}];case 2:return u=pe.sent(),[2,{error:u}];case 3:return[2]}})})},invalidatesTags:function(n,t){return t?[]:[{type:"NetworkGroup",id:"LIST"}]}}),bulkAssignNetworkGroup:s.mutation({query:function(n){var t=n.organizationId,i=n.groupId,a=n.networkIds;return{url:"organizations/".concat(t,"/networks/groups/").concat(i,"/bulkAssign"),method:"POST",body:{networkIds:a}}},invalidatesTags:function(n,t){return t?[]:[{type:"NetworkGroup",id:"LIST"}]}}),bulkUnassignNetworkGroup:s.mutation({query:function(n){var t=n.organizationId,i=n.groupId,a=n.networkIds;return{url:"organizations/".concat(t,"/networks/groups/").concat(i,"/bulkUnassign"),method:"POST",body:{networkIds:a}}},invalidatesTags:function(n,t){return t?[]:[{type:"NetworkGroup",id:"LIST"}]}}),bulkAssignUnassignNetworkGroups:s.mutation({queryFn:function(n){return Ui(this,arguments,void 0,function(t){var i,a,o,l,u,m=t.organizationId,d=t.token,p=t.unassignActions,g=t.assignActions,q=t.synchronous,Z=q===void 0?!1:q,U=t.maxPollingTime,pe=U===void 0?60*1e3:U;return Hi(this,function(fe){switch(fe.label){case 0:return fe.trys.push([0,2,,3]),i={auth:{csrfToken:d}},a={synchronous:Z,maxPollingTime:pe},o=Qi(Qi([],p,!0),g,!0),[4,(0,C.batchedApiRequest)(m,o,i,a)];case 1:return l=fe.sent(),[2,{data:l.data}];case 2:return u=fe.sent(),[2,{error:u}];case 3:return[2]}})})},invalidatesTags:function(n,t){return t?[]:[{type:"NetworkGroup",id:"LIST"}]}})}}}),Bf=ot.useCreateNetworkGroupMutation,qf=ot.useUpdateNetworkGroupMutation,Vf=ot.useDeleteNetworkGroupMutation,Ef=ot.useDeleteNetworkGroupsMutation,_f=ot.useBulkAssignNetworkGroupMutation,Uf=ot.useBulkUnassignNetworkGroupMutation,Hf=ot.useBulkAssignUnassignNetworkGroupsMutation,Vn=function(s,n,t,i){function a(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function u(p){try{d(i.next(p))}catch(g){l(g)}}function m(p){try{d(i.throw(p))}catch(g){l(g)}}function d(p){p.done?o(p.value):a(p.value).then(u,m)}d((i=i.apply(s,n||[])).next())})},En=function(s,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},i,a,o,l;return l={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(l[Symbol.iterator]=function(){return this}),l;function u(d){return function(p){return m([d,p])}}function m(d){if(i)throw new TypeError("Generator is already executing.");for(;l&&(l=0,d[0]&&(t=0)),t;)try{if(i=1,a&&(o=d[0]&2?a.return:d[0]?a.throw||((o=a.return)&&o.call(a),0):a.next)&&!(o=o.call(a,d[1])).done)return o;switch(a=0,o&&(d=[d[0]&2,o.value]),d[0]){case 0:case 1:o=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,a=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!o||d[1]>o[0]&&d[1]<o[3])){t.label=d[1];break}if(d[0]===6&&t.label<o[1]){t.label=o[1],o=d;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(d);break}o[2]&&t.ops.pop(),t.trys.pop();continue}d=n.call(s,t)}catch(p){d=[6,p],a=0}finally{i=o=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}},_n=k.v1.enhanceEndpoints({addTagTypes:[le,gt]}),Un=D.injectEndpoints({endpoints:function(s){return{unclaimSubscription:s.mutation({query:function(n){return{url:"licensing/subscription/subscriptions/".concat(n.subscriptionId,"/unclaim"),method:"POST",headers:{"Content-type":"application/json; charset=UTF-8"}}},onQueryStarted:function(n,t){return Vn(this,arguments,void 0,function(i,a){var o,l=a.dispatch,u=a.queryFulfilled;return En(this,function(m){switch(m.label){case 0:return m.trys.push([0,2,,3]),[4,u];case 1:return m.sent(),l(_n.util.invalidateTags([le,gt])),[3,3];case 2:return o=m.sent(),[3,3];case 3:return[2]}})})}})}}}),Qf=Un.useUnclaimSubscriptionMutation,Hn=D.injectEndpoints({endpoints:function(s){return{getTemporaryPermissionsAccess:s.query({query:function(n){var t=n.networkId,i=n.organizationId;return{url:"temporaryPermissions/access",params:{networkId:t,organizationId:i}}}})}}}),Wf=Hn.useGetTemporaryPermissionsAccessQuery,Ut=D.injectEndpoints({endpoints:function(s){return{extendTemporaryPermission:s.mutation({query:function(n){return{url:"support_admin/header/temporary_permissions/extend_temporary_permission",method:"POST",params:{orgId:n}}}}),expireTemporaryPermission:s.mutation({query:function(n){return{url:"support_admin/header/temporary_permissions/expire_temporary_permission",method:"POST",params:{orgId:n}}}}),getTimeRemaining:s.mutation({query:function(n){return{url:"support_admin/header/temporary_permissions/get_time_remaining",method:"POST",params:{orgId:n}}}})}}}),Kf=Ut.useExtendTemporaryPermissionMutation,Xf=Ut.useExpireTemporaryPermissionMutation,Jf=Ut.useGetTimeRemainingMutation,Qn=j(4249)},7869:(me,$,j)=>{j.d($,{d:()=>V});var f=j(1558),F=j(6624),C=j(4337),N=j.n(C),K=j(2235),D=j(5586),V=(0,f.xP)({reducerPath:"@dashboard/store/dashboardPreferences",baseQuery:(0,F.L5)((0,C.fetchBaseQuery)({baseUrl:"/dashboardPreferencesApi/",paramsSerializer:K.DK,transformHeaders:D.P}),{maxRetries:0}),endpoints:function(){return{}}})},7879:(me,$,j)=>{j.d($,{vR:()=>Q});var f=Object.defineProperty,F=Object.defineProperties,C=Object.getOwnPropertyDescriptors,N=Object.getOwnPropertySymbols,K=Object.prototype.hasOwnProperty,D=Object.prototype.propertyIsEnumerable,V=(R,L,G)=>L in R?f(R,L,{enumerable:!0,configurable:!0,writable:!0,value:G}):R[L]=G,E=(R,L)=>{for(var G in L||(L={}))K.call(L,G)&&V(R,G,L[G]);if(N)for(var G of N(L))D.call(L,G)&&V(R,G,L[G]);return R},_=(R,L)=>F(R,C(L)),H=(R,L)=>{var G={};for(var ee in R)K.call(R,ee)&&L.indexOf(ee)<0&&(G[ee]=R[ee]);if(R!=null&&N)for(var ee of N(R))L.indexOf(ee)<0&&D.call(R,ee)&&(G[ee]=R[ee]);return G},W=Object.defineProperty,X=(R,L)=>W(R,"name",{value:L,configurable:!0});const ne=X(R=>{window.dataLayer=window.dataLayer||[],window.dataLayer.push(R)},"dataLayerPush"),ce=new Map,ae=null,Q=X(R=>{const L=ce.get(`mds_${R.component}`)||new Set,G={};L.forEach(ee=>{G[ee]=void 0}),Object.entries(R.data||{}).forEach(([ee,he])=>{G[ee]=he,L.add(ee)}),ce.set(`mds_${R.component}`,L),ne(_(E({},G),{category:R.category,component_name:R.id,event:`mds_${R.component}`,interaction:R.event}))},"sendMdsAnalytics"),ye=null,Se={switch:"switch_list",wireless:"ap_list",camera:"camera_list"};var ke=Object.defineProperty,Ge=(R,L)=>ke(R,"name",{value:L,configurable:!0});const xe=null;var Ne=Object.defineProperty,ue=(R,L)=>Ne(R,"name",{value:L,configurable:!0});let Ye=!1;const T=null,Qe=null,Be=null,qe=null,Ce=null;var Te=Object.defineProperty,Ve=(R,L)=>Te(R,"name",{value:L,configurable:!0});const We={wireless:"ap_list",switch:"switch_list"},De=null,Re=null;var Ee=Object.defineProperty,k=(R,L)=>Ee(R,"name",{value:L,configurable:!0});const ze=null;var Le=Object.defineProperty,Ie=(R,L)=>Le(R,"name",{value:L,configurable:!0});const Ze=null},8065:(me,$,j)=>{j.d($,{li:()=>N,bs:()=>V,q7:()=>H});var f=j(5824),F=(0,f.createAction)("auth/setToken"),C={token:void 0},N=(0,f.createReducer)(C,function(W){W.addCase(F,function(X,ne){X.token=ne.payload})}),K=(0,f.createAction)("network/setNetworkEid"),D={eid:void 0},V=(0,f.createReducer)(D,function(W){W.addCase(K,function(X,ne){X.eid=ne.payload})}),E=(0,f.createAction)("organization/setOrganizationEid"),_={eid:void 0},H=(0,f.createReducer)(_,function(W){W.addCase(E,function(X,ne){X.eid=ne.payload})})},8165:(me,$,j)=>{j.d($,{n:()=>F});var f=j(6072);const F=()=>{const[C,N]=(0,f.useState)(!1),[K,D]=(0,f.useState)(""),[V,E]=(0,f.useState)([]),[_,H]=(0,f.useState)(0),[W,X]=(0,f.useState)(!1);return{isSearchModalOpen:C,setIsSearchModalOpen:N,searchInputVal:K,setSearchInputVal:D,filteredMenuData:V,setFilteredMenuData:E,currentFocusedItem:_,setCurrentFocusedId:H,isFeedbackFormModalOpen:W,setIsFeedbackFormModalOpen:X}}}}]);
